-- =======================================================================
--[[    Interaction Dot Marks ("DotMarks")
-- ===================================================================--]]
script_name     = "ui_hud_dotmarks"
--[[======================================================================
	Author: Catspaw (CatspawMods @ ModDB)
	Source: https://github.com/CatspawMods/Anomaly-Addon-Archive

	I post gameplay video on my Youtube channel, Catspaw Adventures: 
	https://www.youtube.com/@CatspawAdventures
-- =======================================================================
	A blatant imitation of the "interaction dot" HUD markers in Stalker 2,
	and some of its other UI niceties such as floating prompts and 
	secondary interactions.

	Except not quite as cool, because Anomaly is jank. Hopefully this 
	makes it a little less jank.

	Also implements a "Secondary Interact" keybind with contextual 
	actions such as unloading a weapon without having to pick it up.
-- =======================================================================
	See dotmarks_main.script for dependencies.
-- =======================================================================
	TODO (all non-critical, prioritize marked *):
	* Investigate markers and missing dialogue option for wounded enemies
	* Try again to fix items cycling behind the player
		See commented-out code for broken version
	- Investigate why prompt_fade_out_time isn't working, disable for now
	- Smoother fade in/out for the extended visibility range of explosives
		Markers in general aren't fading as nicely as they use to do
		probably related to the changes to near_scan and early_scan radii
		low priority but not unimportant
	- Try again to add drop shadows/background to the Utjan dots
		I think the way to go is to replace the existing dots with the new
		shadows in the logic, then attach the original dots on top
	- Investigate how to anchor campfire tutorial prompts to the campfires
		Need to confirm their true vanilla interact distance
		Probably hook into existing check for nearest, then add a flag to
		force a prompt active when its linked tutorial is
	- Add "welcome" message similar to PAW, controlled by MCM flag

	BEFORE PUBLIC RELEASE:
	- I don't think I checked the button for taking the X8 elevator back up
	- Optimize/clean up WIP code that didn't get used
		Check each function for usage across all scripts
	- Re-validate EVERY FEATURE individually - all must pass in same build

	POST-RELEASE:
	- MCM live preview for prompt elements - lots of work
	- Encyclopedia entry/entries - relatively easy, just need writing
	- NPE module(s) - not hard, but time-consuming and low priority
	- Try to improve the drop shadows on the item card elements
-- ===================================================================--]]
--      DEPENDENCIES
-- =======================================================================
assert(dotmarks_main, "\n\n"..
	"! ui_hud_dotmarks requires script dotmarks_main, which does not exist or failed to load!\n\n"
)
assert(dotmarks_mcm, "\n\n"..
	"! ui_hud_dotmarks requires script dotmarks_mcm, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_common and utils_catspaw_common.import_metatable, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_common, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_hudmarks, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_hudmarks, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_text and utils_catspaw_text.bindtext, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_text, which is missing or outdated!\n" ..
	"Version found: " .. (utils_catspaw_text and utils_catspaw_text.script_version or "missing!") .. " | Required: 1.4+\n" ..
	"If the version is outdated, try moving this addon to the bottom of your load order."
)
assert(utils_catspaw_mapspots, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_mapspots, which does not exist or failed to load!\n\n"
)
utils_catspaw_common.import_metatable(this, dotmarks_main)
-- =======================================================================
local dl, vl, xml
logprefix   = "[DotMarks] "
debuglogs   = false
verbose     = false
debug_dump  = false

function allow_local_logging(onoff)
	-- By default, logging in this script inherits its debuglogs/verbose settings from utils_catspaw_common
	-- This function allows anyone to temporarily switch on debug logging for this script's operations only
	if onoff then
		dl = function(logtext, ...) dlog(this, logtext, ...) end
		vl = function(logtext, ...) vlog(this, logtext, ...) end
	else
		dl = function(logtext, ...) dlog(nil, logtext, ...) end
		vl = function(logtext, ...) vlog(nil, logtext, ...) end
	end
end
allow_local_logging(true)

local function dump(logtext, ...)
	return debug_dump and logtext and printf(logprefix .. logtext, ...)
end

local function alert(logtext, ...)
	if not logtext then return end
	printf("! " .. logprefix .. logtext, ...)
end

function set_debug_logging(debug_en, verbose_en, dump_en)
	if (debug_en ~= nil) then debuglogs = debug_en end
	if (verbose_en ~= nil) then verbose = verbose_en end
	if (dump_en ~= nil) then debug_dump = dump_en end
end

set_debug_logging(true, true, true) --uncomment this line to enable all logging for troubleshooting

-- First two values will be overridden by MCM once the game loads
-- debug_dump is EXTREMELY noisy and should only ever be manually enabled for a specific reason

-- ======================================================================
--      SHORTCUTS
-- ======================================================================
local get_mcm           = get_mcm_or_default_val
local nameid            = obj_name_and_id
local get_argb          = utils_catspaw_mapspots.get_argb
local is_already_target = utils_catspaw_hudmarks.is_object_already_targeted
local get_task_target   = utils_catspaw_taskmonitor and utils_catspaw_taskmonitor.get_active_target_id or function() end
local tuthooks          = modxml_tutorial_hooks
local is_favorite       = zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.is_favorite
local is_junk           = zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.is_junk
local fdda_pickup       = z_fdda_pickup_intercept_dotmarks
local fddar_bodysearch  = liz_fdda_redone_body_search
local gts               = game.translate_string
-- ======================================================================
valid_mcm_version       = dotmarks_mcm.valid_mcm_version
targeted_id, locked_id  = nil
scanning                = false
pickup_index            = {}
nearby_pickups          = {}
active_anims            = {}
-- ======================================================================
local st_kg             = gts("st_kg")
local fdda_installed    = false
local fddar_installed   = false
local anims_enabled     = false
local anim_playing      = false
local actor_moved       = false
local maingameui        = nil
local hmm               = nil
local popin_active      = nil
local use_dik           = nil
local fdda_callback     = nil
local hintfilters       = nil
local fallback_font     = 2
local next_skill_upd    = 0
local next_near_scan    = 0
local next_early_scan   = 0
local next_tut_check    = 0

-- ======================================================================
--      HUD MARKER PRESET PATCH
--  Set up "dotmark" preset and patch it into utils_catspaw_hudmarks
-- ======================================================================
utils_catspaw_hudmarks.marker_presets["dotmark"] = (
	function(args)
		--[[    This defines all the "default" values for any marker instantiated as
				a "dotmark" preset by utils_catspaw_hudmarks      --]]
		local id    = args and args.id
		local preset_args = {
			-- ================================================================================
			--  Presets that need to be generated on-marker-create rather than static LTX defs
			-- ================================================================================
			id                  = id,
			far_fade_dist       = near_scan_radius() - 0.5,
			far_hide_dist       = near_scan_radius(),
			far_end_dist        = early_scan_radius() + 3,
			scale_dist_min      = (near_scan_radius() or 4) - 1,
			scale_dist_mid      = (near_scan_radius() or 4) - 0.5,
			scale_dist_max      = (near_scan_radius() or 4),
			los_check_int       = (not cfg.ignore_los) and 250 or nil, -- interval in ms to check LOS to marker object
			los_check_range     = (near_scan_radius() or 4) + 1,
			custom_argb         = dup_table(cfg.colors.clr_dmark_norm),
			marker_scale        = cfg.dot_marker_size,
			func_anim_take_curve= easing.InSine, -- easing function used for item take animation

			coord_args = { -- zero out all default screen coordinate adjustments
				near_adj = 0, 
				far_adj = 0,
				base_y  = 0,
			},
			-- ================================================================================
			func_on_update = (
			-- ================================================================================
			--      MAIN UPDATE LOOP FOR DOT MARKER OBJECTS
			-- ================================================================================
			--  Called from utils_catspaw_hudmarks at the start of every marker update
			--  Determines prompt and marker visibility for most objects
			--  Updates condition/ammo and other metadata that are visible on prompts
			-- ================================================================================

				function(mark, args)
					if not mark then return end -- literally impossible
					if mark.no_update_loop then return end
					if cfg.killswitch_markloop then
						mark:HideAll("killswitch_markloop")
						return
					end
					local now           = time_global()
					local id            = mark.id
					local obj           = id and get_game_object(id)
					if not obj then return end
					local show_pri      = true
					if mark.is_stalker then
						mark.is_enemy   = mark.comm and game_relations.is_factions_enemies(cfg.actor_comm, mark.comm)
						mark.is_wounded = IsWounded(obj) or nil
						mark.is_mute    = not obj:is_talk_enabled()
						mark.hidden     = (mark.hidden and mark.is_mute) or (mark.is_enemy and not mark.is_wounded)
						if mark.is_wounded and not mark.was_wounded then
							local _ = debug_dump and vl("%s detected as wounded: %s", mark.name, mark.is_wounded)
							mark.was_wounded = true
							set_secondary_action(mark)
						end
						if mark.is_mute then
							show_pri = false
							if cfg.hide_mute_stalkers then
								hide_marker_and_prompts(mark.mark_id, "mute stalker")
								return
							end
						end
					end
					local dist          = mark.last_dist or 999
					local in_range      = dist <= (mark.interact_dist or 2.5)
					local hide          = (mark.hidden or (not in_range))
					local _             = (not hide) and dump("[DotMarks] [%s][%s] Visibility and UI checks for %s", mark.id, now, mark.name or mark.tutorial or mark.text)
					
					cfg.in_pickup_range[id] = mark.is_pickup and in_range and dist or nil

					if mark.is_arty and (not mark.in_container) and (not can_actor_see_artefact(obj)) then
						hide_marker_and_prompts(mark.mark_id, "artefact not visible")
						return
					end
					if mark.is_button and mark.use_pri and mark.use_pri.physbtn_active then
						if not mark.use_pri.physbtn_active() then
							hide_marker_and_prompts(mark.mark_id, "inactive button")
							return
						end
					end

					-- ================================================================================
					-- Check whether this marker is for a junk object
					local sec           = obj:section()
					if (not hide) and obj and zzz_rax_sortingplus_mcm and cfg.sp_hide_junk_items then
						hide = is_junk(sec)
					end
					-- ================================================================================
					-- Check whether any logic has shut off interaction prompts entirely
					local targeted      = is_current_target(id)
					local show_sec      = false
					show_pri            = show_pri and targeted and in_range
					--dump("prompt check: hide %s | hidden_show: %s | anim block: %s", hide, cfg.hidden_show_prompts, prompt_blocked_by_anim())
					if (hide and not cfg.hidden_show_prompts) or prompt_blocked_by_anim() then
						--dump("Hiding all prompts")
						_ = mark.use_pri and mark.use_pri:ShowPrompt(false)
						_ = mark.alt_interact and mark.alt_interact:ShowPrompt(false)
					else
						-- ================================================================================
						-- Check marker display conditions and whether animations are playing
						-- ================================================================================
						-- Check availability of primary interact prompt
						if mark.use_pri and mark.use_pri.init_done then
							dump("[DotMarks] Checking whether to show pri interact prompt for %s | targeted %s | in_range %s", mark.name, targeted, in_range)
							if not in_range then
								show_pri = false
							elseif mark.is_npc and (not mark.is_container) then
								local last_squad = mark.squad_id
								mark.squad_id = obj.group_id
								if mark.squad_id ~= last_squad then
									local squad = mark.squad_id and alife_object(mark.squad_id)
									mark.commander_id = squad and squad:commander_id()
								end
								if (not mark.is_alive) then
									local tracked = true
									local empty = is_empty_mutant_corpse(id)
									if empty then
										-- No need to show markers for empty mutant corpses
										vl("Mutant corpse is empty, destroying marker")
										destroy_marker(mark.mark_id, "empty mutant corpse")
										return
									elseif cfg.bodies_use_mpda_rules and item_milpda then
										-- Hide bodies that Milspec PDA won't show
										tracked = (ish_kill_tracker and ish_kill_tracker.tracked_kill and ish_kill_tracker.tracked_kill(id))
										if not tracked then
											hide = true
										end
									end
								end
							elseif mark.is_container and not mark.is_display then
								-- Update contents of inventory containers
								mark.body_claimed = is_body_claimed(id)
								local is_managed_stash = not not (mark.body_claimed or treasure_manager.caches[mark.id])
								local text = ""
								local num_items = 0
								if (not cfg.invboxes[id]) then
									cfg.invboxes[id] = {}
								end
								if not mark.body_claimed then
									if (not cfg.invboxes[id].items) then
										cfg.invboxes[id].items, num_items = get_inventory_table(obj, id)
										_ = debug_dump and vl("[%s] No inventory table for container %s, iterated and found %s items", time_global(), mark.name, num_items)
										if is_managed_stash and (num_items == 0) then
											-- treasure manager stashes return as empty until searched
											cfg.invboxes[id].items = nil
										else
											mark.has_items = num_items > 0
										end
									end
								end

								if cfg.show_stash_weight then
									if cfg.invboxes[id].items then
										if mark.has_items then
											mark.weight = axr_companions.get_inventory_weight(cfg.invboxes[id].items)
											local wc = mark.weight and get_actor_weight_class(mark.weight)
											local code  = wc and cfg.weight_colors[wc] or cfg.weight_colors[0]
											mark.use_pri.parse_text_colors = true
											text = string.format(" ($%s%.2f %s$clr_def)", code, mark.weight, st_kg)
										else
											text = " " .. gts("st_alti_empty")
										end
									elseif mark.body_claimed or (is_managed_stash and not cfg.invboxes[id].items) then
										text = " (" .. gts("st_unknown_contents") .. ")"
									else
										text = " " .. gts("st_alti_empty")
									end
									mark.use_pri:SetPrompt(nil, nil, text)
								end
							end
							-- Passed NPC and container checks
							if in_range then
								if mark.is_pickup then
									if mark.glowstick_sec and can_pickup_glowstick(obj, id, dist) then
										if (not cfg.available_pickup) then
											cfg.available_pickup = id
										end
										if not pickup_index[id] then
											local i = (#nearby_pickups or 0) + 1
											pickup_index[id] = i
											nearby_pickups[i] = id
										end
									end
									-- Mark is an item pickup
									if cfg.show_item_card then
										mark.use_pri:UpdateWeightColor()
									end
								elseif (not show_pri) then
									local available_pickup = mark.is_pickup and cfg.available_pickup and (mark.id == cfg.available_pickup)
									local not_hidden_by_anim = (cfg.show_prompt_during_anim or not anim_playing)
									-- If nothing else has allowed visibility yet, final checks
									show_pri = (
										(locked_id and targeted) or
										(available_pickup and not locked_id) or
										((not mark.is_pickup) and (targeted)) and
										(dist < 5) and (not mark.is_mute) and
										not_hidden_by_anim
									)
								end
								if mark.condition and cfg.show_item_condition then
									-- Update condition for degradable objects
									local cond = obj:condition()
									if cond ~= mark.condition then
										mark.condition = cond
										mark.use_pri:SetConditionText(sec, cond)
										mark.use_pri:SetPrompt()
									end
								end
							end
							--dump("Final primary interact state: %s | %s", show_pri, nameid(mark.name, mark.id), show_pri)
							mark.use_pri:ShowPrompt(show_pri)
							-- ================================================================================
							-- Check availability of secondary interact prompt
							if mark.alt_interact then
								show_sec = show_pri and not mark.body_claimed
								if show_sec then
									if cfg.hide_sec_interact_ui then
										show_sec        = false
										dump("Secondary interactions disabled via config, hiding UI for %s", mark.name)
									else
										if mark.ammo_count and (mark.ammo_count == 0) then
											show_sec    = false
										elseif mark.has_battery and mark.condition and (mark.condition < 0.01) then
											show_sec    = false
										elseif mark.is_container then
											show_sec    = show_pri and mark.has_items
										elseif mark.was_wounded then
											if mark.is_wounded and not cfg.healing_stalker then
												if mark.is_wounded then
													show_sec = not not mark.alt_interact.avail_aid
												else
													show_sec = false
													end_mark_wounded_state(mark)
												end
											end
										end
										dump("[DotMarks] Checking whether to show alt interact prompt for %s | show_pri %s | targeted %s", mark.name, show_pri, targeted)
									end
								end
								if mark.alt_interact then
									mark.alt_interact:ShowPrompt(show_sec)
								end
							end
						end
					end
					_ = debug_dump and vl("[%s][%s] Done with both prompt checks:\n* show_pri %s | show_sec %s | hide %s | pri prompt %s", time_global(), mark.name, show_pri, show_sec, hide, (mark.use_pri ~= nil) and "exists")
					-- ================================================================================
					local texture = mark.texture or ""

					if (not hide) and (mark.use_pri and mark.active_swap) then
						mark:ActiveSwap(show_pri)
						texture = mark.texture
						mark.use_pri:SetupConnectingLine()

						if show_pri and can_start_popin_anim(mark) then
							init_active_marker_popin(mark)
						end
					end

					if (hide or cfg.hide_interaction_dots) then
						-- Clear texture for hidden marker
						texture = ""
					else
						mark.marker_scale = cfg.dot_marker_size
						mark:ScaleMarkerByDistance()
					end
					mark.marker:InitTexture(texture)
					log_marker_update_loop(mark)
				end
			),
			-- ================================================================================
			func_los_check = (
			-- ================================================================================
			--  Runs during the LOS check phase of every marker update
			--  Force LOS check to succeed if the marked object is the current interact target
			-- ================================================================================
				function(mark, args)
					if not (mark.is_pickup or mark.is_stalker or mark.container or mark.is_workshop) then return end
					local pri_shown = (mark and mark.use_pri and mark.use_pri.wnd and mark.use_pri.wnd:IsShown())
					return pri_shown and true or nil
				end
			),
			-- ================================================================================
			func_on_destroy = (
			-- ================================================================================
			--  When any marker is destroyed, unregister that ID and clear its metadata
			-- ================================================================================
				function(mark)
					if not (mark and mark.id) then return end
					vl("Marker for %s destroyed, unregistering", mark.id)
					this.unregister_scanned_entity(mark.id) 
				end
			),
		}
		-- Most static values are loaded from the cfg.dotmark_preset table, thus loaded from the config file
		for k,v in pairs(cfg.dotmark_preset) do
			preset_args[k] = v
		end
		return preset_args
	end
)

-- ======================================================================
--      ACTIVE SWAP OF MARKER ATTRIBUTES
--  Monkeypatches utils_catspaw_hudmarks to add support for hotswapping
--  the marker texture and other parameters on the fly based on states
-- ======================================================================
function utils_catspaw_hudmarks.UIHUDMarker:ActiveSwap(state)
	--dump("[%s][UIHUDMarker:ActiveSwap] for %s: %s", time_global(), self.name or self.tutorial, state)
	if self.destroyed or not (self.active_swap or self.task_swap) then return end
	local is_task_target= match_squad_or_leader(self.args.id, cfg.active_task_target_id) and cfg.enable_icon_tasks
	local is_storyline  = utils_catspaw_taskmonitor and utils_catspaw_taskmonitor.is_task_storyline()
	local last_swap     = self.task_swap or self.active_swap
	self.task_swap      = is_task_target and (is_storyline and cfg.swap_task_pri or cfg.swap_task_sec) or nil
	if state == nil then state = is_current_target(self.id) end
	local _
	if state then
		for k,v in pairs(self.task_swap or self.active_swap) do
			if (popin_active ~= self.mark_id) then
				_ = debug_dump and vl("[%s][%s][Swap on] Setting: %s = %s", time_global(), self.name, k, v)
				self[k] = v
				if self.use_pri then
					self.use_pri.args[k] = v
				end
			end
		end
	else
		for k,v in pairs(last_swap or self.active_swap) do
			self.popin_done = false
			self[k] = self.args[k]
			if self.use_pri then
				self.use_pri.args[k] = self.args[k]
			end
			_ = debug_dump and vl("[%s][%s][Swap off] Reverting: %s = %s", time_global(), self.name, k, self.args[k])
		end

	end
	self.base_w = self.width
	self.base_h = self.height
	
	if self.is_active ~= state then
		vl("[%s][%s] Mark active status changed to %s (was %s)", time_global(), self.name, state, self.is_active)
		self.last_active_state = self.is_active
		self.is_active = state
		self.next_update = 0
	end
end

-- ======================================================================

function IsWounded(obj)
	local var = load_var(obj, "wounded_state")
	return var and (var ~= "") and (var ~= "nil")
end

function end_mark_wounded_state(mark)
	vl("end_mark_wounded_state for %s", mark and mark.name)
	if not (mark and mark.is_stalker and mark.alt_interact) then return end
	mark.is_wounded = nil
	mark.was_wounded = nil
	cfg.healing_stalker = nil
	mark.checked_for_sec = nil
	local obj = mark.id and get_game_object(mark.id)
	mark.alt_interact:Destroy("NPC is no longer wounded")
end

function log_marker_update_loop(mark)
	mark.loop_num = mark.loop_num and (mark.loop_num + 1) or 0
	local _ = debug_dump and vl("[DotMarks] [%s][%s] End of main update loop %s | Final size: [%s x %s]", time_global(), mark.name, mark.loop_num, dec2(mark.width), dec2(mark.height))
end

function hide_marker_and_prompts(mark_id, reason)
	local mark = mark_id and hmm:GetMarker(mark_id)
	if not mark then return end
	if mark.use_pri then
		mark.use_pri:ShowPrompt(false)
	end
	if mark.alt_interact then
		mark.alt_interact:ShowPrompt(false)
	end
	mark.marker:InitTexture("")
	mark:HideAll(reason or "hide_marker_and_prompts called")

end

function destroy_marker(mark_id, reason)
	local _ = debug_dump and dl("Trying to destroy marker %s%s", mark_id, reason and (" | "..reason) or "")
	local mark = hmm:GetMarker(mark_id)
	if mark then mark:Destroy(nil, reason) end
end

function destroy_prompt(tid, reason)
	local _ = debug_dump and dl("Trying to destroy tutorial prompt %s%s", tid, reason and (" | "..reason) or "")
	local mark = tid and cfg.markers[tid]
	if mark then
		mark:Destroy(nil, reason)
		cfg.markers[tid] = nil
	end
end

function killswitch(feature)
	local ks = false
	if feature then
		feature = ("killswitch_" .. feature)
		ks = cfg[feature] or cfg.killswitch_all
	else
		ks = cfg.killswitch_all
	end
	return ks
end

function shut_down()
	scanning = false
	cfg.killswitch_all = true
	set_handler_callbacks(true)
	for k,v in pairs(cfg.markers) do
		if v.mark_id then
			destroy_marker(v.mark_id)
		else
			v:Destroy("shutting down")
		end
	end
end

function get_fddar_current_action()
	return lam2 and lam2.get_current_action()
end

function fddar_update_current_anim_state()
	anim_playing = lam2 and lam2.is_running()
end

function get_fdda_callback()
	fdda_callback = fdda_pickup and fdda_pickup.get_fdda_oibp_callback() or nil
	return fdda_callback
end

function fdda_handles_pickups()
	return get_fdda_callback() and (cfg.fdda_pickup_anim or cfg.fddar_pickup_anim)
end

function item_pickup_intercept(obj, flags)
	if killswitch("pickup") then return end
	-- Called directly by actor_on_item_before_pickup if neither FDDA nor FDDAR are installed
	-- Called by my monkeypatch of FDDA/FDDAR's pickup if they are
	local now = time_global()
	if flags.force then
		-- Skip all long-press checks
	else
		if (cfg.held_key == use_dik) then
			flags.ret_value = false
			return
		elseif cfg.watch_use then
			if (time_global() - (cfg.use_released or 0)) < (cfg.long_press_delay or 50) then
				flags.ret_value = false
				return
			end
		end
	end

	vl("[%s][item_pickup_intercept] Actor tried to take item %s", now, nameid(obj))

	local curr_target, taken_obj
	curr_target = get_current_target()
	taken_obj = curr_target and get_game_object(curr_target)
	
	if taken_obj then
		dl("[%s][item_pickup_intercept] Actor will take item %s", now, nameid(taken_obj))
		if cfg.markers[curr_target] then
			cfg.markers[curr_target]:HideAll("dotmarks taking item")
		end
		if flags.ret_value then
		-- The monkeypatch in z_fdda_pickup_intercept_dotmarks sets flags.ret_value to false
		-- if flags.ret_value is already false when it gets to DotMarks, DotMarks will assume
		-- that FDDA is handling the pickup part

		-- However, some items don't appear to respond to this handling, so we use them manually
		-- based on the cfg.manual_use table
			vl("flags.ret_value is %s, manually taking %s", flags.ret_value, nameid(taken_obj))
			db.actor:take_item(taken_obj)
		end
	end
	return taken_obj
end

function set_adjusted_marker_size(mark_id)
	local mark = hmm:GetMarker(mark_id)
	if not mark then return end
	mark.width = mark.base_w
	mark.height = mark.base_h
	--dump("[%s] set_adjusted_marker_size for %s: %s,%s", time_global(), mark.name, mark.width, mark.height)
	if mark.use_pri then
		mark.use_pri:UpdateMainWndPos(mark)
	end
	if mark.alt_interact then
		mark.alt_interact:UpdateMainWndPos(mark)
	end
end

function do_marker_popin(
		mark_id,
		w_start, h_start, w_end, h_end, duration,
		easing_func, on_finish_func, abort_func
	)
	if not mark_id then return end

	local anim_state = 0

	local anim_id = mark_id .. "_popin"

	if active_anims[mark_id] then
		popin_active = nil
	end
	popin_active = mark_id

	local mark      = hmm:GetMarker(mark_id)
	if not mark then return end

	local start_time= time_global()
	local end_time  = time_global() + duration

	easing_func = easing_func or function(x) return x end
	active_anims[mark_id] = {
		mark_id     = mark_id,
		anim_id     = anim_id,
		start_time  = start_time,
		end_time    = end_time,
		active      = true,
		w_start     = function(mark) return mark and mark.is_active and mark.args.width or w_start or 0 end,
		w_end       = function(mark) return mark and mark.is_active and mark.active_swap.width or mark.args.width or w_end or 0 end,
		h_start     = function(mark) return mark and mark.is_active and mark.args.height or h_start or 0 end,
		h_end       = function(mark) return mark and mark.is_active and mark.active_swap.height or mark.args.height or h_end or 0 end,
	}
	
	
	CreateTimeEvent("animate_popin_"..mark_id, time_global(), 0, 
		function()
			local abort = abort_func and abort_func()
			if abort then
				anim_state = 1
			elseif start_time - end_time > 5000 then
				-- Timeout to catch orphaned timeevents
				anim_state = 1
			else
				local anim = active_anims[mark_id]
				local mark = hmm:GetMarker(mark_id)
				if not (mark and mark.is_shown) then
					anim_state = 1
				elseif mark and anim and anim.active then
					if mark.is_active then
						local x = easing_func(anim_state)
						anim.w = lerp(anim.w_start(mark), anim.w_end(mark), x)
						anim.h = lerp(anim.h_start(mark), anim.h_end(mark), x)
					else
						anim_state = 1
					end
					mark.base_w = anim.w or anim.w_end(mark)
					mark.base_h = anim.h or anim.h_end(mark)
					set_adjusted_marker_size(mark_id)
				else
					anim_state = 1
				end
			end

			if (anim_state == 1) then
				if on_finish_func then on_finish_func() end
				active_anims[mark_id] = nil
				popin_active = nil
				return true
			end
			anim_state = math.min(1, normalize(time_global(), start_time, end_time))
		end
	)
end

function init_active_marker_popin(mark)
	if type(mark) == "string" then
		-- Assume a mark_id got passed instead of the mark itself
		mark = hmm:GetMarker(mark)
	end
	if not (mark and mark.mark_id) then return end

	do_marker_popin(
		mark.mark_id,
		mark.args.width * 0.5, mark.args.height * 0.5,
		mark.active_swap.width, mark.active_swap.height,
		cfg.popin_anim_dur,
		easing.easeOutElastic,
		(function()
			mark.next_update = 0
			mark.popin_done = true
			popin_active = nil
		end),
		(function() 
			return  (not popin_active) or
					(not mark.texture) or
					(popin_active ~= mark.mark_id) or
					(mark.texture ~= mark.active_swap.texture)
		end)
	)
end

function can_start_popin_anim(mark)
	return cfg.popin_anim_dur and (cfg.popin_anim_dur > 0) and not (popin_active or mark.popin_done)
end

function match_squad_or_leader(id, comp_id)
	if (id == comp_id) then return true end
	local se_obj    = comp_id and alife_object(comp_id)
	local cls       = se_obj and se_obj:clsid()
	local is_squad  = cls and (cls == clsid.online_offline_group_s) or (cls == clsid.online_offline_group)
	if is_squad then
		-- If the comparison ID is a squad object and didn't match directly, compare to its commander_id
		local leader_id = se_obj:commander_id()
		return (id == leader_id)
	end
end

function can_actor_see_artefact(obj)
	local arty  = obj and obj:cast_Artefact()
	local vstate= arty and arty.getVisible and arty:getVisible() or 0
	local _ = debug_dump and vl("can_actor_see_artefact for %s: %s", nameid(obj), (vstate == 1) and true or false)
	return (vstate == 1) and true or false
end

function get_bones_for_obj(obj)
	local bones = obj and obj.list_bones and obj:list_bones()
	return bones
end

local ini_parts = itms_manager.ini_parts
function has_parts(obj)
	if not obj then return end
	local sec = SYS_GetParam(0, obj:section(), "parent_section") or obj:section()
	local parts = ini_parts:r_string_ex("con_parts_list", sec)
	return parts ~= nil
end

function is_door_open(obj, id)
	id = id or (obj and obj:id())
	obj = obj or (id and get_game_object(id))
	if not id then return end
	local door = id and db.storage[id]["ph_door"] and db.storage[id]["ph_door"].door_action
	local is_open = door:is_open()
end

function is_vanilla_ui_hidden()
	return (cfg.hide_van_interact_ui and not cfg.hide_pri_interact_ui)
end

function trimmed_prompt(txt)
	local pos = txt and txt:find("%(")
	return pos and txt:sub(1, pos - 2) or txt or ""
end

function interact_vert_offset(ui_interact)
	local args = ui_interact and ui_interact.args
	return args and (not args.pri) and (not cfg.hide_pri_interact_ui) and cfg.sec_use_y_offset or cfg.pri_use_y_offset
end

function lerp_color(val, mi, md, mx)
	-- like in utils_xml, except returning a table I can do something with instead of ARGB
	local m1,m2
	if (val >= mi[5]) and (val < md[5]) then
		m1 = mi
		m2 = md
	elseif (val >= md[5]) and (val <= mx[5]) then
		m1 = md
		m2 = mx
	end
	if not (m1 and m2) then
		return clr_tbl(255,255,255,255)
	end
	
	local t = {}
	for i=1,4 do
		if m1[i] == m2[i] then
			t[i] = m1[i]
		else
			t[i] = math.floor( m1[i] + ((m2[i] - m1[i]) * normalize(val, m1[5], m2[5])) )
		end
	end
	return clr_tbl(t[1], t[2], t[3], t[4])
end

function is_already_target(id)
	local is_pickup = hmm and hmm.current_pickup and (id == hmm.current_pickup)
	if is_pickup then return true end
	local is_target = hmm and hmm.current_target and (id == hmm.current_target)
	if is_target then return true end
	local is_xhair  = hmm and hmm.current_pickup and (id == hmm.current_crosshair)
	if is_xhair then return true end
end

function get_condition_color(condition, section)
	if not condition then return end
	local args      = {}
	local c         = cfg.colors
	local mode      = 0
	local crit_pwr  = section and item_device.dev_critical[section]
	if crit_pwr then
		mode        = 2
		args.crit   = crit_pwr
	elseif cfg.parts_wpo_colors then
		mode        = 1
	else
		condition   = clamp(condition / 99, 0, 1)
	end
	return get_state_color(condition, mode, args)
end

function timed_out(stamp, interval)
	if not (stamp and interval) then return end
	return (time_global() - stamp) >= interval
end

--[[======================================================================
	UIStaticQuickHelp management
	Most of the logic is in dotmarks_main.cfg.hint_filter

	on_quickhelp_text_update(raw_text, loc_string, trimmed_text, flags)
		Params: (<string>, <string>, <string>, <table>)

		raw_text:
			the raw text content of the UIStaticQuickHelp textwnd
		loc_string:
			the localization string of the text
		trimmed_text:
			the text with the "use key" prompt trimmed off
		
	flags is an empty table, set flags.text to any string to replace text
	
	cfg.hide_van_interact_ui will override showing any such text changes
-- =====================================================================]]

AddScriptCallback("on_quickhelp_text_update")

function get_quickhelp_text()
	local text = maingameui and maingameui.UIStaticQuickHelp and maingameui.UIStaticQuickHelp:GetText()
	return text and (text ~= "") and (text ~= " ") and text or nil
end

function set_quickhelp_text(text)
	if not maingameui and maingameui.UIStaticQuickHelp then return end
	maingameui.UIStaticQuickHelp:SetText(text or "")
end

--[[======================================================================
	Custom interaction prompt
	Review at some point post-release for unused args/code
-- =====================================================================]]

class "InteractPrompt" (CUIScriptWnd)

function InteractPrompt:__init(anchor, args) super()
	vl("InteractPrompt:__init | event %s | name %s | tutorial %s", args and args.event, args and args.name, args and args.tutorial)
	self:SetAutoDelete(true)
	self.elements = {
		["wnd"]         = true,
		["prompt"]      = false,
		["prompt_l"]    = false,
		["prompt_c"]    = false,
		["prompt_r"]    = false,
		["bind"]        = true,
		["bind_sh"]     = true,
		["label"]       = true,
		["label_sh"]    = true,
		["line"]        = false,
		["longpress"]   = false,
	}   -- bool is whether to scale alpha
	self.xml    = CScriptXmlInit()
	self.uid    = "dotmarks_" .. args.event
	args        = args or {}
	args.func   = args.func or (function() end)
	args.event  = self:Event(args.event)
	args.key    = self:BindKey(args.key)
	args.mod    = self:ModKey(args.mod)
	args.mode   = self:InputMode(args.mode)
	args.bind   = args.bind or bindtext(key, mod)
	args.long   = args.long or (args.mode == 2)
	args.xoffset= args.xoffset or (args.pri and cfg.pri_use_x_offset or cfg.sec_use_x_offset) or 0
	args.yoffset= args.yoffset or (args.pri and cfg.pri_use_y_offset or cfg.sec_use_y_offset) or 0
	if (not args.no_sec_yscale) and (not args.pri) then
		local pxoff = cfg.pri_use_x_offset
		local pyoff = cfg.pri_use_y_offset
		local sxoff = cfg.sec_use_x_offset
		local syoff = cfg.sec_use_y_offset
		local ydiff = syoff - pyoff
		args.yoffset = args.yoffset - ydiff + fontscale(ydiff)
	end

	args.act    = args.act or ""
	args.name   = args.name or ""
	args.fixed  = ((args.fixed ~= nil) and args.fixed) or cfg.fixed_screen_pos
	self.anchor = args.fixed and maingameui or anchor or maingameui
	if args.fixed then
		local x,y   = get_fixed_screen_pos()
		args.locked_screen_pos = vector2():set(x, y)
	end
	if args.scheme then
		if args.is_button then
			local method = ((args.scheme == "ph_button") and "on_press" or "on_code")
			self.physbtn_active = (
				function()
					local btn = self.args.id and db.storage[self.args.id][args.scheme]
					return btn and not not btn[method]
				end
			)
		elseif args.scheme == "ph_door" then
			self:SetupDoorHandlers(args)
		end
	end

	if debug_dump then
		dump("[InteractPrompt] Passed args:")
		for k,v in pairs(args) do dump("|| %s = %s", k, v) end
	end
	if args.hint_filters then
		vl("Setting up %s hint filters", size_table(args.hint_filters))
		self.filters = {}
		self.prompts = {}
		for k,v in pairs(args.hint_filters) do
			hintfilters.add(k, v)
			self.filters[k] = function() return hintfilters.get_state(k) end
			self.prompts[k] = function() return self.filters[k]() and hintfilters.get_text(k) or nil end
		end
		RegisterScriptCallback("on_quickhelp_text_update", self)
	end

	local color             = cfg.colors
	local csv2clr           = csv_argb_to_tbl
	self.text_color_default = clr_tbl(255, 255, 255, 255)
	self.text_hidden        = clr_tbl(0, 0, 0, 0)
	self.text_color_busy    = csv2clr(args.argb_busy)   or color.clr_text_busy  or self.text_color_default
	self.text_color_light   = csv2clr(args.argb_light)  or color.clr_text_light or self.text_color_default
	self.text_color_dark    = csv2clr(args.argb_dark)   or color.clr_text_dark  or self.text_color_default
	self.progress_color     = csv2clr(args.argb_prog)   or color.clr_key_hold or csv_argb_to_tbl({255,255,215,0})

	self.active_prefix      = args.active_prefix or args.act    or ""
	self.active_prompt      = args.active_prompt or args.text   or (args.tutorial and trimmed_prompt(gts(args.tutorial))) or ""
	self.active_suffix      = args.active_suffix or args.suffix or ""
	self.args               = args
	if self.args.tutorial then
		if (self.args.tutorial:find("campfire")) then
			self.campfire_tut   = true
		elseif (self.args.tutorial == "tutorial_sleep") then
			self.sleep_tut = true
		end
	end
	self.last_state         = false
	self:on_option_change()
	self:BusyState(false)
	self:ShowPrompt(args.begin_active, "init")

	RegisterScriptCallback("actor_on_net_destroy", self)
	RegisterScriptCallback("on_option_change", self)
	RegisterScriptCallback("actor_on_update", self)
	
	vl("[%s][InteractPrompt] Completed setup for prompt: %s", self.init_done, self:GetFullPrompt())
end

function InteractPrompt:GetMark()
	if self.args.mark_id then
		return hmm:GetMarker(self.args.mark_id)
	elseif self.args.id and cfg.markers[self.args.id] then
		return cfg.markers[self.args.id]
	end
end

function InteractPrompt:GetInvWeightDisplay(weight)
	local wc = weight and get_actor_weight_class(weight)
	local code  = wc and cfg.weight_colors[wc] or cfg.weight_colors[0]
	self.parse_text_colors = true
	return string.format(" ($%s%.2f %s$clr_def)", code, self.weight, st_kg)
end

function InteractPrompt:SetupDoorHandlers(args)
	vl("Setting up door handler object and methods")
	local ph_door = args.id and db.storage[args.id]["ph_door"]

	self.door = {
		data = ph_door,
		ctrl = ph_door.door_action
	}
	local door = self.door
	if not door.ctrl then return end

	door.lo, door.hi = door.ctrl.joint:get_limits(0, 0, 0)
	door.mid = (door.lo + door.hi) * 0.5
	door.deadzone = 0.1
	door.is_open = (
		function()
			return self.door.ctrl and self.door.ctrl.is_open and self.door.ctrl:is_open()
		end
	)
	door.tips = {
		close   = self.door.data and self.door.data.tip_close,
		open    = self.door.data and self.door.data.tip_open,
		unlock  = self.door.data and self.door.data.tip_unlock,
	}
	door.joint_pos = (
		function()
			return self.door.ctrl and
				self.door.ctrl.joint and
				self.door.ctrl.joint.get_axis_angle and
				self.door.ctrl.joint:get_axis_angle(0)
		end
	)
	door.tip = (
		function()
			local locked = self.door.data and self.door.data.locked
			local tips = self.door.tips
			local msg = locked and tips.unlock or self.door.is_open() and tips.close or tips.open
			return msg
		end
	)
	args.text = gts(self.door.tip())
end


function InteractPrompt:GetWndOffset()
	if self.args.locked_screen_pos then
		return self.args.locked_screen_pos.x, self.args.locked_screen_pos.y
	else
		return self.args.xoffset, self.args.yoffset
	end
end

function InteractPrompt:GetPosOffsets()
	local xoff, yoff = 0, 0
	if not self.args.locked_screen_pos then
		xoff, yoff = self:GetWndOffset()
	end
	return xoff, yoff
end

function InteractPrompt:SetLinePos(x, y)
	local xoff, yoff 	= self:GetPosOffsets()

	self.line:SetWndPos(vector2():set(
		(x or 0) + 15 	+ (self.args.line_adj_x or 0),
		(y or 0) + -15	+ (self.args.line_adj_y or 0)
	))
end


function InteractPrompt:UpdateMainWndPos(mark)
	if self.args.locked_screen_pos then return end
	mark 			= mark or self:GetMark() or {}
	local arg_tbl 	= mark.is_active and mark.task_swap or mark.active_swap or mark.args or {}
	local adj_w 	= ((mark and mark.width or 6) - (arg_tbl.width or 6)) * 0.5
	local adj_h 	= ((mark and mark.height or 6) - (arg_tbl.height or 6)) * 0.5
	local x         = self.args.xoffset + adj_w
	local y         = self.args.yoffset + adj_h
	self.wnd:SetWndPos(vector2():set(x, y))
end


function InteractPrompt:SetupConnectingLine()
	-- White line - really cheap trick but looks nice in certain positions
	if not self.line then
		self.line = self.xml:InitProgressBar("prog_dotpointer", self.wnd)
	end

	if self.args.pri then
		self:SetLinePos(
			(self.args.line_adj_x or 0) + -3.5,
			(self.args.line_adj_y or 0) + 3
		)
		self.line:SetWndSize(vector2():set(5 + (self.args.line_adj_w or 0), 26 + (self.args.line_adj_h or 0)))
	else
		self.line:Show(false)
	end
end


function InteractPrompt:BuildUI()
	vl("InteractPrompt:BuildUI | %s", self.args.name or self.args.text or self.args.tutorial or self.args.event)
	if self.wnd then
		for k,_ in pairs(self.elements) do
			self[k] = nil
		end
	end

	local xml           = self.xml
	xml:ParseFile(cfg.interact_uifile)
	local args          = self.args
	local boxlen        = fontscale(#args.bind * cfg.bind_char_scale)
	local boxpos        = -(boxlen - 4)
	self.args.style     = cfg.keybind_bg_style or 0
	self.black_text     = (self.args.style > 1)
	local stretch_adj   = 0
	self.wnd            = xml:InitStatic("alt_interact", self.anchor)

	self.drop           = xml:InitStatic("box", self.wnd)
	self.drop:SetWndPos(vector2():set(-boxlen, -1))
	self.drop:InitTexture(cfg.main_drop_texture)
	self.drop:SetTextureColor(get_argb(clamp(cfg.interact_drop_alpha * 255, 0, 255), 255, 255, 255))
	self:SetupConnectingLine()

	local one_char = (#args.bind == 1)

	if one_char then
		self.prompt     = xml:InitStatic("alt_interact:prompt", self.wnd)
		self.prompt:InitTexture("ui_catsy_keybind_bg_single_v" .. self.args.style)
		self.prompt:SetWndSize(vector2():set(fontscale(15), fontscale(20)))
	else
		self.prompt     = xml:InitStatic("box", self.wnd)
		
		self.prompt_l   = xml:InitStatic("alt_interact:prompt_l", self.prompt)
		self.prompt_c   = xml:InitStatic("alt_interact:prompt_c", self.prompt)
		self.prompt_r   = xml:InitStatic("alt_interact:prompt_r", self.prompt)
		self.prompt_l:InitTexture("ui_catsy_keybind_bg_left_v" .. args.style)
		self.prompt_c:InitTexture("ui_catsy_keybind_bg_center_v" .. args.style)
		self.prompt_r:InitTexture("ui_catsy_keybind_bg_right_v" .. args.style)

		stretch_adj     = 2
		self.prompt_l:SetWndSize(vector2():set(fontscale(5.3125), fontscale(20)))
		self.prompt_l:SetWndPos(vector2():set(0, 0))
		self.prompt_c:SetWndSize(vector2():set(boxlen, fontscale(20)))
		self.prompt_c:SetWndPos(vector2():set(fontscale(5.1125), 0))
		self.prompt_r:SetWndPos(vector2():set(fontscale(4.78) + boxlen, 0))
		self.prompt_r:SetWndSize(vector2():set(fontscale(5.3125), fontscale(20)))
	end
	self.prompt:SetWndPos(vector2():set(boxpos or 0, 0))

	-- Set up long press progress indicator
	if args.long then
		self.longpress  = xml:InitProgressBar("prog_longpress", self.prompt)
		self.longpress:SetColor(getargb(self.progress_color))
		self.longpress:SetProgressPos(0)
	end

	-- Set up text drop shadows
	self.bind_sh        = xml:InitStatic("alt_interact:label", self.prompt)
	self.label_sh       = xml:InitStatic("alt_interact:label", self.wnd)
	self.bind_sh:SetWndSize(vector2():set((boxlen or 0) + fontscale(15), fontscale(20)))
	self.bind_sh:SetWndPos(vector2():set(fontscale(stretch_adj + cfg.bind_text_pos_x + 1.5), fontscale(cfg.bind_text_pos_y - 0.25)))
	self.label_sh:SetWndPos(vector2():set(fontscale(cfg.action_text_pos_x + 0.5), fontscale(cfg.action_text_pos_y)))
	self.bind_sh:TextControl():SetFont(get_font())
	self.label_sh:TextControl():SetFont(get_font())

	-- Keybind text indicator
	self.bind           = xml:InitStatic("alt_interact:label", self.prompt)
	self:eleSetBaseColorScheme(self.bind, self.black_text and self.text_color_dark or self.text_color_light)
	self.bind:TextControl():SetFont(get_font())

	self:SetBindText(bindtext(self:BindKey(), self:ModKey()))

	self.bind:SetWndSize(vector2():set((boxlen or 0) + fontscale(15), fontscale(20)))
	if one_char then
		self.bind:SetWndPos(vector2():set(fontscale(stretch_adj + cfg.bind_text_pos_x + 1.5), fontscale(cfg.bind_text_pos_y)))
	else
		self.bind:SetWndPos(vector2():set(fontscale(stretch_adj + cfg.bind_text_pos_x), fontscale(cfg.bind_text_pos_y)))
	end

	-- Width reference static
	self.lref      = xml:InitStatic("box", self.wnd)
	self.lref:Show(false)

	-- Prompt text label
	self.label          = xml:InitStatic("alt_interact:label", self.wnd)
	self:eleSetBaseColorScheme(self.label, self.text_color_light)
	self.label:SetWndPos(vector2():set(fontscale(cfg.action_text_pos_x), fontscale(cfg.action_text_pos_y)))
	self.label:TextControl():SetFont(get_font())

	self:eleSetBaseColorScheme(self.bind_sh, self.text_color_dark)
	if self.black_text then
		self.bind_sh:Show(false)
	end
	self:eleSetBaseColorScheme(self.label_sh, self.text_color_dark)

	local obj = self.args.id and get_game_object(self.args.id)
	self:SetupSuffix(obj)
	self:SetPrompt()

	if obj and self.args.pri then
		self:SetupItemCard(self.wnd, obj)
		self:SetupUtjanPartDots(self.itemcard)
	end

	if self.args.locked_screen_pos then
		self.wnd:SetWndPos(self.args.locked_screen_pos)
	else
		self:UpdateMainWndPos()
	end

	vl("Completed %sbuilding interact UI: %s", self.init_done and "re" or "", self.active_prompt)
	self.init_done = self.init_done or time_global()
	self:actor_on_update()
end

function InteractPrompt:SetupSuffix(obj)
	obj             = obj or (self.args.id and get_game_object(self.args.id))
	if (not obj) then return end
	if not (cfg.show_item_condition or cfg.show_item_charge) then return end

	local sec       = self.args.section or obj:section()
	local cls       = self.args.clsid or obj:clsid()
	local has_cond  = (sec and cls) and (utils_item.is_degradable(nil, sec) or IsWeapon(nil, cls) or IsOutfit(nil, cls) or IsHeadgear(nil, cls))
	local is_mag    = magazine_binder and sec and magazine_binder.is_magazine(sec)
	local gear_cnd  = (self.args.has_parts and cfg.show_item_condition)
	local batt_cnd  = ((self.args.has_power or self.args.has_battery) and cfg.show_item_charge)

	if self.args.multi_uses then
		-- Setup suffix text for multiuse items
		if cfg.show_multi_uses and (self.args.multi_uses > 1) then
			self.active_suffix = string.format(" (%s %s)", self.args.multi_uses, gts("st_alti_uses"))
		else
			self.active_suffix = ""
		end
	elseif has_cond and (gear_cnd or batt_cnd) and (not is_mag) then
		-- Setup suffix text for degradable items
		local cond = obj and obj:condition()
		self:SetConditionText(sec, cond)
	else
		self.active_suffix = ""
	end
end


function InteractPrompt:SetConditionText(sec, cond)
	 if (cond and sec) then
		cond = math.floor(cond * 100)
		local c = get_condition_color(cond, sec)
		local key = "clr_" .. cond .. (self.args.has_power and "_batt" or "_cond")
		local str   = c and string.format("%" .. "%c[%s,%s,%s,%s]", c.a, c.r, c.g, c.b)
		if str then set_color_token(key, str) end
		self.parse_text_colors = true
		if (cond < 0.01) and self.args.has_power then
			self.active_suffix = string.format(" ($%s%s$clr_def)", key, gts("st_alti_nopower"))
		else
			self.active_suffix = string.format(" ($%s%s%%$clr_def)", key, cond)
		end
	else
		self.active_suffix = ""
	end
end


function InteractPrompt:UpdatePromptLength()
	local len           = self.prompt_length
	self.prompt_length  = self.lref:GetWidth() + 25
	if len == self.prompt_length then return self.prompt_length end
	if self.itemcard then
		self.itemcard:SetWndPos(vector2():set(cfg.item_card_pos_x + self.prompt_length, cfg.item_card_pos_y or 0))
	end
	return self.prompt_length
end

function InteractPrompt:UpdateWeightColor()
	if not (self.card_wgt_icon and self.card_wgt_text) then return end
	local c = get_state_color(self.weight, 3)
	local color = c and getargb(c)
	if not color then return end
	self.card_wgt_icon:SetTextureColor(color)
	self.card_wgt_text:TextControl():SetTextColor(color)
end

function InteractPrompt:SetupItemCard(anchor, obj)
	if (not cfg.show_item_card) or (not self.args.is_pickup) then return end
	if self.itemcard then self.itemcard:Show(false) end
	obj = obj or (self.args.id and get_game_object(self.args.id))
	sec = self.args.glowstick_sec or (obj and obj:section())
	if not sec then return end

	self.weight     = dec2(ini_sys:r_float_ex(sec,"inv_weight") or 0)
	local value     = dec2(ini_sys:r_float_ex(sec,"cost") or 0)

	xml:ParseFile(cfg.interact_uifile)
	local offset    = fontscale(self:UpdatePromptLength())
	self.itemcard   = self.xml:InitStatic("box", anchor or self.wnd)

	local icon_sz   = cfg.item_card_icon_sz
	local wnd_x     = cfg.item_card_pos_x
	local wnd_y     = cfg.item_card_pos_y
	local text_y    = cfg.item_card_text_y
	local elem_x    = cfg.item_card_elem_x
	local elem_y    = cfg.item_card_elem_y
	local elem_h    = fontscale(cfg.item_card_elem_h)
	local icon_x    = cfg.item_card_icon_x
	local icon_y    = cfg.item_card_icon_y

	self.itemcard:SetWndPos(vector2():set(wnd_x + offset, wnd_y))

	self.card_wgt = self.xml:InitStatic("box", self.itemcard)
	self.card_wgt:SetWndPos(vector2():set(elem_x, elem_y))
	self.card_wgt_icon = self.xml:InitStatic("box", self.card_wgt)
	self.card_wgt_icon:SetWndSize(vector2():set(icon_sz * cfg.unsquish_ratio, icon_sz))
	self.card_wgt_icon:SetWndPos(vector2():set(icon_x, icon_y))
	self.card_wgt_icon:InitTexture(cfg.item_card_icon_weight)
	self.card_wgt_icon:Show(true)

	offset = elem_x + self.card_wgt_icon:GetWidth()
	self.card_wgt_text = self.xml:InitStatic("box", self.card_wgt)
	self.card_wgt_text:SetWndSize(vector2():set(0, elem_h))
	self.card_wgt_text:SetWndPos(vector2():set(offset, text_y))
	self.card_wgt_text:TextControl():SetFont(get_font(cfg.font_item_card or 0))
	self.card_wgt_text:TextControl():SetText(self.weight)
	self.card_wgt_text:AdjustWidthToText()
	self.card_wgt_text:Show(true)
	self:UpdateWeightColor()

	local weight_w = offset + self.card_wgt_text:GetWidth()
	self.card_wgt:SetWndSize(vector2():set(weight_w + 6, elem_h))
	self.card_wgt:InitTexture("ui_dotmarks_card_drop")
	self.card_wgt:SetTextureColor(getargb( cfg.colors.clr_card_drop ))

	offset = elem_x
	self.card_val = self.xml:InitStatic("box", self.itemcard)
	self.card_val:SetWndPos(vector2():set(offset, elem_y + elem_h))
	self.card_val_icon = self.xml:InitStatic("box", self.card_val)
	self.card_val_icon:SetWndSize(vector2():set(icon_sz * cfg.unsquish_ratio, icon_sz))
	self.card_val_icon:SetWndPos(vector2():set(icon_x, icon_y))
	self.card_val_icon:InitTexture(cfg.item_card_icon_value)
	self.card_val_icon:SetTextureColor(getargb( cfg.colors.clr_text_light ))
	self.card_val_icon:Show(true)

	offset = elem_x + self.card_val_icon:GetWidth()
	self.card_val_text = self.xml:InitStatic("box", self.card_val)
	self.card_val_text:SetWndSize(vector2():set(0, elem_h))
	self.card_val_text:SetWndPos(vector2():set(offset, text_y - 0.5))
	self.card_val_text:TextControl():SetFont(get_font(cfg.font_item_card or 0))
	self.card_val_text:TextControl():SetText(value)
	self.card_val_text:TextControl():SetTextColor(getargb( cfg.colors.clr_text_light )) 
	self.card_val_text:AdjustWidthToText()
	self.card_val_text:Show(true)

	local value_w = offset + self.card_val_text:GetWidth()
	self.card_val:SetWndSize(vector2():set(value_w + 6, elem_h))
	self.card_val:InitTexture("ui_dotmarks_card_drop")
	self.card_val:SetTextureColor(getargb( cfg.colors.clr_card_drop ))
	
	self.card_sp_icon = self.xml:InitStatic("box", self.itemcard)
	self.longest_card = math.max(weight_w, value_w)

	self:UpdateFaveJunkIcon()

	self.itemcard:Show(true)
end

function InteractPrompt:UpdateFaveJunkIcon()
	if not (zzz_rax_sortingplus_mcm and cfg.sp_flag_favejunk) then return end
	if not self.card_sp_icon then return end

	local texture = (is_favorite(self.args.section) and cfg.icon_sp_fave_texture) or
					(is_junk(self.args.section) and cfg.icon_sp_junk_texture) or
					""
	self.card_sp_icon:InitTexture(texture)
	local has_icon = (texture ~= "")
	self.card_sp_icon:Show(has_icon)
	if not has_icon then return end

	self.card_sp_icon:SetWndPos(vector2():set(self.longest_card + fontscale(cfg.sp_icon_pos_x or 0), (cfg.sp_icon_pos_y or 0)))
	self.card_sp_icon:SetWndSize(vector2():set(16 * cfg.unsquish_ratio, 16))    
end

function InteractPrompt:SetupUtjanPartDots(anchor, obj)
	-- Adapted from z_item_icon_info in Utjan's Item UI
	-- TODO: try again to add drop shadows/background to the dots
	-- Consider trying to arrange them in a pentagon/square so they can fit better
	if not cfg.show_part_condition then return end
	if not item_icon_info_mcm then return end
	if self.parts_indicators then
		for k,v in pairs(self.parts_indicators) do
			self.parts_indicators[k]:Show(false)
		end
	end

	obj = obj or (self.args.id and get_game_object(self.args.id))
	sec = obj and obj:section()
	cls = obj and obj:clsid()

	if not (obj and has_parts(obj)) then return end
	if (not cfg.show_parts_weapons) and IsWeapon(nil, cls) then return end
	if (not cfg.show_parts_armor) and (IsHeadgear(nil, cls) or IsOutfit(nil, cls)) then return end

	local se_parts = item_parts.get_parts_con(obj, nil, true)
	if is_empty(se_parts) then return end
	local parts = dup_table(se_parts)

	local sep = (cfg.parts_dot_sep_width or 2)
	local base_x = (cfg.parts_dot_pos_x or 0)
	self.parts_container = self.xml:InitStatic("box", anchor or self.wnd)
	self.parts_container:SetWndPos(vector2():set(base_x, cfg.parts_dot_pos_y or 0))
	self.parts_indicators = self.parts_indicators or {}

	self.xml:ParseFile("ui_utjan_icon_info.xml")
	for part, v in pairs(parts) do
		if SYS_GetParam(1, part, "cond_part") then
			self.parts_indicators[part] = self.parts_indicators[part] or self.xml:InitStatic("cond_dot", self.parts_container)
		else
			parts[part] = nil
		end
	end

	local i = 0
	local size = 0
	for part, condition in spairs(parts, parts_sort) do
		local cond_dot_h = 4
		local cond_dot_w = cond_dot_h * cfg.unsquish_ratio
		cond_dot_h = cond_dot_h * 1
		cond_dot_w = cond_dot_w * 1

		self.parts_indicators[part]:SetWndRect(Frect():set(0, 0, cond_dot_w, cond_dot_h))
		
		local x = base_x + 1 + (cond_dot_w + sep) * i
		local y = 0
		self.parts_indicators[part]:SetWndPos(vector2():set(x, y))

		local c = get_condition_color(condition)
		local color = get_argb(c.a, c.r, c.g, c.b)

		if color then
			self.parts_indicators[part]:SetTextureColor( color )
		end
		self.parts_indicators[part]:Show(true)
		size = x + cond_dot_w + sep
		i = i + 1
	end
	self.parts_container:SetWndSize(vector2():set(size, 0))
	self.parts_container:InitTexture(cfg.main_drop_texture)
end



function InteractPrompt:eleSetCurrentColor(element, a, r, g, b)
	if not element then return end
	local argb = get_argb(a, r, g, b)
	if element.SetTextureColor  then element:SetTextureColor(argb) end
	if element.TextControl      then element:TextControl():SetTextColor(argb) end
	element.currcolor = {
		a = tonumber(a) or 255,
		r = tonumber(r) or 255,
		g = tonumber(g) or 255,
		b = tonumber(b) or 255
	}
end

function InteractPrompt:eleSetCurrentColorScheme(element, c)
	c = c or element.basecolor or self.text_color_default
	self:eleSetCurrentColor(element, c.a, c.r, c.g, c.b)
end

function InteractPrompt:eleSetBaseColorScheme(element, c)
	element.basecolor = c or self.text_color_default
	self:eleSetCurrentColorScheme(element, c)
end

function InteractPrompt:GetARGB(clr_tbl)
	return clr_tbl and get_argb({
		a = clr_tbl.a,
		r = clr_tbl.r,
		g = clr_tbl.g,
		b = clr_tbl.b
	})

end

function InteractPrompt:Event(set)
	if set and self.args then self.args.event = set end
	return set or (self.args and self.args.event) or "sec_interact"
end

function InteractPrompt:BindKey(set)
	if set and self.args then self.args.key = set end
	return set or (self.args and self.args.key) or cfg["bind_" .. self:Event()] or 0
end

function InteractPrompt:ModKey(set)
	if set and self.args then self.args.mod = set end
	return set or (self.args and self.args.mod) or cfg["modk_" .. self:Event()] or 0 
end

function InteractPrompt:InputMode(set)
	if set and self.args then self.args.imod = set end
	return set or (self.args and self.args.imod) or 0 
end

function InteractPrompt:SetBindText(text)
	text = text or (self.args and self.args.bind) or ""
	self.bind:TextControl():SetText(text)
	self.bind_sh:TextControl():SetText(text)
end


function InteractPrompt:on_key_hold(key)
	if (self.disabled or self.destroyed or self.busystate) then return end
	
	if (key == self.args.key) and (self.args.mode == 2) and ui_mcm.get_mod_key(self.args.mod) then
		local now = time_global()
		if ui_mcm.key_hold(self.uid, key, 5) then
			local tid = get_current_target()
			local obj = tid and get_game_object(tid) or nil
			cfg.last_hold   = {
				key         = cfg.held_key,
				time        = now,
				by          = self
			}
			self.peak_hold  = nil
			cfg.held_key    = nil
			cfg.held_mod    = nil
			cfg.held_time   = nil
			cfg.holding     = nil
			cfg.use_released= cfg.use_released or now
			--dump("[%s][InteractPrompt:on_key_hold] Setting cfg.use_released to %s", now, cfg.use_released)
			self.longpress:SetProgressPos(0)
			self.args.func(obj, self.args.mark)
			return
		elseif cfg.last_hold and (cfg.last_hold.key == self.args.key) and not timed_out(cfg.last_hold.time, cfg.long_press_delay or 50) then
			--dump("[%s][InteractPrompt:on_key_hold] Tried to start another hold too soon, aborting", now)
			self.longpress:SetProgressPos(0)
			return
		end

		if not cfg.held_key then
			self.longpress:SetProgressPos(0)
			--dump("[%s][InteractPrompt:on_key_hold] Beginning hold of key %s", now, self.args.key)
		end
		cfg.held_key    = key
		cfg.holding     = self
		cfg.held_mod    = self.args.mod
		cfg.held_time   = ui_mcm and ui_mcm.hold[key] and ui_mcm.hold[key][self.uid]
	end
end


function InteractPrompt:on_key_press(key, flags)
	if (self.disabled or self.destroyed or self.busystate) then return end

	if (key == self.args.key) then
		if not ui_mcm then
			self.args.func()
			return
		end

		if (self.args.mode == 0) then
			ui_mcm.simple_press(self.uid, key, self.args.func)
		end
	
		if (self.args.mode == 1) and ui_mcm.get_mod_key(self.args.mod) and ui_mcm.double_tap(self.uid, key) then
			self.args.func()
			return
		end
	end    
end

function InteractPrompt:actor_on_net_destroy() 
	self.disabled = true
	self.destroyed = true
	get_hud():RemoveDialogToRender(self)
end

function InteractPrompt:on_option_change()
	if self.args.tutorial and self.init_done then
		self:Destroy()
		return
	end
	if self.args.pri then
		self.args.key   = self.args.key or bind_to_dik(key_bindings.kUSE)
	else
		local sec       = cfg.bind_sec_interact
		local tap_time  = self.args.tap_time or (ui_mcm and ui_mcm.get("mcm/mcm_kb/mcm_kb_main/dtaptime2")) or 200
		self.hold_time  = (self.args.hold_time or (ui_mcm and ui_mcm.get("mcm/mcm_kb/mcm_kb_main/presstime")) or 2) * tap_time
		self.args.key   = cfg["bind_" .. (self.args.event or "")] or sec or 0
		self.args.mod   = cfg["modk_" .. (self.args.event or "")] or sec or 0 
		self.args.mode  = cfg["imod_" .. (self.args.event or "")] or sec or 0
	end

	self:BuildUI()

	self.bind_sh:Show((not self.black_text) and (not cfg.hide_drop_shadow))
	self.label_sh:Show(not cfg.hide_drop_shadow)
end

function InteractPrompt:BusyState(tf, prefix, force_update)
	local last_state = self.busystate
	self.busystate = not not tf
	if force_update or ((tf ~= nil) and (self.busystate ~= last_state)) then
		--dump("InteractPrompt:BusyState has changed to %s, updating prompt visuals", self.busystate)
		if self.busystate then
			self.active_prefix  = (prefix or gts("st_alti_busy")) .. " "
			self.active_prompt  = first_lower(self.active_prompt)
			if self.text_color_busy then
				self:eleSetCurrentColorScheme(self.label, self.text_color_busy)
				self:eleSetCurrentColorScheme(self.bind, self.text_color_busy)
			end
		else
			self.active_prefix = self.args.act
			self:eleSetCurrentColorScheme(self.label, self.text_color_light)
			self:eleSetCurrentColorScheme(self.bind, self.black_text and self.text_color_dark or self.text_color_light)
			self.active_prompt  = first_upper(self.active_prompt)
		end
		if self.itemcard and cfg.show_item_card then
			self.itemcard:Show(not tf)
		end
		if self.parts_container and cfg.show_item_card then
			self.parts_container:Show(not tf)
		end
		self:RegisterScriptCallbacks(not self.busystate)
		self:SetPrompt()
	end
	return self.busystate
end

function InteractPrompt:AbortFadeIn() return self.fading_out or not self.fading_in end
function InteractPrompt:AbortFadeOut() return self.fading_in or not self.fading_out end

function InteractPrompt:SetAlpha(element_name, alpha, text_also)
	coef = coef or 1
	alpha = clamp(alpha, 0, 255)
	if self[element_name] then
		local ele = self[element_name]
		local c = {}
		if ele.GetTextureColor then
			local i = ele:GetTextureColor()
			c.r,c.g,c.b,c.a = i and int_to_rgba(i)
			c.a = alpha or c.a
			ele:SetTextureColor(get_argb(c.a,c.r,c.g,c.b))
		end
		if text_also then
			c = ele.currcolor or ele.basecolor or {}
			c.a = alpha or c.a
			c.r = c.r or 255
			c.g = c.g or 255
			c.b = c.b or 255
			ele.currcolor = c
			ele:TextControl():SetTextColor(get_argb(c.a,c.r,c.g,c.b))
		end
	end
end

function InteractPrompt:ManageFadeAnim(
		alpha_start, alpha_end, 
		duration, event_id, instanced, 
		r, g, b, 
		anim_curve_modifier_func, on_finish_func, abort_func
	)
	local fade_dir = (alpha_start > alpha_end) and "out" or "in"
	if (event_id == nil) then event_id = "anim_fade" end
	local anim_id = event_id.."_"..tostring(time_global())
	r = r or 255
	g = g or 255
	b = b or 255

	if active_anims[event_id] then
		alpha_start = active_anims[event_id].a
		-- Repeat invocation of non-instanced fade event, abort fade and start over
		active_anims[event_id] = nil
		if on_finish_func then on_finish_func(self) end
	end

	local anim_state = 0
	local start_time= time_global()
	local end_time  = time_global() + duration
	local anim_curve_modifier_func = anim_curve_modifier_func or function(x) return x end
	active_anims[event_id] = {
		instanced   = instanced and true or false,
		anim_id     = anim_id,
		start_time  = start_time,
		end_time    = end_time,
		active      = true,
		a_start     = alpha_start,
		a_end       = alpha_end,
		a           = alpha_start,
		r           = r,
		g           = g,
		b           = b,
	}
	
	CreateTimeEvent("animate_fade"..event_id..anim_id, time_global(), 0, 
		function()
			local abort = abort_func and abort_func(self)
			if abort then
				anim_state = 1
			else
				local anim = active_anims[event_id]
				if anim then
					local x = anim_curve_modifier_func(anim_state)
					local alpha = lerp(alpha_start, alpha_end, x)
					self.curr_alpha = alpha
					for k,v in pairs(self.elements) do
						self:SetAlpha(k, alpha, v)
					end
				else
					anim_state = 1
				end
			end

			if (anim_state == 1) then
				if on_finish_func then on_finish_func(self) end
				return true
			end
			anim_state = math.min(1, normalize(time_global(), start_time, end_time))
		end
	)
end

function InteractPrompt:AnimateFade(inout)
	if inout and self.fading_in then return end
	if (not inout) and self.fading_out then return end


	local uid = "prompt_fade" .. self.args.event
	if not self.curr_alpha then
		self.curr_alpha = 0
	end
	if inout then
		if self.fading_out then
			-- Fadeout cancel
			self.fading_out = false
		end
		if (self.curr_alpha ~= 255) and (cfg.prompt_fade_in_time and (cfg.prompt_fade_in_time > 0)) then
			self.fading_in = true
			self:ManageFadeAnim(
				self.curr_alpha, 255, cfg.prompt_fade_in_time, uid .. "in", false, nil, nil, nil, 
				nil,
				nil, self.AbortFadeIn
			)
		end
	else
		if self.fading_in then
			self.fading_in = false
		end
		if (self.curr_alpha ~= 0) and (cfg.prompt_fade_out_time and (cfg.prompt_fade_out_time > 0)) then
			-- This doesn't seem to be working - investigate
			self.fading_out = true
			self:ManageFadeAnim(
				self.curr_alpha, 0, cfg.prompt_fade_out_time, uid .. "out", false, nil, nil, nil, 
				nil,
				self.UpdatePromptVisibility, self.AbortFadeOut
			)
		end
	end
end
		
function InteractPrompt:UpdatePromptVisibility(tf)
	self.wnd:Show(tf)
end

function InteractPrompt:RegisterScriptCallbacks(tf)
	if self.callbacks_set and not tf then
		UnregisterScriptCallback("on_key_hold", self)
		UnregisterScriptCallback("on_key_press", self)
		self.callbacks_set = false
	elseif tf and not self.callbacks_set then
		RegisterScriptCallback("on_key_hold", self)
		RegisterScriptCallback("on_key_press", self)
		self.callbacks_set = true
	end
end

function InteractPrompt:OnVisibilityChange(state, reason)
	local _ = debug_dump and vl("[%s][InteractPrompt:OnVisibilityChange] to %s%s", time_global(), state, reason)

	self:RegisterScriptCallbacks(state)

	if self.campfire_tut then
		_ = debug_dump and vl("Checking campfire state for %s", self.args.tutorial)
		local obj = get_nearby_campfire(5, false)
		if obj then
			local mark = self:GetMark()
			if mark then
				mark:ActiveSwap(state)
				if state and can_start_popin_anim(mark) then
					init_active_marker_popin(mark)
				end
			end
		else
			dl("Clearing stuck tutorial %s at %s", self.tutorial, time_global())
			self:Destroy()
		return end
	end
end

function InteractPrompt:ShowPrompt(tf, reason)
	if (tf and self.destroyed) then return end
	tf = not not tf
	reason = reason and (" (" .. reason .. ")") or ""
	self.peak_hold = nil
	local _ = debug_dump and vl("ShowPrompt %s: %s%s", self.active_prompt, tf, reason)
	self.line:SetProgressPos(tf and (not cfg.hide_connecting_line) and 1 or 0)
	if self.longpress and not tf then
		self.longpress:SetProgressPos(0)
	end
	self.disabled = not tf
	if self.last_state ~= self.disabled then
		self.last_state = self.disabled
		self:OnVisibilityChange(tf, reason)
	end
	self:AnimateFade(tf)
	if not self.fading_out then
		self:UpdatePromptVisibility(tf)
	end
end

function InteractPrompt:Prefix(set)
	if set then self.active_prefix = set end
	return (set or self.active_prefix or (self.args and self.args.act) or "")
end

function InteractPrompt:Prompt(set)
	if set then self.active_prompt = set end
	return (set or self.active_prompt or (self.args and self.args.text) or "")
end

function InteractPrompt:Suffix(set)
	if set then self.active_suffix = set end
	return (set or self.active_suffix or (self.args and self.args.suffix) or "")
end

function InteractPrompt:GetFullPrompt(prefix, prompt, suffix)
	return self:Prefix(prefix) .. self:Prompt(prompt) .. self:Suffix(suffix)
end

function InteractPrompt:SetPrompt(new_prefix, new_prompt, new_suffix)
	local new_text  = self:GetFullPrompt(new_prefix, new_prompt, new_suffix)
	local color_text, plain_text
	if self.parse_text_colors then
		color_text = parse_color_tokens(new_text, nil, true)
		plain_text = parse_color_tokens(new_text, nil, false)
	end
	local _ = debug_dump and vl("InteractPrompt:SetPrompt(%s, %s, %s) | %s", new_prefix, new_prompt, new_suffix, new_text)
	self.label:TextControl():SetText(color_text or new_text)
	self.label_sh:TextControl():SetText(plain_text or new_text)
	self.lref:TextControl():SetText(plain_text or new_text)
	self.lref:AdjustWidthToText()
	local pos = self:UpdatePromptLength()
	self.drop:SetWndSize(vector2():set(pos + fontscale(55), fontscale(22)))
end

function InteractPrompt:UpdateLongPress()
	if self.longpress then
		if (not self.busystate) and (cfg.held_key == self.args.key) and (cfg.held_mod == self.args.mod) then
			self.peak_hold = time_continual() - (cfg.held_time or 0)
			local prog = (self.peak_hold / self.hold_time)
			self.longpress:SetProgressPos(prog)
			CUIScriptWnd.Update(self)
		else
			self.longpress:SetProgressPos(0)
		end
	end
end

function InteractPrompt:on_quickhelp_text_update(raw_text, loc_string, trimmed_text)
	--dump("on_quickhelp_text_update | %s | %s | %s", raw_text, loc_string, trimmed_text)
	if not (loc_string and self.prompts[loc_string]) then return end
	if self.args.refresh_text then
		self.args.text = trimmed_text
		self:SetPrompt(self.args.text)
		return
	end        
end

function InteractPrompt:UpdateFilteredHints()
	if not (self.prompts and (self.args.is_door or self.args.is_button or self.args.is_workshop or is_already_target(self.args.id))) then return end
	local hint
	for k,v in pairs(self.prompts) do
		hint = v()
		if hint then
			if self.args.refresh_text then
				self.args.text = hint
				self:SetPrompt(self.args.text)
				return
			end            
		end
	end
	return hint
end

function InteractPrompt:UpdateMutantLootPrompt()
	if is_dead_mutant(self.args) and self.args.section then
		local can_loot, loot_msg = can_chop_body(self.args.section)
		local changed = (loot_msg ~= self.last_loot_msg)
		self.last_loot_msg = loot_msg
		local prefix = (not can_loot) and gts("st_alti_cannot") or nil
		self:Suffix(can_loot and "" or (loot_msg and (": " .. gts(loot_msg))) or "")
		self:BusyState(not can_loot, prefix, changed)
	end
end

function InteractPrompt:UpdateAnimBusyState()
	if anims_enabled and cfg.prompt_busy_during_anim and not self.busy_locked then
		self:BusyState(anim_playing)
	end
end

function InteractPrompt:UpdatePrimaryInteractText()
	if self.prompts then return end
	-- Skip any markers already checked against hint filters
	if (
		self.door or
		(not self.args.text) or
		(self.args.text == "")
	) then
		local hint = hintfilters.last_raw_text and trimmed_prompt(hintfilters.last_raw_text)
		self:SetPrompt(nil, hint or self.args.text or "")
	end
end

function InteractPrompt:CheckForStuckTutorial()
	_ = (not self.init_done) and vl("Updates for this type are handled in main loop")
	if self.args.tutorial and (time_global() - self.init_done > 1000) then
		local monitor_active = state_monitor(self.args.tutorial)
		if ((not monitor_active) or (not game.has_active_tutorial())) then
			vl("No active tutorial, destroying prompt")
			self:Destroy("no active tutorial for " .. self.args.tutorial)
			return
		end
	end
end

function InteractPrompt:GetWoundedSuffix(last_aid, qty)
	if (last_aid ~= self.avail_aid) then
		self.aid_multi = nil
	end
	self.aid_multi = self.aid_multi or IsItem("multiuse", self.avail_aid)
	local text = string.format(" (%s %s%s)", qty or 0, self.aid_multi and (gts("st_alti_uses").." ") or "", gts("st_alti_owned"))
	return text
end

function InteractPrompt:CheckWoundedStalkers()
	self.avail_aid = nil
	local mark = self.args.id and cfg.markers[self.args.id]
	local last_aid = self.avail_aid
	self.avail_aid = cheapest_medical_help_owned()
	local qtyowned  = actor_aid_item_count(self.avail_aid) or 0
	if qtyowned < 1 then
		dump("InteractPrompt:CheckForWoundedStalkers found no health items")
		self.avail_aid = nil
		self:ShowPrompt(false)
		return
	end
	--dump("Generating heal prompt text for aid item %s", self.avail_aid)
	self.wounded_string = self.wounded_string or gts("st_alti_heal")
	local use_aid_name = gts(inventory_name(nil, self.avail_aid, true))
	self.args.text  = string.format(self.wounded_string, use_aid_name, mark.name)
	local suffix = self:GetWoundedSuffix(last_aid, qtyowned)
	self:SetPrompt(nil, self.args.text, suffix)
	self:UpdateLongPress()
	self:UpdateAnimBusyState()
end

function InteractPrompt:actor_on_update()
	if self.destroyed then return end
	local _ = debug_dump and vl("[%s][%s]InteractPrompt:actor_on_update | %s%s", self.args.id, self.args.event, self.init_done and "" or "first run at ", time_global())
	self:UpdateFilteredHints()
	
	local mark = self:GetMark()
	if (self.args.tutorial or mark.is_stalker) then
		self:CheckForStuckTutorial()
		_ = (not self.args.pri) and mark.is_wounded and self:CheckWoundedStalkers()
		return
	end

	if self.disabled then return end

	if self.args.pri then
		self:UpdatePrimaryInteractText()
		self:UpdateFaveJunkIcon()
		self:UpdateMutantLootPrompt()
	else
		self:UpdateLongPress()
	end

	self:UpdateAnimBusyState()
end

function InteractPrompt:Destroy(reason)
	self:ShowPrompt(false)
	self:HideDialog()
	self.hint_filters   = nil
	self.destroyed      = true
	get_hud():RemoveDialogToRender(self)
	
	if reason then
		dl("[InteractPrompt:Destroy][%s][%s]", self.args.id, reason)
	end
end

-- =======================================================================
--      MAIN LOGIC
-- =======================================================================

function get_font(num)
	local font = fonts[num or cfg.font_main_prompt or fallback_font]
	return font and font.font
end

function get_font_size(num)
	local font = fonts[num or cfg.font_main_prompt or fallback_font]
	return font and font.size
end

function get_font_scale(num)
	local scale = get_font_size() / 16
	return scale
end

function fontscale(i)
	return i * get_font_scale()
end

function init_target_metadata(id, meta_dat)
	if not cfg.target_data[id] then
		cfg.target_data[id] = {}
	end
	if meta_dat ~= nil and not cfg.target_data[id][meta_dat] then
		cfg.target_data[id][meta_dat] = {}
	end
end

function set_target_data(id, meta_dat, result)
	if not (id and meta_dat) then return end
	init_target_metadata(id, meta_dat)
	cfg.target_data[id][meta_dat].result = result
	return result
end

function get_metadata_record(id, meta_dat)
	return id and meta_dat and cfg.target_data[id] and cfg.target_data[id][meta_dat]
end

function get_target_data(id, meta_dat)
	return id and meta_dat and cfg.target_data[id] and cfg.target_data[id][meta_dat] and cfg.target_data[id][meta_dat].result
end

function ismeta_mutant(id)
	return get_target_data(id, cfg.metadata_types.is_mutant)
end

function ismeta_container(id)
	return get_target_data(id, cfg.metadata_types.is_container)
end

function ismeta_pickup(id)
	return get_target_data(id, cfg.metadata_types.is_pickup)
end

function ismeta_empty_mutant(id)
	return get_target_data(id, cfg.metadata_types.empty_mutant)
end

function is_dead_mutant(args, id)
	if id and not args then
		args = id and cfg.markers[id]
	end
	if args then
		return args.is_mutant and not args.is_alive
	end
end

function is_empty_mutant_corpse(id)
	if not is_dead_mutant(nil, id) then return end
	if get_metadata_record(id, cfg.metadata_types.is_empty_mutant) then
		return ismeta_empty_mutant(id)
	end
	local obj = id and get_game_object(id)
	local looted = obj and se_load_var(id, obj:name(), "looted")
	local st = db.storage[id]
	local decayed = (st and st.death_time and game.get_game_time():diffSec(st.death_time) > cfg.mutant_decay_time)
	local empty = (looted or decayed)
	--dump("is_empty_mutant_corpse: %s | looted %s | decayed %s", empty, looted, decayed)
	return empty and set_target_data(id, cfg.metadata_types.is_empty_mutant, empty)
end

function can_chop_body(section)
	if not section then return end
	local result, tip
	if (item_knife.is_equipped()) then
		if (item_knife.get_condition() < 0.15) then
			tip = "st_body_knife_bad"
		elseif (not item_knife.can_loot(section)) then
			tip = "st_body_knife_weak"
		else
			result = true
			tip = "st_body_loot"
		end
	else
		tip = "st_body_knife_needed"
	end
	return result, tip
end

function is_actor_in_sleep_zone()
	for k,v in pairs(ui_sleep_dialog.sleep_zones) do
		if utils_obj.npc_in_zone(db.actor, v) then
			return true
		end
	end
end


function get_current_target()
	--dump("current target: %s | L %s | T %s", locked_id or targeted_id, locked_id, targeted_id)
	return locked_id or targeted_id or nil
end

function is_current_target(id)
	if not id then return end
	local curr_target = get_current_target()
	--dump("id %s is %sthe current target", id, curr_target and (id == curr_target) and "" or "not ")
	return curr_target and (id == curr_target)
end

function get_current_target_obj()
	local id = get_current_target()
	return id and get_game_object(id) or nil
end

function is_target_pickup(id)
	id = id or get_current_target()
	if get_metadata_record(id, cfg.metadata_types.is_pickup) then
		return get_target_data(id, cfg.metadata_types.is_pickup)
	end
	local result = id and (id == cfg.available_pickup) or (cfg.markers[id] and cfg.markers[id].is_pickup)
	return set_target_data(id, cfg.metadata_types.is_pickup, result)
end

function is_target_container(id, cls)
	id = id or get_current_target()
	if get_metadata_record(id, cfg.metadata_types.is_container) then
		-- Get cached result if it exists
		return ismeta_container(id)
	end
	local result, obj
	result = id and cfg.markers[id] and cfg.markers[id].is_container
	if not result then
		obj = get_game_object(id)
		cls = cls or (obj and obj:clsid())
		if (obj and cls) then
			result = (IsInvbox(nil, cls) or (IsStalker(nil, cls) and not (obj:alive())))
		else
			result = false
		end
	end
	return set_target_data(id, cfg.metadata_types.is_container, result)
end

function state_monitor(tid)
	if not tid then return end
	local state = tuthooks and tuthooks.monitors and tuthooks.monitors[tid] and tuthooks.monitors[tid].state
	local conds = state and cfg.state_conds and cfg.state_conds[tid] or nil
	local cond  = true
	if state and (conds ~= nil) then
		cond = cfg.state_conds[tid](tid)
	end
	cfg.monitors[tid] = state and cond or false
	return cfg.monitors[tid]
end

function show_interaction_dots(tf)
	cfg.hide_interaction_dots = not tf
end

function check_for_dependencies(silent, debug_test)
	dl("[%s] Checking for dependencies", time_global())
	local failmessage
	local no_config             = not cfg
	dl("config loaded: %s", not no_config)
	-- Trap load failure

	dl("using_modded_exes: %s", using_modded_exes)
	-- Modded exes are a hard requirement, nothing will function without them

	local exes_version          = MODDED_EXES_VERSION or (get_modded_exes_version and get_modded_exes_version()) or 0
	local no_callback_old_exes   = (exes_version < 20250306)
	dl("no_callback_old_exes: %s", no_callback_old_exes)
	-- Modded exes found, but too old to support actor_on_update_pickup callback

	local no_callback_old_dbs   = (_G.CPickupModeUpdate_COD == nil) or not cfg.update_pickup_firing
	dl("no_callback_old_dbs: %s | found in _G %s | callback firing %s", no_callback_old_dbs, not (_G.CPickupModeUpdate_COD == nil), cfg.update_pickup_firing)
	-- Modded exes up to date, but stale DB files causing missing callback

	local no_lookat_method      = (exes_version < 20250225) or (not db.actor.get_actor_object_looking_at)
	dl("no_lookat_method: %s", no_lookat_method)
	-- Modded exes found, but too old even to support get_actor_object_looking_at

	local bad_mcm_version       = not valid_mcm_version(true)
	local ui_functors           = not not (ui_mcm and ui_mcm.UI_MCM and ui_mcm.UI_MCM.Init_Wrapper_Box)
	local mcm_version           = ui_mcm and ui_mcm.VERSION or "NOT FOUND"
	dl("bad_mcm_version: %s", bad_mcm_version)
	-- Version of MCM older than 1.7.0

	local no_hud_mark_manager   = (not hmm)
	dl("no_hud_mark_manager: %s", no_hud_mark_manager)
	-- HUD Mark Manager not found, which is really bad because we should've asserted by now

	local epic_fail             = (not using_modded_exes) or
									no_callback_old_exes or
									no_callback_old_dbs or
									no_hud_mark_manager or
									no_pickup_callback or
									no_lookat_method or
									bad_mcm_version or
									no_config
	if not (epic_fail or debug_test) then return end
	cfg = cfg or {}
	cfg.killswitch_all = true
	set_handler_callbacks(true)
	alert("Dependency check failed!")

	if (not using_modded_exes) or (debug_test and debug_test == 1) then
		failmessage         = gts("st_dotmarks_fail_reason_noexes") ..
							gts("st_get_modded_exes")

	elseif no_callback_old_exes or (debug_test and debug_test == 2) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldexes"), 20250306, exes_version) ..
							gts("st_get_modded_exes")

	elseif no_lookat_method or (debug_test and debug_test == 3) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldexes"), 20250225, exes_version) ..
							gts("st_get_modded_exes")

	elseif no_callback_old_dbs or (debug_test and debug_test == 4) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_staledbs"), exes_version) ..
							gts("st_get_modded_exes")

	elseif bad_mcm_version or (debug_test and debug_test == 5) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldmcm"), mcm_version, ui_functors) ..
							gts("st_catsy_get_mcm")

	elseif no_hud_mark_manager or (debug_test and debug_test == 6) then
		failmessage         = gts("st_dotmarks_fail_reason_nohmm")

	elseif no_config or (debug_test and debug_test == 7) then
		failmessage         = gts("st_dotmarks_fail_reason_nocfg")
	end

	if failmessage then
		failmessage = gts("st_dotmarks_epicfail_error") .. failmessage .. gts("st_catsy_failmessage_in_log_or_pda")
		local log_msg = parse_color_tokens(failmessage, nil, false)
		alert(log_msg)
		if silent and not debug_test then
			return epic_fail
		end

		failmessage = parse_color_tokens(failmessage)
		CreateTimeEvent("dotmarks_dependency_warning", 0, 4, (
			function()
				dotip(failmessage, 10000, "Interaction Dot Marks", true, "ui_inGame2_V_zone_nedavno_proshel_vibros")
				return true
			end
		))
	end
	return true
end

function actor_on_first_update()
	hmm = utils_catspaw_hudmarks and utils_catspaw_hudmarks.get_hud_mark_manager()
	CreateTimeEvent("dotmark_scan_delay", 0, cfg.scan_start_delay, start_scanning)
	maingameui = ActorMenu.get_maingame()
	xml = CScriptXmlInit()
end

function start_scanning()
	if check_for_dependencies(false) then return true end
	scanning = true
	if utils_catspaw_taskmonitor then
		utils_catspaw_taskmonitor.set_monitor_active(true)
	end
	return true
end

function stop_scanning()
	scanning = false
	if utils_catspaw_taskmonitor then
		utils_catspaw_taskmonitor.set_monitor_active(false)
	end
	return true
end

function get_args_for_valid_objects(obj)
	if not obj then return end
	local id = obj:id()
	local cls = obj:clsid()
	local sec = obj:section()
	local kind = get_obj_kind(obj)

	vl("get_args_for_valid_objects: %s - clsid %s", nameid(nil, id), cls)
	if is_blacklisted(id, cls, sec, kind) then
		local _ = debug_dump and vl("Object matched one or more blacklists: id %s | cls %s | sec %s | kind %s", cfg.blacklisted_ids[id], cfg.blacklisted_clsids[cls], cfg.blacklisted_sections[sec], cfg.blacklisted_kinds[kind])
		return
	end
	local args = { logged_type = "something else", section = sec, clsid = cls }

	local function setup_item_args(iclass)
		args            = get_cfg_for_type("args", iclass, obj) or {}
		if args.iclass_override then
			iclass      = args.iclass_override
			args        = get_cfg_for_type("args", iclass, obj) or {}
		end
		args.id         = id
		args.clsid      = cls
		args.kind       = kind
		args.section    = args.glowstick_sec or sec
		args.hidden     = not cfg.scan[iclass]
		args.has_power  = (item_device.dev_consumption[sec] or (sec == "batteries_dead")) or nil
	end

	local method
	local stype = get_type_for_section(sec)
	if stype then
		vl("Section %s found in lookup: %s", sec, stype)
		method = 0
		setup_item_args(stype)
	else
		local ktype = get_type_for_kind(kind)
		if ktype then
			vl("Kind %s found in lookup: %s", kind, ktype)
			method = 1
			setup_item_args(ktype)
		else
			for item_class, enabled in pairs(cfg.scan) do
				if cfg.is_item[item_class](obj, sec, cls, kind) then
					vl("Type found via iteration: %s", item_class)
					setup_item_args(item_class)
					method = 2
					break
				end
			end
		end
	end
	
	if not args.texture then
		local pid = cfg.available_pickup
		if (id == pid) then
			alert("Obj %s failed classification, but is detected by engine as a pickup!\n"..
				"$ Classifying \"Misc\" as a fallback, investigate: section %s | clsid %s | kind %s",
				nameid(nil, id), sec, cls, kind
			)
			setup_item_args("Misc")
		else
			dl("No args found for %s, no marker init | section %s | clsid %s | kind %s", nameid(nil, id), sec, cls, kind)
			return
		end
	end
	if not args.texture then return end

	local method_txt = (method > 1) and "iteration" or (method > 0) and "kind" or "section"
	dl("get_args_for_valid_objects: %s classification is %s (matched by %s) | section %s | kind %s", nameid(obj), args.logged_type, method_txt, sec, kind)
	return args
end

-- =======================================================================

--[[
function handle_primary_interact()
	-- no additional logic at this time, just need a stub function here
	-- Still necessary? Validate, pretty sure I can write around the need for a stub
end
--]]

function setup_pri_interact_prompt(mark, args)
	dl("[%s] setup_pri_interact_prompt for %s", mark.mark_id or "fixed interaction", args and (args.name or args.logged_type) or "unknown type with no passed args")
	if not mark then return end
	if mark.use_pri then
		mark.use_pri:Destroy("re-init of existing prompt")
		mark.use_pri = nil
	end
	args            = args or {}
	local anchor    = mark.marker or args.anchor
	local key       = bind_to_dik(key_bindings.kUSE)
	local bind_text = bindtext(key, 0)
	local int_text  = trimmed_prompt(get_quickhelp_text())

	if mark.is_pickup then
		int_text = gts("st_alti_take") .. " " .. (mark.money or mark.name)
	elseif mark and mark.is_stalker and mark.is_alive then
		int_text = gts("st_alti_speak") .. " " .. mark.name
	elseif mark and mark.is_door then
		int_text = int_text or trimmed_prompt(gts("car_character_use"))
	elseif mark and mark.is_container then
		int_text = gts("st_alti_search") .. " " .. mark.name
	elseif mark and (mark.is_npc and not mark.is_alive) then
		int_text = gts("st_body_loot")
	elseif mark and mark.hf_workshop then
		int_text = nil
	end

	local passed_args = {
		pri         = true,
		name        = mark.name or args.name or nil,
		text        = int_text,
		bind        = bind_text,
		key         = key,
		section     = section,
		func        = args and args.pri_handler_func or (function() end),
		event       = "pri_interact",
		monitors    = mark.monitors,
	}
	if args and not is_empty(args) then for k,v in pairs(args) do passed_args[k] = v end end

	mark.use_pri = InteractPrompt(anchor or maingameui, passed_args)
	return mark.use_pri
end


function setup_sec_interact_prompt(mark)
	if not mark then return end
	if mark.alt_interact then return end
	if mark.checked_for_sec then return end
	mark.checked_for_sec = true
	local id        = mark.id
	vl("[%s][%s] setup_sec_interact_prompt for %s", id, mark.mark_id, mark.name)
	local anchor    = mark.marker
	local obj       = id and get_game_object(id)
	local section   = obj and obj:section()
	local mode      = cfg.imod_sec_interact
	local act_text  = (mode == 2) and gts("st_alti_hold").." " or (mode == 1) and gts("st_alti_doubletap").." " or ""
	local bind_text = bindtext(cfg.bind_sec_interact, cfg.modk_sec_interact)
	local int_text  = ""
	local func      = handle_secondary_interact

	if obj and IsWeapon(obj) then
		if not cfg.sec_enable_unload_act then return end
		local atype     = obj:get_ammo_type() + 1
		local ammos     = parse_list(ini_sys, obj:section(), "ammo_class")
		local sec       = ammos and atype and ammos[atype]
		local ammo      = find_best_localization(nil, nil, sec)
		int_text        = string.format(gts("st_alti_prompt_ammo"),
			mag_installed and gts("st_alti_eject_mag") or gts("st_alti_unload_weapon"),
			ammo,
			mark.ammo_count,
			gts("st_alti_from"),
			mark.name
		)
		func = unload_and_take_ammo
	elseif mark.is_wounded then
		if not cfg.sec_enable_heal_act then return end
		func = help_wounded_stalker
	elseif mark.hf_workshop then
		int_text = gts("st_hf_workshop_menu")
	elseif mark.is_container then
		if not cfg.sec_enable_takeall_act then return end
		-- Inventory box or stash
		local weight = nil
		if not obj:is_inv_box_empty() then
			local tbl = get_inventory_table(obj, id)
			weight = axr_companions.get_inventory_weight(tbl)
		end
		if (section == "inv_backpack") then
			-- Pick up backpack and everything in it
			int_text = first_upper(gts("st_alti_pickup_bp"))
			func = pick_up_backpack
		elseif z_auto_looter and cfg.takeall_does_autoloot and not mark.autolooted then
			-- Trigger iTheon's autoloot
			int_text = string.format("%s %s",
				first_upper(gts("st_alti_autoloot")),
				mark.name
			)
			func = trigger_autoloot
		else
			-- Take everything from box
			int_text = string.format("%s %s",
				first_upper(gts("st_alti_takeall")),
				mark.name
			)
			func = take_all_from_box
		end
	elseif cfg.is_item.Tools(obj) then
		if not cfg.sec_enable_use_act then return end
		-- Usable tool
		local verb      = mark.use_verb or "st_alti_takeuse"
		int_text        = string.format(gts("st_alti_prompt_usable"),
			gts(verb),
			mark.name,
			gts("st_alti_now")
		)

	elseif cfg.is_item.Consumables(obj) then
		if not cfg.sec_enable_use_act then return end
		-- Consumable
		local verb      = mark.use_verb or (
			(mark.kind == "i_medical") and "st_alti_use_booster" or
			(cfg.smokables[section] and "st_alti_smokeout") or
			"st_alti_consume_food"
		)
		int_text        = string.format(gts("st_alti_prompt_usable"),
			gts(verb),
			mark.name,
			gts("st_alti_now")
		)
	elseif (mark.kind == "i_letter") then
		if not cfg.sec_enable_use_act then return end
		-- Readable
		int_text        = string.format(gts("st_alti_prompt_usable"),
			gts("st_alti_read"),
			mark.name,
			gts("st_alti_now")
		)
		func = take_and_read
	elseif section and IsItem("device", section) then
		if not cfg.sec_enable_unload_act then return end
		-- Device with battery power
		int_text        = string.format(gts("st_alti_prompt_usable"),
			first_upper(gts("st_item_unpack_battery")),
			gts("st_alti_from"),
			mark.name
		) 
		func = unpack_batteries
	elseif (mark.clsid == clsid.equ_backpack) then
		-- Backpack inventory item
		int_text        = string.format("%s %s",
			first_upper(gts("st_alti_deploy_bp")),
			mark.name
		)
		func = deploy_backpack
	else
		if not cfg.sec_enable_use_act then return end
		-- Fallback to generic "use" prompt
		int_text        = string.format(gts("st_alti_prompt_booster"),
			gts("st_alti_takeuse"),
			mark.name,
			gts("st_alti_now")
		)
	end

	local args = {
		mark    = mark,
		name    = mark.name,
		text    = int_text,
		act     = act_text,
		bind    = bind_text,
		long    = (mode == 2),
		func    = func,
		id      = id,
		event   = "sec_interact",
	}

	mark.alt_interact = InteractPrompt(anchor or maingameui, args)
end

function set_secondary_action(mark)
	if not mark then return end
	if mark.alt_interact then
		mark.alt_interact:Destroy("reinit as something else")
	end
	setup_sec_interact_prompt(mark)
end

-- =======================================================================

local scanned = {}

function unregister_scanned_entity(id)
	if not id then return end
	local ind = pickup_index[id]
	if ind then
		nearby_pickups[ind] = nil
	end
	cfg.in_pickup_range[id] = nil
	pickup_index[id] = nil
	cfg.invboxes[id] = nil
	cfg.target_data[id] = nil
	scanned[id] = nil
	if cfg.markers[id] then
		local mark = cfg.markers[id]
		if mark.use_pri then
			mark.use_pri:Destroy("unregistering pri use" .. id)
		end
		if mark.alt_interact then
			mark.alt_interact:Destroy("unregistering sec use")
		end
		if mark.preset then
			destroy_marker(mark.mark_id, "unregister_scanned_entity")
		else
			destroy_prompt(id, "unregister_scanned_entity")
		end
	end
	

	vl("[%s] Unregistering scanned entity for %s and nulling all pointers to it", time_global(), nameid(name, id))
end


function marked_obj_has_ammo(id)
	return id and cfg.markers[id] and (cfg.markers[id].ammo_count and cfg.markers[id].ammo_count > 0)
end

function can_pickup_glowstick(obj, id, dist)
	if dist > (cfg.obj_interact_dist or 2.5) then return false end
	obj         = obj or (id and get_game_object(id))
	id          = id or (obj and obj:id())
	local pos   = obj and obj:position()
	local dot   = pos and utils_catspaw_hudmarks and utils_catspaw_hudmarks.dotproduct_for_pos(pos) or 0
	return dot >= (cfg.target_lenience)
end

function obj_has_available_sec_interact(obj, id, mark)
	if not (obj or id) then return end
	if mark and (mark.no_sec or mark.is_display) then return false end

	id = id or (obj and safeid(obj))
	obj = obj or (id and get_game_object(id))
	if not obj then return end
	if cfg.useless_shit[obj:section()] then return end

	local cls           = obj and obj:clsid()
	local is_melee      = IsMelee(nil, cls)
	local has_ammo      = marked_obj_has_ammo(id) and not is_meele
	local is_consumable = cfg.is_item.Consumables(obj)
	local is_readable   = (mark and mark.is_readable)
	local has_batteries = (mark and mark.has_battery)
	local is_backpack   = (mark and mark.is_backpack)
	local is_interact   = mark.is_container or mark.hf_workshop

	local required      = (
		is_consumable or
		has_batteries or
		is_readable or
		has_ammo or
		is_interact
	)

	local banned        = (
		mark.money
	)

	local has_interact = required and not banned

	local _ = debug_dump and vl("[obj_has_available_sec_interact] %s: %s\n" ..
		"^ Required: interaction %s | batt %s | ammo %s | eatable %s | readable %s\n" ..
		"~ Banned: money %s",
		nameid(obj, id),
		has_interact,
		is_interact,
		has_batteries,
		has_ammo,
		is_consumable,
		is_readable,
		mark.money
	)
	return has_interact
end


function scan_nearby_object(obj)
	local id  = obj and obj:id()
	if not valid_id(id) then return end
	local name = obj and obj:name()

	if scanned[id] then
		-- Skip previously-scanned IDs if their name matches, otherwise clear the table entry assuming it's a reused ID
		if scanned[id] == name then
			--dump("%s has already been scanned, skipping", nameid(name, id))
		return end
		dl("%s has a new name, assuming the ID has been reused and clearing entry", id)
		scanned[id] = nil
	end

	local m_id  = "dotmark_" .. tostring(id)
	hmm = hmm or utils_catspaw_hudmarks.get_hud_mark_manager()
	if not hmm then return end

	local cls = obj:clsid()
	local sec = obj:section()

	if hmm:GetMarker(m_id) then
		-- Already a marker for this ID, skip
	else
		scanned[id] = name
		dl("[DotMarks] scanning unmarked object %s | clsid %s | [%s]", nameid(name, id), cls, sec)
		local args  = get_args_for_valid_objects(obj)
		if not args then return end

		args            = args or {}
		args.id         = id
		args.mark_id    = m_id
		args.name       = args.name or find_best_localization(obj, nil, sec) or nil
		args.preset     = "dotmark"

		if debug_dump then
			vl("Passing the following args to utils_catspaw_hudmarks:")
			for k,v in pairs(args) do
				vl("%s = %s", k, v)
			end
		end

		if not cfg.markers then cfg.markers = {} end
		cfg.markers[id] = hmm:AddMarker(args)
		local mark = cfg.markers[id]

		if (not cfg.hide_pri_interact_ui) and not (args.no_pri) then
			setup_pri_interact_prompt(mark, args)
		end
		if obj_has_available_sec_interact(obj, id, mark) and not (args.no_sec) then
			setup_sec_interact_prompt(mark)
		end
		if (not mark.active_swap) and cfg.enable_icon_targetdot then
			mark.active_swap = cfg.swap_dotactive
		end
		
		has_cond = (sec and cls) and (utils_item.is_degradable(nil, sec) or IsWeapon(nil, cls) or IsOutfit(nil, cls) or IsHeadgear(nil, cls))
		local is_mag = magazine_binder and sec and magazine_binder.is_magazine(sec)
		if has_cond and not is_mag then
			mark.condition = obj and obj:condition()
		end
	end
end


function scan_nearby_entities(scan_radius)
	local pos = db.actor and db.actor:center()
	if not pos then return end
	level.iterate_nearest(pos, scan_radius, scan_nearby_object)
end


function dot_eye(position)
	-- Taken from Crook's Faction ID
	local toPoint = vector():set(position):sub(device().cam_pos):normalize()
	local toEye = device().cam_dir
	local dot = toPoint:dotproduct(toEye)
	
	return dot
end

local function log_target_acquisition(method, last_id)
	if not (debug_dump and method) then return end
	local target = targeted_id and get_game_object(targeted_id)
	if not target then return end
	local method_txt = ""
	if method < 0 then
		target = last_id and get_game_object(last_id)
		if target then
			dump("[%s] update_targeted_object: no longer targeting %s", time_global(), nameid(target))
		end
		return
	elseif method > 1 then
		method_txt = "avail_pickup"
	elseif method > 0 then
		method_txt = "looking_at"
	else
		method_txt = "target_obj"
	end
	dump("[%s] update_targeted_object: targeted_id is now %s (%s) | method %s", time_global(), targeted_id, target and target:name(), method_txt)
end

function is_marker_object_container(obj, id)
	id = id or (obj and obj:id())
	return id and cfg.markers[id] and cfg.markers[id].is_container
end

function update_targeted_object()
	local last_id = targeted_id
	local target, method

	if db.actor.get_actor_object_looking_at then
		-- 20250225 modded exes required for this method
		target = db.actor:get_actor_object_looking_at()
		method = 1
	elseif cfg.use_fallback_targeting then
		-- Vanilla but very finicky, requires the object to be precisely under the crosshair
		target = level.get_target_obj()
		method = 0
	end
	if cfg.available_pickup and not is_marker_object_container(target) then
		target = get_game_object(cfg.available_pickup)
		method = 2
		-- 20250306 modded exes required for pickup callback
	end    

	local id = target and target:id()
	if cfg.racked_items[id] then
		targeted_id = cfg.racked_items[id]
		target = get_game_object(targeted_id)
	else
		targeted_id = id
	end

	cfg.active_task_target_id = get_task_target()
	if targeted_id then
		if target and (method < 1) and cfg.fallback_distance_check and (targeted_id ~= last_id) then
			local apos = db.actor:position()
			local dist = apos:distance_to(target:position())
			if dist > (cfg.obj_interact_dist or 2.5) then
				targeted_id = nil
			end
		end
	elseif last_id then
		method = -1
	else
		return
	end
	log_target_acquisition(method, last_id)
end


function actor_on_net_destroy()
	stop_scanning()
end

function get_inventory_table(box, id)
	-- Streamlined version of the one in axr_companions
	box = box or (id and get_game_object(id))
	local t = {}
	local i = 0
	if box then
		id = id or box:id()
		local function iterate(owner, item)
			i = i + 1
			local item_id = item:id()
			local item_sec = item:section()
			t[item_id] = item_sec
		end
		iterate_any_inventory(box, iterate)
	end
	return t, i
end

function deploy_backpack(backpack)
	local pos = backpack and backpack:position()
	if not pos then return end
	local actor = db.actor
	local se_obj = actor and alife_create("inv_backpack", pos, actor:level_vertex_id(), actor:game_vertex_id())
	local section = backpack:section()
	if (se_obj and section) then
		local txt = string.format(gts("st_itm_stash_of_character"), db.actor:character_name())
		level.map_add_object_spot_ser(se_obj.id, "treasure", txt)
		actor_menu.set_msg(1, gts("st_stash_created"),4)
		
		local m_data = alife_storage_manager.get_state()
		if not (m_data.player_created_stashes) then 
			m_data.player_created_stashes = {}
		end
		
		m_data.player_created_stashes[se_obj.id] = section
		
		alife_release(backpack)
	end
end

function remove_placed_backpack(id)
	if not id then return end
	level.map_remove_object_spot(id, "treasure")
	local se_obj = alife_object(id)

	if se_obj then
		alife_release(se_obj)
	end
	
	local m_data = alife_storage_manager.get_state()
	if (m_data.player_created_stashes and m_data.player_created_stashes[id]) then 
		local section = m_data.player_created_stashes[id]
		alife_create_item(section, db.actor)
		m_data.player_created_stashes[id] = nil
	end
	return true
end

function iterate_any_inventory(box, func)
	if not (box and func) then return end
	if IsStalker(nil, box:clsid()) then
		box:iterate_inventory(func)
	else
		box:iterate_inventory_box(func)
	end
end

function cheapest_medical_help_owned(who)
	who = who or db.actor
	if not who then return end
	local medkit
	local medhelp = {
		[1] = "medkit",
		[2] = "medkit_army",
		[3] = "medkit_scientic",
		[4] = "stimpack",
		[5] = "stimpack_army",
		[6] = "stimpack_scientic"
	}
	for i = 1, #medhelp do
		medkit = medhelp[i]
		if medkit and who:object(medkit) then
			return medkit
		end
	end
end

function actor_aid_item_count(section)
	if not db.actor then return end
	local num_owned = section and utils_item.get_amount(db.actor, section, 1) or 0
	return num_owned   
end

function try_init_heal_anim(npc, mark, exec_func)
	end_mark_wounded_state(mark)
	cfg.hidden_before_anim = mark.hidden
	mark.hidden = true
	if npc and exec_func and cfg.sec_enable_heal_anim and not cfg.healing_stalker then
		if zzz_wounded_heal_anim then
			cfg.healing_stalker = npc:id()
			zzz_wounded_heal_anim.use_injector(npc)
		elseif liz_fdda_redone_body_search then
			-- Largely adapted from FDDAR's body search
			cfg.healing_stalker = npc:id()
			local pos = npc and utils_obj.safe_bone_pos(npc, "bip01_spine1") or npc:position()
			db.actor:actor_look_at_point(liz_fdda_redone_body_search.clamp_target_pos_height(pos, 10))
			local is_crouching = IsMoveState('mcCrouch')
			local is_crouch_togglable = get_console_cmd(1, "g_crouch_toggle")
			if not is_crouch_togglable then exec_console_cmd("g_crouch_toggle 1") end
			level.press_action(bind_to_dik(key_bindings.kCROUCH))
			level.release_action(bind_to_dik(key_bindings.kCROUCH))
			db.actor:hide_weapon()
			level.disable_input()

			local end_time = time_global() + 500

			CreateTimeEvent("dotmarks_heal_stalker", 0, 0, (
				function()
					if time_global() > end_time then
						utils_obj.play_sound("interface\\inv_stim_4p3")
						cfg.healing_stalker = nil
						exec_func(npc, mark, true)
						db.actor:actor_stop_look_at_point()
						level.enable_input()
						if is_crouching ~= IsMoveState('mcCrouch') then
							level.press_action(bind_to_dik(key_bindings.kCROUCH))
							level.release_action(bind_to_dik(key_bindings.kCROUCH))
							if not is_crouch_togglable then exec_console_cmd("g_crouch_toggle 0") end
						end                    
						return true
					end
				end
			))
		end
		return true
	end
end

function heal_anim_end()
	local id = cfg.healing_stalker
	local npc = id and get_game_object(id)
	local mark = id and cfg.markers[id]
	if not (npc and mark) then return end
	help_wounded_stalker(npc, mark, true)
end

function help_wounded_stalker(npc, mark, skip_anim_check)
	if not mark then return end
	if (not skip_anim_check) and try_init_heal_anim(npc, mark, help_wounded_stalker) then
		vl("[%s] help_wounded_stalker: search anim check, not processing on this call", time_global())
		return true
	end
	mark.hidden = cfg.hidden_before_anim
	cfg.hidden_before_anim = nil
	if not (npc and mark) then return true end
	local medkit    = cheapest_medical_help_owned()
	local count     = medkit and actor_aid_item_count(medkit)
	if (not count) or (count < 1) then return true end
	alife_create_item("medkit_script", npc)
	xr_wounded.unlock_medkit(npc)
	game_statistics.increment_npc_statistic(db.actor, "wounded_helped")
end


function hijack_autoloot_keybind()
	if z_auto_looter and cfg.takeall_does_autoloot and cfg.hijack_autoloot_keybind then
		z_auto_looter.config.looter_key = cfg.autoloot_hijack_value
	end
end

function can_play_search_anim(mark)
	if not mark then return end
	vl("can_play_search_anim | %s | stalker %s | container %s", nameid(mark.name, mark.id), mark.is_stalker, mark.is_container)
	if not (cfg.fddar_body_search and cfg.search_anim_on_takeall) then return end
	if mark.is_stalker then return true end
	if cfg.fddar_container_search and mark.is_container then return true end
end

function try_init_search_anim(box, mark, exec_func)
	if box and exec_func and can_play_search_anim(mark) then
		local action_start = fddar_bodysearch.get_template_action_looting_start(box)
		action_start.is_show_ui = true
		lam2.add_action(action_start)
		local action_idle = fddar_bodysearch.get_template_action_looting_idle(box)
		cfg.block_loot_window = time_global()
		action_idle.on_execute = (
			function (self, time)
				if npc_loot_claim and npc_loot_claim.actor_looting_claimed then
					self.force_close = true
				end
				if self.force_close or (time > self.ui_open_delay) or lam2.has_queued_actions() then
					if not self.is_input_enabled then
						self.is_input_enabled = true
						if cfg.fddar_disable_walk then level.enable_input() end
					end
					if haru_skills then fddar_bodysearch.haruka_scavanger_effect() end
					self.force_close = true
					local action_stop = fddar_bodysearch.get_template_action_looting_end()
					lam2.add_action_first(action_stop)
					return lam2.states.success
				end
				return lam2.states.running
			end
		)
		lam2.add_action(action_idle)
		CreateTimeEvent("dotmarks_fddar_takeall", 0, 0.25, (
			function()
				if (not anim_playing) then
					exec_func(box, mark, true)
					cfg.block_loot_window = nil
					return true
				end
			end
		))
		return true
	end
end

function trigger_autoloot(box, mark, skip_anim_check)
	vl("[%s] trigger_autoloot | %s | skip_anim_check %s", time_global(), nameid(box), not not skip_anim_check)
	if not (zz_autoloot_dotmarks and z_auto_looter and z_auto_looter.auto_looter) then return true end
	local id = box and box:id()
	if not id then return true end
	if is_body_claimed(id) then return true end
	if (not skip_anim_check) and try_init_search_anim(box, mark, trigger_autoloot) then
		vl("[%s] trigger_autoloot: search anim check, not processing inv on this call", time_global())
		return true
	end

	dl("[%s] Calling Auto Looter for %s", time_global(), nameid(box))
	zz_autoloot_dotmarks.override_id = id
	hijack_autoloot_keybind()
	z_auto_looter.auto_looter(z_auto_looter.config.looter_key)
	mark = mark or (id and cfg.markers[id])
	mark.autolooted = true
	if mark.alt_interact then
		mark.alt_interact.args.func = take_all_from_box
		mark.alt_interact.args.name = string.format("%s %s", first_upper( gts("st_alti_takeall") ), mark.name)
		mark.alt_interact:Prompt(mark.alt_interact.args.name)
		mark.alt_interact:SetPrompt()
	end
	return true
end

function take_all_from_box(box, mark, skip_anim_check)
	vl("take_all_from_box | %s | skip_anim_check %s", nameid(box), not not skip_anim_check)
	if not box then return end
	if (not skip_anim_check) and try_init_search_anim(box, mark, take_all_from_box) then
		return true
	end
	local id = box:id()
	if is_body_claimed(id) then return true end

	local function itr_inv(temp, item)
		box:transfer_item(item, db.actor)
		SendScriptCallback("actor_on_item_take_from_box", box, item)
	end
	iterate_any_inventory(box, itr_inv)
	if cfg.markers[id] then
		cfg.markers[id].has_items = false
	end
	utils_obj.play_sound("interface\\items\\inv_items_take_all")
	return true
end


function pick_up_backpack(obj)
	local id = obj and obj:id()
	if not id then return end

	local data = {
		stash_id = id,
		cancel = false,
	}
	SendScriptCallback("actor_on_stash_remove",data)
	if data.cancel then
		return
	end

	if not obj:is_inv_box_empty() then
		take_all_from_box(obj)
	end
	
	CreateTimeEvent("bp_take_all", 0, 0.05, remove_placed_backpack, id)
end


function eject_mag_from_ground(wpn)
	-- Largely adapted from the similar eject function in Mags Redux
	if not mags_installed then return end
	if wpn:weapon_in_grenade_mode() or not magazine_binder.is_supported_weapon(wpn) then return end
	local id = wpn:id()

	magazine_binder.validate_wep(id)
	
	local mag_data = magazine_binder.get_mag_loaded(id)
	
	if mag_data then
		wpn:force_unload_magazine(false)
		wpn:unload_magazine()
		if magazines.retain_round(wpn) and #mag_data.loaded > 0 then
			vl("retaining round of type %s in chamber", stack.peek(mag_data.loaded))
			stack.pop(mag_data.loaded)
			wpn:set_ammo_elapsed(1)
		else
			wpn:set_ammo_elapsed(0)
		end
		
		se_mag = alife_create_item(mag_data.section, db.actor)
		if se_mag then
			magazines.create_time_event("mag_redux", "timer_eject_"..id, 0, magazines.timer_eject_magazine, id, se_mag.id, mag_data)
		else
			dl("Could not create magazine %s", mag_data.section)
		end
		magazine_binder.set_data(id, {
			section     = "no_mag",
			loaded      = {},
			is_weapon   = true,
		})
		magazine_binder.dump_data(mag_data)
		return se_mag.id
	end
end

function unload_and_take_ammo(wpn)
	if not (wpn and IsWeapon(wpn)) then return end
	local count = wpn:get_ammo_in_magazine()
	if count < 1 then return end
	local atype = wpn:get_ammo_type() + 1
	local ammos = parse_list(ini_sys, wpn:section(), "ammo_class")
	local sec   = ammos and atype and ammos[atype]
	
	if mags_installed then
		vl("Ejecting magazine with %s rounds of %s from %s and giving the mag to actor", count, sec, wpn:name())
		eject_mag_from_ground(wpn)
	else
		vl("Unloading %s rounds of %s from %s and giving the ammo to actor", count, sec, wpn:name())
		alife_create_item(sec, db.actor, {ammo = count})
		wpn:unload_magazine()
	end

	local id = wpn:id()
	cfg.markers[id].ammo_count = 0
end

function unpack_batteries(obj)
	-- like in item_device.func_battery, except without the parent check
	local sec   = obj:section()
	local con   = obj:condition()
	local batt  = item_device.device_battery
	local id    = obj:id()
	local dead  = 0.0001
	if ini_sys:section_exist(batt) then
		-- Create new battery for actor and process old one
		alife_create_item(batt, db.actor, {cond = con})
		alife_process_item(sec, id, {cond = dead})
		actor_effects.play_item_fx(batt)
		utils_obj.play_sound("interface\\inv_batt")
	end
	local mark = id and cfg.markers[id]
	if not (mark and mark.use_pri) then return end
	mark.condition = dead
	mark.use_pri:SetConditionText(sec, dead)
	mark.use_pri:SetPrompt()
end

function is_obj_interact_dist(obj)
	if not (obj and db.actor) then return end
	local pos = obj:center()
	return pos and (pos:distance_to(db.actor:center()) <= (cfg.obj_interact_dist or 2.5))
end


function prompt_blocked_by_anim()
	if (not anim_playing) then
		return false
	end
	return not cfg.show_prompt_during_anim
end

function do_consume_action(id, manual_use)
	local obj = id and get_game_object(id)
	if not obj then return true end
	if (anims_enabled and not manual_use) then
		local _ = debug_dump and vl("[%s] passing consume action of %s to FDDA", time_global(), nameid(obj, id))
		SendScriptCallback("actor_on_item_before_use", obj, {ret_value = true})
	else
		local _ = debug_dump and vl("[%s] causing actor to consume/use %s", time_global(), nameid(obj, id))
		db.actor:eat(obj)
	end
end

function delay_action_for_anim(args)
	args = args or {}
	local id        = args.id
	local manual_use= args.manual
	local functor   = args.func
	vl("[%s] delay_action_for_anim start: id %s | manual %s | functor passed: %s", time_global(), id, manual, not not functor)
	if not (id and functor and (type(functor) == "function")) then return true end
	if not cfg.pending_actions[id] then
		-- Pending action record cleared, abort action
		return true
	end

	local timed_out = false
	if time_global() > cfg.pending_actions[id] then
		cfg.pending_actions[id] = nil
		timed_out = true
		-- Pending action timed out, execute action
	end
	
	if fdda_callback and anim_playing and not timed_out then
		return
	end
	if not functor then return true end
	functor(id, manual_use)
	return true
end

function force_actor_to_take(obj)
	vl("Forcing actor to take %s via active pickup callback", obj and obj:name())
	local send_pickup_callback = fdda_callback or item_pickup_intercept
	send_pickup_callback(obj, {force = true, ret_value = true})
end

function take_and_use(obj)
	if not (obj and db.actor) then return end
	local id = obj:id()
	force_actor_to_take(obj)
	if id then
		cfg.pending_actions[id] = time_global() + (cfg.item_use_timeout or 0)
		local manual_use = is_item_manual_use(obj)
		local args = {
			id = id,
			manual = manual_use,
			func = do_consume_action,
		}
		CreateTimeEvent("delayed_actor_use", time_global(), cfg.item_use_delay, delay_action_for_anim, args)
	end
end

function is_item_manual_use(obj, mark)
	local id    = obj and obj:id()
	local mark  = mark or (id and cfg.markers[id]) or {}
	local sec   = mark.section or (obj and obj:section())
	return mark.manual_use or cfg.manual_use[sec]
end

function delay_read_action(id)
	if fdda_callback and anim_playing then return end
	local obj = id and get_game_object(id)
	item_recipe.func_recipe(obj)
	return true
end

function take_and_read(obj)
	if not (obj and db.actor) then return end
	force_actor_to_take(obj)
	local id = obj and obj:id()
	if id then
		CreateTimeEvent("delayed_actor_use", time_global(), cfg.item_use_delay, delay_read_action, id)
	end
end

function handle_secondary_interact(obj)
	if prompt_blocked_by_anim() then
		local _ = debug_dump and vl("Actor tried to interact but is busy with another item animation")
	return end

	-- Get target object and do validation checks
	local id = get_current_target()
	obj = obj or (id and get_game_object(id))
	if not is_obj_interact_dist(obj) then return end
	local mark = cfg.markers[id]
	local prompt = mark and mark.alt_interact
	if cfg.prompt_busy_during_anim and prompt and prompt.busystate then return end

	-- Passed validation - identify handler, if any
	if IsWeapon(obj) then
		unload_and_take_ammo(obj)
	elseif (IsItem("eatable", obj:section())) then
		take_and_use(obj)
	elseif mark.hf_workshop then
		-- Do nothing, it opens its own menu
	else
		take_and_use(obj)
	end
end

function on_item_use_anim_start()
	anim_playing = true
end

function on_item_use_anim_stop()
	anim_playing = false
end

function cycle_targeted_pickup(dir)
	vl("cycle_targeted_pickup: %s | locked %s | target %s", dir and (dir > 0) and "next" or "previous", locked_id, targeted_id)
	if not (dir and get_current_target()) then return end
	local max       = size_table(nearby_pickups)
	local _ = debug_dump and vl("max %s | in_pickup_range %s", max, size_table(cfg.in_pickup_range))
	if (max < 2) or is_empty(cfg.in_pickup_range) then return end
	local id_curr   = get_current_target()
	local ind_curr  = pickup_index[id_curr] or 1
	local ind_new
	if (dir > 0) then
		ind_new     = (ind_curr < max) and (ind_curr + 1) or 1
	else
		ind_new     = (ind_curr > 1) and (ind_curr - 1) or max
	end
	locked_id       = nearby_pickups[ind_new]
	local _         = ind_new and (ind_new ~= ind_curr) and play_snd_path(cfg.snd_path_blip)
	vl("Pickup cycled | prev ind %s id %s | new ind %s id %s", ind_curr, nearby_pickups[ind_curr], ind_new, locked_id)
end


--[[
-- fixes cycling to items behind the player, but broken - investigate why
function cycle_targeted_pickup(dir)
	if not (dir and get_current_target()) then return end
	local max       = size_table(nearby_pickups)
	local _ = debug_dump and vl("max %s | in_pickup_range %s", max, size_table(cfg.in_pickup_range))
	if (max < 2) or is_empty(cfg.in_pickup_range) then return end
	local id_curr   = get_current_target()
	local ind_curr  = pickup_index[id_curr] or 1
	local checks    = 0
	local ind_new
	local curr = ind_curr
	local function cycle()
		checks = checks + 1
		if (dir > 0) then
			curr     = (curr < max) and (curr + 1) or 1
		else
			curr     = (curr > 1) and (curr - 1) or max
		end
		local id = nearby_pickups[curr]
		local mark = id and cfg.markers[id]
		if not (mark and mark.is_shown) then
			if (checks < max) then
				cycle()
				return
			else
				return
			end
		end
		ind_new = curr
	end
	cycle()

	locked_id       = nearby_pickups[ind_new]
	local _         = ind_new and (ind_new ~= ind_curr) and play_snd_path(cfg.snd_path_blip)
	vl("Pickup cycled | prev ind %s id %s | new ind %s id %s", ind_curr, nearby_pickups[ind_curr], ind_new, locked_id)
end
--]]

function reset_nearby_item_tables()
	locked_id       = nil
	actor_moved     = true
	cfg.last_pickup = nil
	nearby_pickups  = {}
	pickup_index    = {}
end

function update_nearby_pickups()
	if is_empty(cfg.in_pickup_range) then return end
	local actor_moving = (level.actor_moving_state() > 0)
	if actor_moving then
		reset_nearby_item_tables()
		return true
	end
	cfg.last_pickup = cfg.available_pickup
	if not is_empty(nearby_pickups) then return end
	-- pickup tables haven't been updated since actor stopped moving

	local i = 1
	for k,v in spairs(cfg.in_pickup_range) do
		nearby_pickups[i] = k
		pickup_index[k] = i
		i = i + 1
	end
	actor_moved = false
end

function setup_tutorial_prompt(tutorial)
	dump("Need to set up a new interact UI for tutorial %s", tutorial)
	local args = get_cfg_for_type("args", "Tutorials") or {}
	args.tutorial           = tutorial
	args.fixed              = true
	args.anchor             = maingameui
	args.active_prompt      = trimmed_prompt(gts(cfg.tutorial_hints[tutorial]))
	args.logged_type        = "tutorial prompt"
	cfg.markers[tutorial]   = setup_pri_interact_prompt(maingameui, args)
end

function dump_monitor_states()
	for k,v in pairs(cfg.monitors) do
		dump("State monitor for %s: %s", k, state_monitor(k))
	end
end

function check_tutorial_states()
	if cfg.tutorial_hints and is_not_empty(cfg.tutorial_hints) then
		if game.has_active_tutorial() then
			cfg.tutorials_cleared = false
		elseif (not cfg.tutorials_cleared) then
			for k,v in pairs(cfg.tutorial_hints) do
				if cfg.markers[k] then
					destroy_prompt(k, "destroying orphaned tutorial prompt")
				end
			end
			cfg.tutorials_cleared = true
		end
	end
end

function start_tutorial_prompt(tutorial, text, flags)
	vl("Tutorial start callback for %s: %s", tutorial, text)
	cfg.monitors[tutorial] = state_monitor(tutorial)
	if cfg.monitors[tutorial] then
		flags.ret_value = not cfg.hide_van_interact_ui
		cfg.tutorials_cleared = false
		if cfg.markers[tutorial] then
			cfg.markers[tutorial]:ShowPrompt(true)
		else
			setup_tutorial_prompt(tutorial)
		end
	end
end

function stop_tutorial_prompt(tutorial, text, flags)
	vl("Tutorial stop callback for %s, shutting down prompt", tutorial)
	cfg.monitors[tutorial] = false
	if cfg.markers[tutorial] then
		destroy_prompt(tutorial, "ending inactive tutorial via callback")
	end 
end

function update_skill_bonus_range()
	local skill = haru_skills and cfg.haru_skill_name and haru_skills.skills_levels[cfg.haru_skill_name]
	local sklev = skill and skill.current_level or 0
	cfg.skill_bonus_range = sklev * (cfg.haru_skill_coef or 0)
	return cfg.skill_bonus_range
end

function do_garbage_collection()
	local now = time_global()
	if cfg.pending_actions and not is_empty(cfg.pending_actions) then
		for k,v in pairs(cfg.pending_actions) do
			if now > (tonumber(v) or 0) then
				cfg.pending_actions[k] = nil
			end
		end
	end
	if cfg.block_loot_window then
		if (now - cfg.block_loot_window) > 3000 then
			cfg.block_loot_window = nil
		end
	end
end

function check_hint_filters()
	if not (cfg.hint_filter and cfg.hint_filter.enabled) then return end
	if is_empty(cfg.hint_filter.enabled) then return end
	local text = cfg.hint_filter.update_text()
end

local function perform_debugging_checks() end

-- =======================================================================
--      MAIN SCAN LOOP
-- =======================================================================
function actor_on_update()
	--perform_debugging_checks() -- only uncommented when needed
	if not scanning then return end
	cfg.actor_comm  = character_community(db.actor):sub(7)
	-- ===================================================================
	--  Hint filters
	--  Watches and manages the UIStaticQuickHelp text prompts
	-- ===================================================================
	check_hint_filters()
	-- ===================================================================
	--  Tutorial monitors
	--  Watches for state flags set by modxml_tutorial_hooks.script
	--  Mostly cleanup now that tutorials are handled via callbacks
	-- ===================================================================
	if cfg.tut_check_interval then
		if (next_tut_check <= time_global()) then
			next_tut_check = get_next_tg_interval(cfg.tut_check_interval)
			dotmarks_main.in_sleep_zone = is_actor_in_sleep_zone()
			check_tutorial_states()
		end
	end
	-- ===================================================================
	--  Update nearby pickup items and identifies current/locked target
	--  Accuracy is critical, should happen as often as possible
	-- ===================================================================    
	update_nearby_pickups()
	if locked_id then
		local _ = debug_dump and vl("locked_id is %s, skipping target updates and scans", locked_id)
		return
	end
	update_targeted_object()
	-- ===================================================================
	--  Skill system updates
	--  Rare, skillups don't occur often
	--  Needs to run before near_scan so that it applies radius changes
	-- ===================================================================
	if cfg.skill_upd_interval then
		if (next_skill_upd <= time_global()) then
			next_skill_upd  = get_next_tg_interval(cfg.skill_upd_interval)
			update_skill_bonus_range()
		end
	end
	-- ===================================================================
	--  Near scan - iterate objects within near_scan_radius
	--  This quickly picks up newly-spawned or dropped objects
	--  Frequent
	-- ===================================================================
	if cfg.near_scan_interval then
		if (next_near_scan <= time_global()) then
			next_near_scan   = get_next_tg_interval(cfg.near_scan_interval)
			scan_nearby_entities(near_scan_radius())
		end
	end
	-- ===================================================================
	--  Early scan - iterate within near_scan_radius + early_scan_radius
	--  Instantiates markers for objects before they would become visible
	--  Less frequent
	-- ===================================================================
	if cfg.early_scan_interval then
		if (next_early_scan <= time_global()) then
			next_early_scan   = get_next_tg_interval(cfg.early_scan_interval)
			scan_nearby_entities(early_scan_radius())
		end
	end
	do_garbage_collection()
end

-- =======================================================================


function on_before_key_press(key, bind, dis, flags)
	if cfg.watch_use and (key == use_dik) then
		cfg.use_released = nil
		cfg.block_loot_window = time_global()
		dump("[%s][on_before_key_press] Beginning hold of key %s", time_global(), key)
		cfg.held_key = key
		local id = get_current_target()
		if not id then return end
		local mark = cfg.markers[id]
		if not (mark and mark.is_stalker and mark.is_wounded) then return end
		--dump("NPC %s is wounded, supressing key", mark and mark.name)
		flags.ret_value = false
	end
end

function do_use_release_action_manually(id)
	local obj = get_game_object(id)
	local mark = id and cfg.markers[id]
	-- Target exists, no completed hold action
	if is_target_pickup(id) and ((id == locked_id) or not locked_id) then
		cfg.use_released = nil
		vl("No completed hold action, item pickup should occur")
		force_actor_to_take(obj)
	elseif is_target_container(id, obj:clsid()) then
		if z_ui_inventory_dotmarks then
			vl("[%s] No completed hold action, allow inventory interaction with %s", time_global(), obj:name())
			cfg.use_released = nil
			obj:use(db.actor)
		else
			alert("ERROR! z_ui_inventory_dotmarks could not be found, please reinstall DotMarks")
		end
	elseif mark and mark.is_stalker and mark.is_wounded then
		vl("Forcing actor to talk with wounded NPC")
		cfg.use_released = nil
		xr_effects.force_talk(db.actor, obj, {true})
	end
end

function on_key_release(key)
	cfg.block_loot_window = nil
	if key == cfg.held_mod then cfg.held_mod = nil end
	if (key == cfg.held_key) then
		if (key == use_dik) then
			cfg.held_key = nil
			cfg.use_released = cfg.use_released or time_global()
			local id = get_current_target()
			if not id then return end
			local dur = cfg.holding and cfg.holding.peak_hold
			local time = cfg.holding and cfg.holding.hold_time
			local _ = debug_dump and vl("[%s] on_key_release: use key was just released | dur held %s | hold time %s", cfg.use_released, dur, time)
			if not (dur and time and (dur >= time)) then
				do_use_release_action_manually(id)
			end
		end
	end
end

function actor_on_update_pickup(obj)
	cfg.update_pickup_firing = true
	cfg.last_pickup = cfg.available_pickup
	cfg.available_pickup = obj and obj:id() or nil

	if cfg.last_pickup and cfg.available_pickup and (cfg.last_pickup ~= cfg.available_pickup) then
		reset_nearby_item_tables()
	end
end

function actor_on_item_take(obj)
	local id = obj and obj:id()
	if id and cfg.markers[id] then
		dump("Actor just took %s, unregistering scanned object", nameid(obj, id))
		unregister_scanned_entity(id)
	end
end

function remove_obj_from_box_table(box, item)
	if not (box and item) then return end
	local b_id = box:id()
	if not cfg.invboxes[b_id] then return end
	if not cfg.invboxes[b_id].items then
		cfg.invboxes[b_id].items = {}
	end
	local i_id = item:id()
	cfg.invboxes[b_id].items[i_id] = nil

	local mark      = cfg.markers[b_id] or {}
	local was_items = mark.has_items
	local num_items = size_table(cfg.invboxes[b_id].items)
	mark.has_items  = num_items > 0
	vl("remove_obj_from_box_table completed for %s <- %s", item:name(), box:name())
end

function add_obj_to_box_table(box, item)
	if not (box and item) then return end
	local b_id = box:id()
	if not cfg.invboxes[b_id] then
		cfg.invboxes[b_id] = {}
	end
	if not cfg.invboxes[b_id].items then
		cfg.invboxes[b_id].items = {}
	end
	local i_id      = item:id()
	local sec       = item:section()
	cfg.invboxes[b_id].items[i_id] = sec

	local mark      = cfg.markers[b_id] or {}
	mark.has_items  = true
	vl("add_obj_to_box_table completed for %s -> %s", item:name(), box:name())
end

function ActorMenu_on_item_after_move(box_id, item, mode, bag_from)
	vl("ActorMenu_on_item_after_move: box %s | item %s | bag_from %s", box_id, nameid(item), bag_from)
	if (mode == 2) or (mode == "loot") then
		local box = box_id and get_game_object(box_id)
		if (bag_from == 7) or (bag_from == "npc_bag") then
			remove_obj_from_box_table(box, item)
		else
			add_obj_to_box_table(box, item)
		end
	end
end

function handle_npc_death(npc)
	local id = npc and npc:id()
	vl("NPC %s has died, unregistering them and re-registering as corpse object", nameid(npc))
	unregister_scanned_entity(id)
	scan_nearby_object(npc)
end

function on_mouse_wheel(scroll_dir, flags)
	if  (not cfg.wheel_cycles_pickups) or
		(not get_current_target()) or
		actor_menu.inventory_opened() or
		(item_device and item_device.is_pda_active()) or
		(ui_workshop.GUI and ui_workshop.GUI:IsShown()) or
		axr_main.binoc_is_zoomed or axr_main.scoped_weapon_is_zoomed then
	return end

	local direction         = (scroll_dir > 0) and 1 or -1
	local _ = debug_dump and vl("on_mouse_wheel: %s | direction: %s", scroll_dir, direction)
	cycle_targeted_pickup(direction)
	flags.ret_value         = false
end

function on_before_level_changing()
	dl("Shutting down for level change")
	shut_down()
end

function parse_color_data(color_key, csv_string)
	if not (color_key and csv_string) then return end
	local c         = csv_argb_to_tbl(csv_string)
	cfg.colors[color_key]   = c
	local str       = string.format("%" .. "%c[%s,%s,%s,%s]", c.a, c.r, c.g, c.b)
	set_color_token(color_key, str)
	return c
end

function parse_file_data()
	if cfg.colors then
		for k,v in pairs(cfg.colors) do
			if k:find("clr_") then
				parse_color_data(k, v)
			else
				cfg.colors[k]   = nil
			end
		end
	end
	cfg.weight_colors = {
		[0] = "clr_weight_ok",
		[1] = "clr_weight_high",
		[2] = "clr_weight_over"
	}

	cfg.show_part_condition     = (cfg.show_parts_weapons or cfg.show_parts_armor)
	cfg.color_icon_itemcard     = clr_tbl(cfg.color_icon_itemcard)
	cfg.unsquish_ratio          = utils_catspaw_hudmarks.update_unsquish_ratio() or 1
	cfg.unsquish                = (function(w) return (w or 0) * (cfg.unsquish_ratio or 1) end)
	local ini_mutant            = ini_file("items\\settings\\mutant_loot.ltx")
	cfg.mutant_decay_time       = ini_mutant:r_float_ex("mutant_loot_mod","decay_time") or 7200
	local factions      = game_relations.factions_table
	local ini_fac       = ini_file_ex("plugins\\faction_profile.ltx")
	cfg.notable_npcs    = {}
	cfg.vendors         = cfg.vendors or {}
	for _,fac in pairs(factions) do
		local fd = ini_fac:collect_section(fac)
		cfg.notable_npcs[fac] = {
			leader      = fd.leader,
			trader      = fd.trader,
			mechanic    = fd.mechanic,
			medic       = fd.medic,
			barman      = fd.barman,
			guide       = fd.guide
		}
		if fd.leader then   cfg.vendors[fd.leader]    = "leader" end
		if fd.trader then   cfg.vendors[fd.trader]    = "trader" end
		if fd.mechanic then cfg.vendors[fd.mechanic]  = "mechanic" end
		if fd.medic then    cfg.vendors[fd.medic]     = "medic" end
		if fd.barman then   cfg.vendors[fd.barman]    = "barman" end
		if fd.guide then    cfg.vendors[fd.guide]     = "guide" end
	end
	if debug_dump then
		vl("Loaded NPC vendors:")
		for k,v in pairs(cfg.vendors) do
			vl("|| %s = %s", k,v)
		end
	end
	hintfilters = cfg.hint_filter
end

function set_item_pickup_callbacks(kill)
	if kill or killswitch("pickup") then
		UnregisterScriptCallback("actor_on_item_before_pickup", item_pickup_intercept)
	elseif not get_fdda_callback() then
		RegisterScriptCallback("actor_on_item_before_pickup", item_pickup_intercept)
		dl("No form of FDDA installed, registering internal pickup callback")
		cfg.pickup_callback_set = true
	end
end

function set_item_anim_callbacks(kill)
	if lam2 and fddar_installed then
		if anims_enabled and not (kill or killswitch()) then
			if lam2.Subscribe then
				dl("Subscribing FDDAR item animation callbacks")
				lam2.Subscribe("on_anim_queue_start", on_item_use_anim_start)
				lam2.Subscribe("on_anim_queue_stop", on_item_use_anim_stop)
			else
				RegisterScriptCallback("actor_on_update", fddar_update_current_anim_state)
			end
		else
			if lam2.Unsubscribe then
				dl("Unsubscribing FDDAR item animation callbacks")
				lam2.Unsubscribe("on_anim_queue_start", on_item_use_anim_start)
				lam2.Unsubscribe("on_anim_queue_stop", on_item_use_anim_stop)
			else
				UnregisterScriptCallback("actor_on_update", fddar_update_current_anim_state)
			end
		end
	elseif ea_callbacks and fdda_installed then
		if anims_enabled and not (kill or killswitch()) then
			dl("Registering FDDA item animation callbacks")
			ea_callbacks.EA_RegisterScriptCallback("ea_on_item_use", on_item_use_anim_start)
			ea_callbacks.EA_RegisterScriptCallback("ea_on_item_anim_stop", on_item_use_anim_stop)
		else
			dl("Unregistering FDDA item animation callbacks")
			ea_callbacks.EA_UnregisterScriptCallback("ea_on_item_use", on_item_use_anim_start)
			ea_callbacks.EA_UnregisterScriptCallback("ea_on_item_anim_stop", on_item_use_anim_stop)
		end
	end
end

function set_handler_callbacks(kill)
	if kill or killswitch() then
		UnregisterScriptCallback("actor_on_update", actor_on_update)
		UnregisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		UnregisterScriptCallback("on_key_release", on_key_release)
		UnregisterScriptCallback("on_before_key_press", on_before_key_press)
		UnregisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		UnregisterScriptCallback("on_tutorial_prompt_start", start_tutorial_prompt)
		UnregisterScriptCallback("on_tutorial_prompt_stop", stop_tutorial_prompt)
		if kill then
			UnregisterScriptCallback("on_option_change", on_option_change)
		end
	else
		RegisterScriptCallback("actor_on_update", actor_on_update)
		RegisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		RegisterScriptCallback("on_key_release", on_key_release)
		RegisterScriptCallback("on_before_key_press", on_before_key_press)
		RegisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		RegisterScriptCallback("on_tutorial_prompt_start", start_tutorial_prompt)
		RegisterScriptCallback("on_tutorial_prompt_stop", stop_tutorial_prompt)
	end
	set_item_pickup_callbacks(kill)
	set_item_anim_callbacks(kill)
end

local function log_other_addon_settings()
	if not debug_dump then return end
	vl("Loaded settings from other addons:\n"..
		"fddar/pickup/multipickup -> fddar_multipickup %s\n" ..
		"fddar/pickup/enable -> fddar_pickup_anim %s\n" ..
		"EA_settings/enable_animations -> fdda_anims_enabled: %s\n" ..
		"EA_settings/take_item_anim -> fdda_pickup_anim: %s\n" ..
		"item_icon_info/part_dots/show_on_wpn -> show_parts_weapons: %s\n" ..
		"item_icon_info/part_dots/show_on_armor -> show_parts_armor: %s\n" ..
		"item_icon_info/part_dots/wpo_green -> parts_wpo_grn: %s\n" ..
		"item_icon_info/part_dots/wpo_yellow -> parts_wpo_yel: %s\n" ..
		"item_icon_info/part_dots/wpo_orange -> parts_wpo_orn: %s",
		cfg.fddar_multipickup, cfg.fddar_pickup_anim,
		cfg.fdda_anims_enabled, cfg.fdda_pickup_anim,
		cfg.show_parts_weapons, cfg.show_parts_armor,
		cfg.parts_wpo_grn, cfg.parts_wpo_yel, cfg.parts_wpo_orn
	)
end

function on_option_change()
	local _ = debug_dump and vl("on_option_change() triggered at %s", time_global())
	dl("Iterating through settings and looking for MCM overrides\n" ..
		"+ You may see a burst of MCM warnings about bad paths during this process. These are completely harmless and should be ignored."
	)
	debuglogs   = get_mcm("dotmarks/dmarkadv/debuglogs", debuglogs)
	verbose     = get_mcm("dotmarks/dmarkadv/verbose", verbose)
	local log 	= (debuglogs or debug_dump or verbose or DEV_DEBUG)
	local _ 	= log and printf("Debug logging enabled: %s | verbose %s | debug_dump %s | DEV_DEBUG %s", debuglogs, verbose, debug_dump, DEV_DEBUG)
	local last_version = ui_mcm.get("dotmarks/dmarkmain/last_version")
	local last_release = ui_mcm.get("dotmarks/dmarkmain/last_release")
	if not last_release then
		_=log and printf("No previous DotMarks version information found in MCM, setting to current version")
	else
		local vtext = "Found MCM config from DotMarks version %s, rel %s"
		if tonumber(last_release) < release_date then
			vtext = vtext .. ", updating to "..release_date.." release "..script_version
		end
		_=log and printf(vtext, last_version, last_release)
	end
	ui_mcm.set("dotmarks/dmarkmain/last_version", script_version)
	ui_mcm.set("dotmarks/dmarkmain/last_release", release_date)
	local reset_table = {
		[20250423]	= {
			pri_use_x_offset 		= true,
			pri_use_y_offset 		= true,
			sec_use_x_offset 		= true,
			sec_use_y_offset 		= true,
			b	= true
		}
	}
	local resets = {}
	for rel, opts in pairs(reset_table) do
		if (not last_release) or (last_release < rel) then
			dump("Existing release %s is older than %s, adding opts to reset table", last_release, rel)
			for k,v in pairs(opts) do
				dump("Will reset opt %s", k)
				resets[k] = v
			end
		end
	end

	vl("Loading config table")

	for k,v in pairs(cfg) do
		if type(v) ~= "table" then
			local mcm_path = cfg.mcm_paths[k]
			if mcm_path and mcm_path:find("/$") then
				mcm_path = mcm_path .. k
			end
			if mcm_path then
				if resets[k] then
					dl("Defaulting MCM value %s = %s (was %s)", k, v, get_mcm(mcm_path, cfg[k]))
					ui_mcm.set(mcm_path, v)
				else
					local foo = ui_mcm.get(mcm_path)
					cfg[k] = get_mcm(mcm_path, cfg[k])
					vl("Loading MCM value %s = %s", k, cfg[k])
				end
			else
				_ = debug_dump and vl("No MCM path found for %s, skipping", k)
			end
		end
	end
	if zz_autoloot_dotmarks then
		zz_autoloot_dotmarks.hijack_autoloot_keybind = cfg.hijack_autoloot_keybind
		cfg.keybind_hijack_value = zz_autoloot_dotmarks.keybind_hijack_value
	end
	log_other_addon_settings()

	if cfg.argb_dot_normal then
		parse_color_data("clr_dmark_norm", cfg.argb_dot_normal)
	end
	for k,v in pairs(cfg) do
		if k:find("^swap_") and v.load_argb then
			v.custom_argb = csv_argb_to_tbl(cfg[v.load_argb])

			if v.custom_argb then
				for i,j in pairs(v.custom_argb) do
				end
			end
			v.load_argb = nil
		end
	end

	for k,v in pairs(cfg.scan) do
		cfg.scan[k] = get_mcm("dotmarks/dmarkobjs/scan_" .. string.lower(k), cfg.scan[k])
		_ = debug_dump and vl("Scanning %s = %s", k, v)
	end

	if z_fdda_pickup_intercept_dotmarks then
		fddar_installed = (not not z_fdda_pickup_intercept_dotmarks.fddar_oibp)
		fdda_installed  = (not not z_fdda_pickup_intercept_dotmarks.fdda_oibp)
		anims_enabled   = (fddar_installed and cfg.fddar_pickup_anim) or (fdda_installed and cfg.fdda_pickup_anim and cfg.fdda_anims_enabled)
	end

	cfg.pending_actions = {}
	scanned             = {}
	use_dik             = bind_to_dik(key_bindings.kUSE)
	if cfg.bind_sec_interact == nil then
		cfg.bind_sec_interact = use_dik
	end
	cfg.watch_use   = (use_dik == cfg.bind_sec_interact) and not cfg.hide_sec_interact_ui
	if cfg.markers and not is_empty(cfg.markers) then
		for k,v in pairs(cfg.markers) do
			v:Destroy(nil, "reset after on_option_change")
		end
	end
	set_handler_callbacks()
	st_kg           = gts("st_kg")
	CreateTimeEvent("autoloot_override", 0, 0.25, hijack_autoloot_keybind)
end

function on_game_start()
	local script_version = dotmarks_main and dotmarks_main.script_version
	local release_date = dotmarks_main and dotmarks_main.release_date
	printf("Interaction Dot Marks %s (rel %s) began initialization at %s",
		script_version or "(version not found)", release_date or "missing", time_global()
	)
	valid_mcm_version = dotmarks_mcm and dotmarks_mcm.valid_mcm_version
	local bad_mcm_version = (not valid_mcm_version) or not valid_mcm_version()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	-- This callback is always registered so that we can notify the player of init failure
	local base_failed = not init_base_config(dotmarks_config_file, { logging = debug_dump, called_by = script_name })
	if cfg and (not bad_mcm_version) then
		mags_installed = (magazines and magazine_binder)
		parse_file_data()
		RegisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		RegisterScriptCallback("actor_on_item_take", actor_on_item_take)
		RegisterScriptCallback("ActorMenu_on_item_after_move", ActorMenu_on_item_after_move)
		RegisterScriptCallback("actor_on_item_take_from_box", remove_obj_from_box_table)
		RegisterScriptCallback("actor_on_item_put_in_box", add_obj_to_box_table)
		RegisterScriptCallback("actor_on_net_destroy", actor_on_net_destroy)
		RegisterScriptCallback("on_key_release", on_key_release)
		RegisterScriptCallback("on_before_key_press", on_before_key_press)
		RegisterScriptCallback("on_option_change", on_option_change)
		RegisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		RegisterScriptCallback("npc_on_death_callback", handle_npc_death)
		RegisterScriptCallback("monster_on_death_callback", handle_npc_death)
		RegisterScriptCallback("on_before_level_changing", on_before_level_changing)
		if stealth_kill_detection then
			RegisterScriptCallback("npc_on_silent_kill_callback", handle_npc_death)
		end
		on_option_change()
		if (fdda_installed and fddar_installed) then
			alert("WARNING: Both FDDA and FDDA Redone scripts were found, but FDDA scripts should be disabled! Leaving them both active can lead to busyhands or other serious issues.")
		end
		return
	end

	local failmsg = ""
	if base_failed then
		cfg = nil
		failmsg = " to load base config from dotmarks_main"
	elseif bad_mcm_version then
		failmsg = string.format(" to detect MCM 1.7.0 or higher")
	elseif not cfg then
		cfg = nil
		failmsg = string.format(" to load config file %s", dotmarks_config_file)
	end
	alert("[%s] ERROR: Initialization failed%s!\n" ..
		"! DotMarks startup aborted, skipping callback registration", script_name, failmsg)
end
