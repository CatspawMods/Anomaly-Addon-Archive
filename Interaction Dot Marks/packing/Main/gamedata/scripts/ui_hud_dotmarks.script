-- =======================================================================
--[[    Interaction Dot Marks ("DotMarks")
-- ===================================================================--]]
script_name     = "ui_hud_dotmarks"
--[[======================================================================
	Author: Catspaw (CatspawMods @ ModDB)
	Source: https://github.com/CatspawMods/Anomaly-Addon-Archive

	I post gameplay video on my Youtube channel, Catspaw Adventures: 
	https://www.youtube.com/@CatspawAdventures
-- =======================================================================
	A blatant imitation of the "interaction dot" HUD markers in Stalker 2,
	and some of its other UI niceties such as floating prompts and 
	secondary interactions.

	Except not quite as cool, because Anomaly is jank. Hopefully this 
	makes it a little less jank.

	Also implements a "Secondary Interact" keybind with contextual 
	actions such as unloading a weapon without having to pick it up.
-- =======================================================================
	See dotmarks_main.script for dependencies.
-- =======================================================================
	TODO (all non-critical):
	- Deploying IEDs pretty much working, marker anim for it is not
		May need to table that until after release
	- Add "welcome" message similar to PAW, controlled by MCM flag
		May be a post-release thing
	- Update GH documentation with new Utjan and IED settings
	- Correct the MCM text and documentation for changed defaults

	BEFORE PUBLIC RELEASE:
	- FEATURE FREEZE is now in effect - nothing new gets added
	- Re-validate EVERY FEATURE individually - all must pass in same build

	POST-RELEASE:
	- MCM live preview for prompt elements - lots of work
	- Encyclopedia entry/entries - relatively easy, just need writing
	- NPE module(s) - not hard, but time-consuming and low priority
	- Improve the drop shadows on the item card elements, they fugly

-- ===================================================================--]]
--      DEPENDENCIES
-- =======================================================================
assert(dotmarks_main, "\n\n"..
	"! ui_hud_dotmarks requires script dotmarks_main, which does not exist or failed to load!\n\n"
)
assert(dotmarks_mcm, "\n\n"..
	"! ui_hud_dotmarks requires script dotmarks_mcm, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_common and utils_catspaw_common.import_metatable, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_common, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_hudmarks, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_hudmarks, which does not exist or failed to load!\n\n"
)
assert(utils_catspaw_text and utils_catspaw_text.bindtext, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_text, which is missing or outdated!\n" ..
	"Version found: " .. (utils_catspaw_text and utils_catspaw_text.script_version or "missing!") .. " | Required: 1.4+\n" ..
	"If the version is outdated, try moving this addon to the bottom of your load order."
)
assert(utils_catspaw_mapspots, "\n\n"..
	"! ui_hud_dotmarks requires script utils_catspaw_mapspots, which does not exist or failed to load!\n\n"
)
utils_catspaw_common.import_metatable(this, dotmarks_main)
-- =======================================================================
local dl, vl, xml
logprefix   = "[DotMarks] "
debuglogs   = false
verbose     = false
debug_dump  = false

function allow_local_logging(onoff)
	-- By default, logging in this script inherits its debuglogs/verbose settings from utils_catspaw_common
	-- This function allows anyone to temporarily switch on debug logging for this script's operations only
	if onoff then
		dl = function(logtext, ...) dlog(this, logtext, ...) end
		vl = function(logtext, ...) vlog(this, logtext, ...) end
	else
		dl = function(logtext, ...) dlog(nil, logtext, ...) end
		vl = function(logtext, ...) vlog(nil, logtext, ...) end
	end
end
allow_local_logging(true)

local function dump(logtext, ...)
	return debug_dump and logtext and printf(logprefix .. logtext, ...)
end

local function alert(logtext, ...)
	if not logtext then return end
	printf("! " .. logprefix .. logtext, ...)
end

function set_debug_logging(debug_en, verbose_en, dump_en)
	if (debug_en ~= nil) then debuglogs = debug_en end
	if (verbose_en ~= nil) then verbose = verbose_en end
	if (dump_en ~= nil) then debug_dump = dump_en end
end

--set_debug_logging(true, true, true) --uncomment this line to enable all logging for troubleshooting

-- First two values will be overridden by MCM once the game loads
-- debug_dump is EXTREMELY noisy and should only ever be manually enabled for a specific reason

-- ======================================================================
--      SHORTCUTS
-- ======================================================================
local get_mcm           = get_mcm_or_default_val
local nameid            = obj_name_and_id
local get_argb          = utils_catspaw_mapspots.get_argb
local is_already_target = utils_catspaw_hudmarks.is_object_already_targeted
local get_task_target   = utils_catspaw_taskmonitor and utils_catspaw_taskmonitor.get_active_target_id or function() end
local tuthooks          = modxml_tutorial_hooks
local is_favorite       = zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.is_favorite
local is_junk           = zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.is_junk
local fdda_pickup       = z_fdda_pickup_intercept_dotmarks
local fddar_bodysearch  = liz_fdda_redone_body_search
local gts               = game.translate_string
-- ======================================================================
valid_mcm_version       = dotmarks_mcm.valid_mcm_version
targeted_id, locked_id  = nil
scanning                = false
pickup_index            = {}
nearby_pickups          = {}
active_anims            = {}
-- ======================================================================
local st_kg             = gts("st_kg")
local fdda_installed    = false
local fddar_installed   = false
local anims_enabled     = false
local anim_playing      = false
local actor_moved       = false
local maingameui        = nil
local hmm               = nil
local popin_active      = nil
local use_dik           = nil
local fdda_callback     = nil
local hintfilters       = nil
local fallback_font     = 2
local next_skill_upd    = 0
local next_near_scan    = 0
local next_early_scan   = 0
local next_tut_check    = 0

-- ======================================================================
--      HUD MARKER PRESET PATCH
--  Set up "dotmark" preset and patch it into utils_catspaw_hudmarks
-- ======================================================================
utils_catspaw_hudmarks.marker_presets["dotmark"] = (
	function(args)
		--[[    This defines all the "default" values for any marker instantiated as
				a "dotmark" preset by utils_catspaw_hudmarks      --]]
		local id    = args and args.id
		local preset_args = {
			-- ================================================================================
			--  Presets that need to be generated on-marker-create rather than static LTX defs
			-- ================================================================================
			id                  = id,
			far_fade_dist       = near_scan_radius() - 1,
			far_hide_dist       = 1,
			far_end_dist        = early_scan_radius() + 5,
			scale_dist_min      = (near_scan_radius() or 4) - 1.5,
			scale_dist_mid      = (near_scan_radius() or 4) - 0.5,
			scale_dist_max      = (near_scan_radius() or 4),
			los_check_int       = (not cfg.ignore_los) and 250 or nil, -- interval in ms to check LOS to marker object
			los_check_range     = early_scan_radius() + 1,
			custom_argb         = dup_table(cfg.colors.clr_dmark_norm),
			marker_scale        = cfg.dot_marker_size,
			func_anim_take_curve= easing.InSine, -- easing function used for item take animation

			coord_args = { -- zero out all default screen coordinate adjustments
				near_adj = 0, 
				far_adj = 0,
				base_y  = 0,
			},
			-- ================================================================================
			func_on_update = (
			-- ================================================================================
			--      MAIN UPDATE LOOP FOR DOT MARKER OBJECTS
			-- ================================================================================
			--  Called from utils_catspaw_hudmarks at the start of every marker update
			--  Determines prompt and marker visibility for most objects
			--  Updates condition/ammo and other metadata that are visible on prompts
			-- ================================================================================

				function(mark, args)
					if not mark then return end -- literally impossible
					if mark.no_update_loop then return end
					if cfg.killswitch_markloop then
						mark:HideAll("killswitch_markloop")
						return
					end
					local now           = time_global()
					local id            = mark.id
					local obj           = id and get_game_object(id)
					if not obj then return end

					local show_pri      = true
					if mark.is_stalker and mark.is_alive then
						local alive = obj:alive()
						if not alive then
							handle_npc_death(obj)
							return
						end
						mark.is_wounded = xr_wounded.is_wounded(obj) or nil
						mark.is_enemy   = mark.comm and game_relations.is_factions_enemies(cfg.actor_comm, mark.comm)
						mark.is_mute    = not obj:is_talk_enabled()
						mark.hidden     = (mark.hidden and mark.is_mute) or (mark.is_enemy and not mark.is_wounded)
						--dump("%s is %s NPC | enemy %s | wounded %s was %s | mute %s", mark.name, mark.comm, mark.is_enemy, mark.is_wounded, mark.was_wounded, mark.is_mute)
						if mark.is_wounded then
							if not (mark.was_wounded or cfg.heal_cooldown_active) then
								mark.was_wounded 	= true
								if mark.is_enemy then
									-- do nothing at this time, enemies with surrender dialog can talk
								else
									set_secondary_action(mark)
								end
							end
						elseif mark.was_wounded then
							end_mark_wounded_state(mark)
						end
						if mark.is_mute then
							show_pri = false
							if cfg.hide_mute_stalkers then
								hide_marker_and_prompts(mark.mark_id, "mute stalker")
								return
							end
						end
					end
					local dist          = mark.last_dist or 999
					local in_range      = is_in_range(id, dist, mark)
					local hide          = mark.hidden --(mark.hidden or (not in_range))
					local _             = (not hide) and dump("[DotMarks] [%s][%s] Visibility and UI checks for %s | dist %s", mark.id, now, mark.name or mark.tutorial or mark.text, dist)
					
					cfg.in_pickup_range[id] = mark.is_pickup and in_range and dist or nil

					if mark.is_arty and (not mark.in_container) and (not can_actor_see_artefact(obj)) then
						hide_marker_and_prompts(mark.mark_id, "artefact not visible")
						return
					end
					if mark.is_button and mark.use_pri and mark.use_pri.physbtn_active then
						if not mark.use_pri.physbtn_active() then
							hide_marker_and_prompts(mark.mark_id, "inactive button")
							return
						end
					end

					-- ================================================================================
					-- Check whether this marker is for a junk object
					local sec           = obj:section()
					if (not hide) and obj and zzz_rax_sortingplus_mcm and cfg.sp_hide_junk_items then
						hide = is_junk(sec)
					end

					-- ================================================================================
					-- Check whether any logic has shut off interaction prompts entirely
					local targeted      = is_current_target(id)
					local show_sec      = false
					show_pri            = show_pri and targeted and in_range
					if not (mark.item_class and is_object_scannable(mark.item_class)) then
						hide = true
					end
					--dump("prompt check: hide %s | hidden_show: %s | anim block: %s", hide, cfg.hidden_show_prompts, prompt_blocked_by_anim())
					if (hide and not cfg.hidden_show_prompts) or prompt_blocked_by_anim() then
						--dump("Hiding all prompts")
						_ = mark.use_pri and mark.use_pri:ShowPrompt(false)
						_ = mark.alt_interact and mark.alt_interact:ShowPrompt(false)
					else
						-- ================================================================================
						-- Check marker display conditions and whether animations are playing
						-- ================================================================================
						-- Check availability of primary interact prompt
						if mark.use_pri and mark.use_pri.init_done then
							dump("[DotMarks] Checking whether to show pri interact prompt for %s | targeted %s | in_range %s", mark.name, targeted, in_range)
							if not in_range then
								show_pri = false
							elseif mark.is_npc and (not mark.is_container) then
								local last_squad = mark.squad_id
								mark.squad_id = obj.group_id
								if mark.squad_id ~= last_squad then
									local squad = mark.squad_id and alife_object(mark.squad_id)
									mark.commander_id = squad and squad:commander_id()
								end
								if (not mark.is_alive) then
									local tracked = true
									local empty = is_empty_mutant_corpse(id)
									if empty then
										-- No need to show markers for empty mutant corpses
										vl("Mutant corpse is empty, destroying marker")
										destroy_marker(mark.mark_id, "empty mutant corpse")
										return
									elseif cfg.bodies_use_mpda_rules and item_milpda then
										-- Hide bodies that Milspec PDA won't show
										tracked = (ish_kill_tracker and ish_kill_tracker.tracked_kill and ish_kill_tracker.tracked_kill(id))
										if not tracked then
											hide = true
										end
									end
								end
							elseif mark.is_container and not mark.is_display then
								-- Update contents of inventory containers
								mark.body_claimed = is_body_claimed(id)
								local is_managed_stash = not not (mark.body_claimed or treasure_manager.caches[mark.id])
								local text = ""
								local num_items = 0
								if (not cfg.invboxes[id]) then
									cfg.invboxes[id] = {}
								end
								if not mark.body_claimed then
									if (not cfg.invboxes[id].items) then
										cfg.invboxes[id].items, num_items = get_inventory_table(obj, id)
										_ = debug_dump and vl("[%s] No inventory table for container %s, iterated and found %s items", time_global(), mark.name, num_items)
										if is_managed_stash and (num_items == 0) then
											-- treasure manager stashes return as empty until searched
											cfg.invboxes[id].items = nil
										else
											mark.has_items = num_items > 0
										end
									end
								end

								if cfg.show_stash_weight then
									if cfg.invboxes[id].items then
										if mark.has_items then
											mark.weight = axr_companions.get_inventory_weight(cfg.invboxes[id].items)
											local wc = mark.weight and get_actor_weight_class(mark.weight)
											local code  = wc and cfg.weight_colors[wc] or cfg.weight_colors[0]
											mark.use_pri.parse_text_colors = true
											text = string.format(" ($%s%.2f %s$clr_def)", code, mark.weight, st_kg)
										else
											text = " " .. gts("st_alti_empty")
										end
									elseif mark.body_claimed or (is_managed_stash and not cfg.invboxes[id].items) then
										text = " (" .. gts("st_unknown_contents") .. ")"
									else
										text = " " .. gts("st_alti_empty")
									end
									mark.use_pri:SetPrompt(nil, nil, text)
								end
							end
							-- Passed NPC and container checks
							if in_range then
								if mark.is_campfire then
									show_pri = cfg.active_campfire and (cfg.active_campfire == mark.id)
								elseif mark.is_pickup then
									--if mark.is_glowstick and can_interact_physpickup(obj, id, dist) then
									if mark.physics_obj and can_interact_physpickup(obj, id, dist) then
										if (not cfg.available_pickup) then
											cfg.available_pickup = id
										end
										if not pickup_index[id] then
											local i = (#nearby_pickups or 0) + 1
											pickup_index[id] = i
											nearby_pickups[i] = id
										end
									end
									-- Mark is an item pickup
									if cfg.show_item_card then
										mark.use_pri:UpdateWeightColor()
									end
								elseif (not show_pri) then
									local available_pickup = mark.is_pickup and cfg.available_pickup and (mark.id == cfg.available_pickup)
									local not_hidden_by_anim = (cfg.show_prompt_during_anim or not anim_playing)
									-- If nothing else has allowed visibility yet, final checks
									show_pri = (
										(locked_id and targeted) or
										(available_pickup and not locked_id) or
										((not mark.is_pickup) and (targeted)) and
										(dist < 5) and (not mark.is_mute) and
										not_hidden_by_anim
									)
								end
								if mark.show_condition then
									-- Update condition for degradable objects
									local cond = obj:condition()
									if cond ~= mark.condition then
										mark.condition = cond
										mark.use_pri:SetConditionText(sec, cond)
										mark.use_pri:SetPrompt()
									end
								end
							end
							--dump("Final primary interact state: %s | %s", show_pri, nameid(mark.name, mark.id))
							if mark.use_pri then
								mark.use_pri:ShowPrompt(show_pri)
							end
							-- ================================================================================
							-- Check availability of secondary interact prompt
							if mark.alt_interact then
								show_sec = show_pri and not mark.body_claimed
								if show_sec then
									if cfg.hide_sec_interact_ui then
										show_sec        = false
										dump("Secondary interactions disabled via config, hiding UI for %s", mark.name)
									else
										if mark.ammo_count and (mark.ammo_count == 0) then
											show_sec    = false
										elseif mark.has_battery and mark.condition and (mark.condition < 0.01) then
											show_sec    = false
										elseif mark.is_container then
											show_sec    = show_pri and mark.has_items
										elseif mark.was_wounded then
											show_sec 	= show_pri and validate_wounded_prompt(mark)
										end
										dump("[DotMarks] Checking whether to show alt interact prompt for %s | show_pri %s | targeted %s", mark.name, show_pri, targeted)
									end
								end
								if mark.alt_interact then
									mark.alt_interact:ShowPrompt(show_sec)
								end
							end
						end
					end
					_ = debug_dump and vl("[%s][%s] Done with both prompt checks:\n* show_pri %s | show_sec %s | hide %s | pri prompt %s", time_global(), mark.name, show_pri, show_sec, hide, (mark.use_pri ~= nil) and "exists")
					-- ================================================================================
					local texture = mark.texture or ""

					if (not hide) and (mark.use_pri and mark.active_swap) then
						mark:ActiveSwap(show_pri)
						texture = mark.texture
						mark.use_pri:SetupConnectingLine()

						if show_pri and can_start_popin_anim(mark) then
							init_active_marker_popin(mark)
						end
					end

					if (hide or cfg.hide_interaction_dots) then
						-- Clear texture for hidden marker
						texture = ""
					else
						mark.marker_scale = cfg.dot_marker_size
						mark:ScaleMarkerByDistance()
					end
					mark.marker:InitTexture(texture)
					log_marker_update_loop(mark)
				end
			),
			-- ================================================================================
			func_los_check = (
			-- ================================================================================
			--  Runs during the LOS check phase of every marker update
			--  Force LOS check to succeed if the marked object is the current interact target
			-- ================================================================================
				function(mark, args)
					if not (mark.is_pickup or mark.is_stalker or mark.container or mark.is_workshop) then return end
					local pri_shown = (mark and mark.use_pri and mark.use_pri.wnd and mark.use_pri.wnd:IsShown())
					if mark.is_pickup and not pri_shown then
						pri_shown = not not pickup_index[mark.id]
					end
					return pri_shown and true or nil
				end
			),
			-- ================================================================================
			func_on_destroy = (
			-- ================================================================================
			--  When any marker is destroyed, unregister that ID and clear its metadata
			-- ================================================================================
				function(mark)
					if not (mark and mark.id) then return end
					vl("Marker for %s destroyed, unregistering", mark.id)
					this.unregister_scanned_entity(mark.id) 
				end
			),
		}
		-- Most static values are loaded from the cfg.dotmark_preset table, thus loaded from the config file
		for k,v in pairs(cfg.dotmark_preset) do
			preset_args[k] = v
		end
		return preset_args
	end
)

-- ======================================================================
--      ACTIVE SWAP OF MARKER ATTRIBUTES
--  Monkeypatches utils_catspaw_hudmarks to add support for hotswapping
--  the marker texture and other parameters on the fly based on states
-- ======================================================================
function utils_catspaw_hudmarks.UIHUDMarker:ActiveSwap(state)
	--dump("[%s][UIHUDMarker:ActiveSwap] for %s: %s", time_global(), self.name or self.tutorial, state)
	if self.destroyed or not (self.active_swap or self.task_swap) then return end
	local is_task_target= match_squad_or_leader(self.args.id, cfg.active_task_target_id) and cfg.enable_icon_tasks
	local is_storyline  = utils_catspaw_taskmonitor and utils_catspaw_taskmonitor.is_task_storyline()
	local last_swap     = self.task_swap or self.active_swap
	self.task_swap      = is_task_target and (is_storyline and cfg.swap_task_pri or cfg.swap_task_sec) or nil
	if state == nil then state = is_current_target(self.id) end
	local _
	if state then
		for k,v in pairs(self.task_swap or self.active_swap) do
			if (popin_active ~= self.mark_id) then
				_ = debug_dump and vl("[%s][%s][Swap on] Setting: %s = %s", time_global(), self.name, k, v)
				self[k] = v
				if self.use_pri then
					self.use_pri.args[k] = v
				end
			end
		end
	else
		for k,v in pairs(last_swap or self.active_swap) do
			self.popin_done = false
			self[k] = self.args[k]
			if self.use_pri then
				self.use_pri.args[k] = self.args[k]
			end
			_ = debug_dump and vl("[%s][%s][Swap off] Reverting: %s = %s", time_global(), self.name, k, self.args[k])
		end

	end
	self.base_w = self.width
	self.base_h = self.height
	
	if self.is_active ~= state then
		vl("[%s][%s] Mark active status changed to %s (was %s)", time_global(), self.name, state, self.is_active)
		self.last_active_state = self.is_active
		self.is_active = state
		self.next_update = 0
	end
end

-- ======================================================================


function uiscale(i)
	return (i or 0) * (cfg.ui_scale or 1)
end

function get_font(num)
	return fonts[tonumber(num) or cfg.font_main_prompt or fallback_font]
end

function get_font_obj(num)
	local font = get_font(num)
	return font and font.font
end

function get_font_xoff(num)
	local font = get_font(num)
	return font and tonumber(font.xoff) or 0
end

function get_font_width(num)
	local font = get_font(num)
	return font and tonumber(font.width or font.size) or 16
end

function get_font_height(num)
	local font = get_font(num)
	return font and tonumber(font.height or font.width or font.size) or 16
end

function get_font_scale_w(num)
	local scale = get_font_width(num) / 16
	return scale
end

function get_font_scale_h(num)
	local scale = get_font_height(num) / 16
	return scale
end

function fontscale_w(i)
	return i * get_font_scale_w(num)
end

function fontscale_h(i)
	return i * get_font_scale_h(num)
end

function setwndpos(element, x, y)
	if not element then return end
	element:SetWndPos(vector2():set(
		uiscale(x or 0),
		uiscale(y or 0)
	))
end

function setwndsize(element, w, h)
	if not element then return end
	element:SetWndSize(vector2():set(
		uiscale(w or 0),
		uiscale(h or 0)
	))
end

function get_interact_distance(id, mark)
	if not mark then mark = (id and cfg.markers[id]) end
	return mark and mark.interact_dist or cfg.obj_interact_dist or 2.5
end

function is_in_range(id, dist, mark)
	mark = mark or (id and cfg.markers[id])
	if not mark then
		local obj = id and get_game_object(id)
		if not (obj and db.actor) then return end
		dist = db.actor:position():distance_to(obj:position())
	end
	dist = dist or (mark and mark.last_dist) or 999
	return dist <= get_interact_distance(nil, mark)
end

function get_ied_mode(id, active_check)
	local data = id and txr_mines._mines[id]
	local mode = data and data.mode
	if active_check and mode then
		mode = data.active and mode or nil
	end
	return mode
end

function get_remaining_ied_time(id)
	local data = id and txr_mines._mines[id]
	local mode = data and data.mode
	if (mode == cfg.mine_modes.MODE_TIMER) then
		local now = get_time_elapsed()
		local left = data.exp_time - now
		return left, mode
	end
	return nil, mode
end

function game_seconds(gametime)
	return gametime and (gametime > 0)  and (gametime / level.get_time_factor())
end

function is_still_wounded(mark, args)
	return mark and mark.is_wounded
end

function validate_wounded_prompt(mark, args)
	if not mark then return end
	if not cfg.healing_stalker then
		if mark.is_wounded then
			return not not mark.alt_interact.avail_aid
		elseif mark.was_wounded then
			end_mark_wounded_state(mark)
		end
	end
end

function ied_anim_cycle_func(state, mark)
	-- none of this currently works properly
	if not mark then return end
	local id = mark.id
	local data = id and txr_mines._mines[id]
	local mode = data and data.mode
	local now = get_time_elapsed()
	local boom = data and data.exp_time
	local left = boom and (boom - now)
	local secs = game_seconds(left)
	local cycle = 1
	local dgr = (txr_mines.TRIGGER_RADIUS or 2.5) + 2.5
	local tooclose = mark.last_dist and mark.last_dist < dgr
	local anim = active_anims[mark.mark_id].ied
	if (mode == 0) then
		local dist = clamp(mark.last_dist or 10, 5, 10)
		local max = 10
		local warn = lerp(2.5, 10, dist)
		anim.cycle_dur = 1000 - (warn * 850)
	elseif (mode == 1) then
		if secs < 10 then
			if (secs < 5) then
				cycle = (state % 0.25)
			elseif (state < 0.4) then
				cycle = (state % 0.2)
			else
			end
		end
	end

	eased = easing.easeOutElastic(cycle)
	--("[%s] ied_anim_cycle_func: state %s | cycle %s | eased %s", time_global(), state, cycle, eased)
	return eased
end

function do_marker_anim_cycle(
		mark_id,
		w_start, h_start, w_end, h_end, duration,
		anim_func, on_finish_func, abort_func
	)
	if not mark_id then return end
	local anim_state 	= 0
	local anim_id 		= mark_id .. "_popin"
	local mark      	= hmm:GetMarker(mark_id)
	if not mark then return end

	if not active_anims[mark_id] then
		active_anims[mark_id] = {}
	end

	local start_time= time_global()
	local end_time  = time_global() + duration

	anim_func = anim_func or function(x) return x end
	active_anims[mark_id].ied = {
		mark_id     = mark_id,
		anim_id     = anim_id,
		active      = true,
		cycle_dur 	= duration,
		w_start     = function(mark) return mark and mark.is_active and mark.args.width or w_start or 0 end,
		w_end       = function(mark) return mark and mark.is_active and mark.active_swap.width or mark.args.width or w_end or 0 end,
		h_start     = function(mark) return mark and mark.is_active and mark.args.height or h_start or 0 end,
		h_end       = function(mark) return mark and mark.is_active and mark.active_swap.height or mark.args.height or h_end or 0 end,
	}
	
	
	CreateTimeEvent("animate_ied_"..mark_id, time_global(), 0, 
		function()
			local now = time_global()
			if abort_func and abort_func() then
				anim_state = -1
			else
				local anim = active_anims[mark_id].ied
				local mark = hmm:GetMarker(mark_id)
				if not mark then
					anim_state = -1
				elseif anim and anim.active then
					if now > end_time then
						anim_state = 1
						start_time = now
						end_time = now + anim.cycle_dur
					end

					local x = anim_func(anim_state, mark) or 1
					anim.w = lerp(anim.w_start(mark), anim.w_end(mark), x)
					anim.h = lerp(anim.h_start(mark), anim.h_end(mark), x)
					mark.base_w = anim.w or anim.w_end(mark)
					mark.base_h = anim.h or anim.h_end(mark)
					set_adjusted_marker_size(mark_id)
				else
					anim_state = -1
				end
			end

			if (anim_state == -1) then
				if on_finish_func then on_finish_func() end
				active_anims[mark_id].ied = nil
				return true
			end
			anim_state = math.min(1, normalize(time_global(), start_time, end_time))
		end
	)
end

function init_ied_mark_anim(mark)
	if not cfg.anim_ied_hazard then return end
	if not mark then return end
	local id = mark.id
	local mode = get_ied_mode(id, true)
	if not mode then return end

	do_marker_anim_cycle(
		mark.mark_id,
		mark.args.width * 0.5, mark.args.height * 0.5,
		mark.args.width, mark.args.height,
		1000,
		ied_anim_cycle_func,
		nil,
		nil
	)
end

function get_ied_text()
	if cfg.mine_mode < 0 then return end
	local timer = (cfg.mine_mode == 1) and (cfg.bomb_timer or 30) or ""
	local iedstr = "ui_mcm_lst_dmarks_iedmode_"..tostring(cfg.mine_mode)
	local iedtext = gts(iedstr)
	if (cfg.mine_mode == 1) then
		iedtext = string.format(iedtext, timer)
	end
	
	dump("get_ied_text: mode %s | timer %s | str %s | text %s", cfg.mine_mode, timer, iedstr, iedtext)
	return iedtext
end

function IsWounded(obj)
	local var = load_var(obj, "wounded_state")
	return var and (var ~= "") and (var ~= "nil")
end

function end_mark_wounded_state(mark)
	vl("end_mark_wounded_state for %s", mark and mark.name)
	if not (mark and mark.is_stalker and mark.alt_interact) then return end
	mark.is_wounded = nil
	mark.was_wounded = nil
	cfg.healing_stalker = nil
	mark.checked_for_sec = nil
	if mark.alt_interact then
		mark.alt_interact:Destroy("NPC is no longer wounded")
	end
	cfg.heal_cooldown_active = true
	CreateTimeEvent("dmark_heal_cooldown", 0, 2, (
		function()
			cfg.heal_cooldown_active = false
			return true
		end
	))
end

function log_marker_update_loop(mark)
	mark.loop_num = mark.loop_num and (mark.loop_num + 1) or 0
	local _ = debug_dump and vl("[DotMarks] [%s][%s] End of main update loop %s | Final size: [%s x %s]", time_global(), mark.name, mark.loop_num, dec2(mark.width), dec2(mark.height))
end

function hide_marker_and_prompts(mark_id, reason)
	local mark = mark_id and hmm:GetMarker(mark_id)
	if not mark then return end
	if mark.use_pri then
		mark.use_pri:ShowPrompt(false)
	end
	if mark.alt_interact then
		mark.alt_interact:ShowPrompt(false)
	end
	mark.marker:InitTexture("")
	mark:HideAll(reason or "hide_marker_and_prompts called")

end

function destroy_marker(mark_id, reason)
	local _ = debug_dump and dl("Trying to destroy marker %s%s", mark_id, reason and (" | "..reason) or "")
	local mark = hmm:GetMarker(mark_id)
	if mark then mark:Destroy(nil, reason) end
end

function destroy_prompt(tid, reason)
	local _ = debug_dump and dl("Trying to destroy tutorial prompt %s%s", tid, reason and (" | "..reason) or "")
	local mark = tid and cfg.markers[tid]
	if mark then
		mark:Destroy(nil, reason)
		cfg.markers[tid] = nil
	end
end

function killswitch(feature)
	local ks = false
	if feature then
		feature = ("killswitch_" .. feature)
		ks = cfg[feature] or cfg.killswitch_all
	else
		ks = cfg.killswitch_all
	end
	return ks
end

function shut_down()
	scanning = false
	cfg.killswitch_all = true
	set_handler_callbacks(true)
	for k,v in pairs(cfg.markers) do
		if v.mark_id then
			destroy_marker(v.mark_id)
		else
			v:Destroy("shutting down")
		end
	end
end

function get_fddar_current_action()
	return lam2 and lam2.get_current_action()
end

function fddar_update_current_anim_state()
	anim_playing = lam2 and lam2.is_running()
end

function get_fdda_callback()
	fdda_callback = fdda_pickup and fdda_pickup.get_fdda_oibp_callback() or nil
	return fdda_callback
end

function fdda_handles_pickups()
	return get_fdda_callback() and (cfg.fdda_pickup_anim or cfg.fddar_pickup_anim)
end

function item_pickup_intercept(obj, flags)
	if killswitch("pickup") then return obj end
	-- Called directly by actor_on_item_before_pickup if neither FDDA nor FDDAR are installed
	-- Called by my monkeypatch of FDDA/FDDAR's pickup if they are
	local now = time_global()
	if flags.force then
		-- Skip all long-press checks
	else
		if (cfg.held_key == use_dik) then
			flags.ret_value = false
			return
		elseif cfg.watch_use then
			if (time_global() - (cfg.use_released or 0)) < (cfg.long_press_delay or 50) then
				flags.ret_value = false
				return
			end
		end
	end

	vl("[%s][ret_val: %s][item_pickup_intercept] Actor tried to take item %s", now, flags.ret_value, nameid(obj))

	local curr_target, taken_obj
	curr_target = get_current_target()
	taken_obj = curr_target and get_game_object(curr_target)
	
	if taken_obj then
		dl("[%s][item_pickup_intercept] Actor will take item %s", now, nameid(taken_obj))
		local handle_take = flags.skip_anim or not fdda_callback
		if flags.ret_value then
			flags.ret_value = false
			local mark = cfg.markers[curr_target]
			if handle_take and not (mark and mark.physics_obj) then
				vl("flags.ret_value is %s, DotMarks will handle pickup %s", flags.ret_value, nameid(taken_obj))
				db.actor:take_item(taken_obj)
				return
			end
			if mark then
				mark:HideAll("dotmarks taking item")
			end
			fake_take_anim(mark)
			return
		end
	end
	return taken_obj
end

function set_adjusted_marker_size(mark_id)
	local mark = hmm:GetMarker(mark_id)
	if not mark then return end
	mark.width = mark.base_w
	mark.height = mark.base_h
	--dump("[%s] set_adjusted_marker_size for %s: %s,%s", time_global(), mark.name, mark.width, mark.height)
	if mark.use_pri then
		mark.use_pri:UpdateMainWndPos(mark)
	end
	if mark.alt_interact then
		mark.alt_interact:UpdateMainWndPos(mark)
	end
end

function do_marker_popin(
		mark_id,
		w_start, h_start, w_end, h_end, duration,
		easing_func, on_finish_func, abort_func
	)
	if not mark_id then return end

	local anim_state = 0

	local anim_id = mark_id .. "_popin"

	if not active_anims[mark_id] then
		active_anims[mark_id] = {}
	end
	if active_anims[mark_id].popin then
		popin_active = nil
	end
	popin_active = mark_id

	local mark      = hmm:GetMarker(mark_id)
	if not mark then return end

	local start_time= time_global()
	local end_time  = time_global() + duration

	easing_func = easing_func or function(x) return x end
	active_anims[mark_id].popin = {
		mark_id     = mark_id,
		anim_id     = anim_id,
		start_time  = start_time,
		end_time    = end_time,
		active      = true,
		w_start     = function(mark) return mark and mark.is_active and mark.args.width or w_start or 0 end,
		w_end       = function(mark) return mark and mark.is_active and mark.active_swap.width or mark.args.width or w_end or 0 end,
		h_start     = function(mark) return mark and mark.is_active and mark.args.height or h_start or 0 end,
		h_end       = function(mark) return mark and mark.is_active and mark.active_swap.height or mark.args.height or h_end or 0 end,
	}
	
	
	CreateTimeEvent("animate_popin_"..mark_id, time_global(), 0, 
		function()
			local abort = abort_func and abort_func()
			if abort then
				anim_state = 1
			elseif start_time - end_time > 5000 then
				-- Timeout to catch orphaned timeevents
				anim_state = 1
			else
				local anim = active_anims[mark_id].popin
				local mark = hmm:GetMarker(mark_id)
				if not (mark and mark.is_shown) then
					anim_state = 1
				elseif mark and anim and anim.active then
					if mark.is_active then
						local x = easing_func(anim_state)
						anim.w = lerp(anim.w_start(mark), anim.w_end(mark), x)
						anim.h = lerp(anim.h_start(mark), anim.h_end(mark), x)
					else
						anim_state = 1
					end
					mark.base_w = anim.w or anim.w_end(mark)
					mark.base_h = anim.h or anim.h_end(mark)
					set_adjusted_marker_size(mark_id)
				else
					anim_state = 1
				end
			end

			if (anim_state == 1) then
				if on_finish_func then on_finish_func() end
				active_anims[mark_id].popin = nil
				popin_active = nil
				return true
			end
			anim_state = math.min(1, normalize(time_global(), start_time, end_time))
		end
	)
end

function init_active_marker_popin(mark)
	if type(mark) == "string" then
		-- Assume a mark_id got passed instead of the mark itself
		mark = hmm:GetMarker(mark)
	end
	if not (mark and mark.mark_id) then return end

	do_marker_popin(
		mark.mark_id,
		mark.args.width * 0.5, mark.args.height * 0.5,
		mark.active_swap.width, mark.active_swap.height,
		cfg.popin_anim_dur,
		easing.easeOutElastic,
		(function()
			mark.next_update = 0
			mark.popin_done = true
			popin_active = nil
		end),
		(function() 
			return  (not popin_active) or
					(not mark.texture) or
					(popin_active ~= mark.mark_id) or
					(mark.texture ~= mark.active_swap.texture)
		end)
	)
end

function can_start_popin_anim(mark)
	return cfg.popin_anim_dur and (cfg.popin_anim_dur > 0) and not (popin_active or mark.popin_done)
end

function match_squad_or_leader(id, comp_id)
	if (id == comp_id) then return true end
	local se_obj    = comp_id and alife_object(comp_id)
	local cls       = se_obj and se_obj:clsid()
	local is_squad  = cls and (cls == clsid.online_offline_group_s) or (cls == clsid.online_offline_group)
	if is_squad then
		-- If the comparison ID is a squad object and didn't match directly, compare to its commander_id
		local leader_id = se_obj:commander_id()
		return (id == leader_id)
	end
end

function can_actor_see_artefact(obj)
	local arty  = obj and obj:cast_Artefact()
	local vstate= arty and arty.getVisible and arty:getVisible() or 0
	local _ = debug_dump and vl("can_actor_see_artefact for %s: %s", nameid(obj), (vstate == 1) and true or false)
	return (vstate == 1) and true or false
end

function get_bones_for_obj(obj)
	local bones = obj and obj.list_bones and obj:list_bones()
	return bones
end

local ini_parts = itms_manager.ini_parts
function has_parts(obj)
	if not obj then return end
	local sec = SYS_GetParam(0, obj:section(), "parent_section") or obj:section()
	local parts = ini_parts:r_string_ex("con_parts_list", sec)
	return parts ~= nil
end

function is_door_open(obj, id)
	id = id or (obj and obj:id())
	obj = obj or (id and get_game_object(id))
	if not id then return end
	local door = id and db.storage[id]["ph_door"] and db.storage[id]["ph_door"].door_action
	local is_open = door:is_open()
end

function is_vanilla_ui_hidden()
	return (cfg.hide_van_interact_ui and not cfg.hide_pri_interact_ui)
end

function trimmed_prompt(txt)
	local pos = txt and txt:find("%(")
	return pos and txt:sub(1, pos - 2) or txt or ""
end

function interact_vert_offset(ui_interact)
	local args = ui_interact and ui_interact.args
	return args and (not args.pri) and (not cfg.hide_pri_interact_ui) and cfg.sec_use_y_offset or cfg.pri_use_y_offset
end

function lerp_color(val, mi, md, mx)
	-- like in utils_xml, except returning a table I can do something with instead of ARGB
	local m1,m2
	if (val >= mi[5]) and (val < md[5]) then
		m1 = mi
		m2 = md
	elseif (val >= md[5]) and (val <= mx[5]) then
		m1 = md
		m2 = mx
	end
	if not (m1 and m2) then
		return clr_tbl(255,255,255,255)
	end
	
	local t = {}
	for i=1,4 do
		if m1[i] == m2[i] then
			t[i] = m1[i]
		else
			t[i] = math.floor( m1[i] + ((m2[i] - m1[i]) * normalize(val, m1[5], m2[5])) )
		end
	end
	return clr_tbl(t[1], t[2], t[3], t[4])
end

function is_already_target(id)
	local is_pickup = hmm and hmm.current_pickup and (id == hmm.current_pickup)
	if is_pickup then return true end
	local is_target = hmm and hmm.current_target and (id == hmm.current_target)
	if is_target then return true end
	local is_xhair  = hmm and hmm.current_pickup and (id == hmm.current_crosshair)
	if is_xhair then return true end
end

function get_condition_color(condition, section)
	if not condition then return end
	local args      = {}
	local c         = cfg.colors
	local mode      = 0
	local crit_pwr  = section and item_device.dev_critical[section]
	if crit_pwr then
		mode        = 2
		args.crit   = crit_pwr
	elseif cfg.parts_wpo_colors then
		mode        = 1
	else
		condition   = clamp(condition / 99, 0, 1)
	end
	return get_state_color(condition, mode, args)
end

function timed_out(stamp, interval)
	if not (stamp and interval) then return end
	return (time_global() - stamp) >= interval
end

--[[======================================================================
	UIStaticQuickHelp management
	Most of the logic is in dotmarks_main.cfg.hint_filter

	on_quickhelp_text_update(raw_text, loc_string, trimmed_text, flags)
		Params: (<string>, <string>, <string>, <table>)

		raw_text:
			the raw text content of the UIStaticQuickHelp textwnd
		loc_string:
			the localization string of the text
		trimmed_text:
			the text with the "use key" prompt trimmed off
		
	flags is an empty table, set flags.text to any string to replace text
	
	cfg.hide_van_interact_ui will override showing any such text changes
-- =====================================================================]]

AddScriptCallback("on_quickhelp_text_update")

function get_quickhelp_text()
	local text = maingameui and maingameui.UIStaticQuickHelp and maingameui.UIStaticQuickHelp:GetText()
	return text and (text ~= "") and (text ~= " ") and text or nil
end

function set_quickhelp_text(text)
	if not maingameui and maingameui.UIStaticQuickHelp then return end
	maingameui.UIStaticQuickHelp:SetText(text or "")
end

--[[======================================================================
	Custom interaction prompt
	Review at some point post-release for unused args/code
-- =====================================================================]]

class "InteractPrompt" (CUIScriptWnd)
-- =======================================================================
function InteractPrompt:__init(anchor, args) super()
	vl("InteractPrompt:__init | event %s | name %s | tutorial %s", args and args.event, args and args.name, args and args.tutorial)
	self:SetAutoDelete(true)
	self.elements = {
		["wnd"]         = true,
		["drop"] 		= true,
		["prompt"]      = false,
		["prompt_l"]    = false,
		["prompt_c"]    = false,
		["prompt_r"]    = false,
		["bind"]        = true,
		["bind_sh"]     = true,
		["label"]       = true,
		["label_sh"]    = true,
		["line"]        = false,
		["longpress"]   = false,
	}   -- bool is whether to scale alpha
	self.xml    = CScriptXmlInit()
	self.uid    = "dotmarks_" .. args.event
	self:ParseArgs(args)
	-- ===================================================================
	--	Setup special handlers and hint filters
	-- ===================================================================
	self.anchor 	= self.args.fixed and maingameui or anchor or maingameui
	if self.args.fixed then
		local x,y   = get_fixed_screen_pos()
		self.args.locked_screen_pos = vector2():set(x, y)
	end
	if self.args.scheme then
		if self.args.is_button then
			self:SetupButtonHandlers()
		elseif self.args.scheme == "ph_door" then
			self:SetupDoorHandlers()
		end
	end
	if self.args.tutorial then
		if (self.args.tutorial:find("campfire")) then
			self.campfire_tut   = true
		elseif (self.args.tutorial == "tutorial_sleep") then
			self.sleep_tut = true
		end
	end	
	self:SetupHintFilters()
	-- ===================================================================
	-- 	Setup text and prompts, finish init
	-- ===================================================================
	local color             = cfg.colors
	local csv2clr           = csv_argb_to_tbl
	self.text_color_default = clr_tbl(255, 255, 255, 255)
	self.text_hidden        = clr_tbl(0, 0, 0, 0)
	self.text_color_busy    = csv2clr(args.argb_busy)   or color.clr_text_busy  or self.text_color_default
	self.text_color_light   = csv2clr(args.argb_light)  or color.clr_text_light or self.text_color_default
	self.text_color_dark    = csv2clr(args.argb_dark)   or color.clr_text_dark  or self.text_color_default
	self.progress_color     = csv2clr(args.argb_prog)   or color.clr_key_hold or csv_argb_to_tbl({255,255,215,0})
	self.active_prefix      = args.active_prefix or args.act    or ""
	self.active_prompt      = args.active_prompt or args.text   or (args.tutorial and trimmed_prompt(gts(args.tutorial))) or ""
	self.active_suffix      = args.active_suffix or args.suffix or ""
	self.last_state         = false
	self:on_option_change()
	self:BusyState(false)
	self:ShowPrompt(args.begin_active, "init")
	-- ===================================================================
	RegisterScriptCallback("actor_on_net_destroy", self)
	RegisterScriptCallback("on_option_change", self)
	RegisterScriptCallback("actor_on_update", self)
	vl("[%s][InteractPrompt] Completed setup for prompt: %s", self.init_done, self:GetFullPrompt())
end
-- =======================================================================

function InteractPrompt:CycleBombMode(bind)
	if self.disabled or (not self.args.iedtext) then return end
	local max = cfg.rce_installed and 2 or 1
	if bind == cfg.bind_fmnext then
		cfg.mine_mode = cfg.mine_mode + 1
		if cfg.mine_mode > max then cfg.mine_mode = 0 end
	else
		cfg.mine_mode = cfg.mine_mode - 1
		if cfg.mine_mode < 0 then cfg.mine_mode = max end
	end
	play_snd_path(cfg.snd_path_blip)
	self.active_prompt = self.args.iedtext .. " " .. get_ied_text()
	self:SetPrompt()
end

function InteractPrompt:SetBombTimer(direction)
	if self.disabled or (not self.args.iedtext) then return end
	local min = cfg.bomb_timer_min or 10
	local max = cfg.bomb_timer_max or 120
	local inc = cfg.bomb_timer_inc or 5

	cfg.bomb_timer = (cfg.bomb_timer or 30) + (direction * inc)
	if cfg.bomb_timer > max then
		cfg.bomb_timer = min
	elseif cfg.bomb_timer < min then
		cfg.bomb_timer = max
	end
	play_snd_path(cfg.snd_path_blip)
	self.active_prompt = self.args.iedtext .. " " .. get_ied_text()
	self:SetPrompt()
end

function InteractPrompt:on_mouse_wheel(scroll_dir, flags)
	if not cfg.sec_use_mousewheel_timer then return end
	local id = targeted_deployable_bomb()
	if not id then return end
	local direction = (scroll_dir > 0) and 1 or -1
	self:SetBombTimer(direction)
	flags.ret_value = false
end

function InteractPrompt:on_before_key_press(key, bind, dis, flags)
	--dump("InteractPrompt:on_before_key_press | key %s | bind %s", key, bind)
	if self.args.iedmode then
		if cfg.sec_use_firemode_mines and ((bind == cfg.bind_fmprev) or (bind == cfg.bind_fmnext)) then
			local id = targeted_deployable_bomb()
			if not id then return end
			self:CycleBombMode(bind)
			flags.ret_value = false
		end
	elseif self.args.is_glowstick then
		if (bind == key_bindings.kUSE) then
			local obj = get_game_object(self.args.id)
			vl("Forcing actor to take glowstick")
			flags.ret_value = false
			item_pickup_intercept(obj, {force = true, ret_value = true, skip_anim = skip_anim})
			self:Destroy("actor took glowstick")
		end
	end
end

function InteractPrompt:ParseArgs(args)
	if debug_dump then
		dump("[InteractPrompt] Passed args:")
		for k,v in pairs(args) do dump("|| %s = %s", k, v) end
	end
	args        = args or {}
	args.func   = args.func or (function() end)
	args.event  = self:Event(args.event)
	args.key    = self:BindKey(args.key)
	args.mod    = self:ModKey(args.mod)
	args.mode   = self:InputMode(args.mode)
	args.bind   = args.bind or bindtext(key, mod)
	args.long   = args.long or (args.mode == 2)
	args.xoffset= args.xoffset or (args.pri and cfg.pri_use_x_offset or cfg.sec_use_x_offset) or 0
	args.yoffset= args.yoffset or (args.pri and cfg.pri_use_y_offset or cfg.sec_use_y_offset) or 0
	if (not args.no_sec_yscale) and (not args.pri) then
		local pxoff = cfg.pri_use_x_offset
		local pyoff = cfg.pri_use_y_offset
		local sxoff = cfg.sec_use_x_offset
		local syoff = cfg.sec_use_y_offset
		local ydiff = syoff - pyoff
		args.yoffset = args.yoffset - ydiff + fontscale_h(ydiff)
	end
	if args.iedmode then
		args.iedtext = args.text
		args.text = args.iedtext .. " " .. args.iedmode
	end
	args.act    = args.act or ""
	args.name   = args.name or ""
	args.fixed  = ((args.fixed ~= nil) and args.fixed) or cfg.fixed_screen_pos
	self.args   = args
end

function InteractPrompt:SetupButtonHandlers()
	vl("[%s] InteractPrompt:SetupButtonHandlers | scheme: %s", self.args.section, self.args.scheme)
	local method = "on_use"
	if (self.args.scheme == "ph_button") then
		method = "on_press"
	elseif (self.args.scheme == "ph_code") then
		method = "on_code"
	end
	self.physbtn_active = (
		function()
			local btn = self.args.id and self.args.scheme and db.storage[self.args.id][self.args.scheme]
			return btn and method and not not btn[method]
		end
	)
end

function InteractPrompt:SetupHintFilters(filters)
	filters = filters or self.args.hint_filters
	self.args.hint_filters = self.args.hint_filters or {}
	if (not filters) or (is_empty(filters)) then return end
	function add_hint_filter(m, r)
		hintfilters.add(m, r)
		self.args.hint_filters[m] = r
		self.filters[m] = function() return hintfilters.get_state(m) end
		self.prompts[m] = function() return self.filters[m]() and hintfilters.get_text(m) or nil end
	end

	self.filters = {}
	self.prompts = {}
	for k,v in pairs(filters) do
		add_hint_filter(k, v)
	end
	self.args.hint_filters = filters
	RegisterScriptCallback("on_quickhelp_text_update", self)
end

function InteractPrompt:GetMark()
	if self.args.mark_id then
		return hmm:GetMarker(self.args.mark_id)
	elseif (self.id or self.args.id) and cfg.markers[(self.id or self.args.id)] then
		return cfg.markers[self.args.id]
	end
end

function InteractPrompt:GetInvWeightDisplay(weight)
	local wc = weight and get_actor_weight_class(weight)
	local code  = wc and cfg.weight_colors[wc] or cfg.weight_colors[0]
	self.parse_text_colors = true
	return string.format(" ($%s%.2f %s$clr_def)", code, self.weight, st_kg)
end

function InteractPrompt:SetupDoorHandlers()
	vl("Setting up door handler object and methods")
	local args = self.args
	local ph_door = args.id and db.storage[args.id]["ph_door"]

	self.door = {
		data = ph_door,
		ctrl = ph_door.door_action
	}
	local door = self.door
	if not door.ctrl then return end

	door.lo, door.hi = door.ctrl.joint:get_limits(0, 0, 0)
	door.mid = (door.lo + door.hi) * 0.5
	door.deadzone = 0.1
	door.is_open = (
		function()
			return self.door.ctrl and self.door.ctrl.is_open and self.door.ctrl:is_open()
		end
	)
	door.tips = {
		close   = self.door.data and self.door.data.tip_close,
		open    = self.door.data and self.door.data.tip_open,
		unlock  = self.door.data and self.door.data.tip_unlock,
	}
	door.joint_pos = (
		function()
			return self.door.ctrl and
				self.door.ctrl.joint and
				self.door.ctrl.joint.get_axis_angle and
				self.door.ctrl.joint:get_axis_angle(0)
		end
	)
	door.tip = (
		function()
			local locked = self.door.data and self.door.data.locked
			local tips = self.door.tips
			local msg = locked and tips.unlock or self.door.is_open() and tips.close or tips.open
			return msg
		end
	)
	args.text = gts(self.door.tip())
	self.args.hint_filters = {}
	for k,v in pairs(door.tips) do self.args.hint_filters[v] = v end
end


function InteractPrompt:GetWndOffset()
	if self.args.locked_screen_pos then
		return self.args.locked_screen_pos.x, self.args.locked_screen_pos.y
	else
		return self.args.xoffset, self.args.yoffset
	end
end

function InteractPrompt:GetPosOffsets()
	local xoff, yoff = 0, 0
	if not self.args.locked_screen_pos then
		xoff, yoff = self:GetWndOffset()
	end
	return xoff, yoff
end

function InteractPrompt:SetLinePos(x, y)
	local xoff, yoff 	= self:GetPosOffsets()

	setwndpos(self.line,
		(x or 0) + 15 	+ (self.args.line_adj_x or 0),
		(y or 0) + -15	+ (self.args.line_adj_y or 0)
	)
end


function InteractPrompt:UpdateMainWndPos(mark)
	if self.args.locked_screen_pos then return end
	mark 			= mark or self:GetMark() or {}
	local arg_tbl 	= mark.is_active and mark.task_swap or mark.active_swap or mark.args or {}
	local adj_w 	= ((mark and mark.width or 6) - (arg_tbl.width or 6)) * 0.5
	local adj_h 	= ((mark and mark.height or 6) - (arg_tbl.height or 6)) * 0.5
	local x         = self.args.xoffset + adj_w
	local y         = self.args.yoffset + adj_h
	setwndpos(self.wnd, x, y)
end


function InteractPrompt:SetupConnectingLine()
	-- White line - really cheap trick but looks nice in certain positions
	if not self.line then
		self.line = self.xml:InitProgressBar("prog_dotpointer", self.wnd)
	end

	if self.args.pri then
		self:SetLinePos(
			(self.args.line_adj_x or 0) + -3.5,
			(self.args.line_adj_y or 0) + 3
		)
		setwndsize(self.line, 5 + (self.args.line_adj_w or 0), 26 + (self.args.line_adj_h or 0))
	else
		self.line:Show(false)
	end
end


function InteractPrompt:BuildUI()
	vl("InteractPrompt:BuildUI | %s", self.args.name or self.args.text or self.args.tutorial or self.args.event)
	if self.wnd then
		for k,_ in pairs(self.elements) do
			self[k] = nil
		end
	end

	local xml           = self.xml
	xml:ParseFile(cfg.interact_uifile)
	local args          = self.args
	local boxlen        = fontscale_w(#args.bind * cfg.bind_char_scale)
	local boxpos        = -(boxlen - 4)
	self.args.style     = cfg.keybind_bg_style or 0
	self.black_text     = (self.args.style > 1)
	local stretch_adj   = 0
	self.wnd            = xml:InitStatic("alt_interact", self.anchor)

	self.drop           = xml:InitStatic("box", self.wnd)
	setwndpos(self.drop,
		-boxlen + fontscale_w(cfg.interact_drop_x),
		fontscale_h(cfg.interact_drop_y)
	)
	self.drop:InitTexture(cfg.main_drop_texture)
	self:eleSetBaseColorScheme(self.drop, clr_tbl(clamp(cfg.interact_drop_alpha * 255, 0, 255), 255, 255, 255))
	--self.drop:SetTextureColor(get_argb(clamp(cfg.interact_drop_alpha * 255, 0, 255), 255, 255, 255))
	self:SetupConnectingLine()

	local one_char = (#args.bind == 1)

	if one_char then
		self.prompt     = xml:InitStatic("alt_interact:prompt", self.wnd)
		self.prompt:InitTexture("ui_catsy_keybind_bg_single_v" .. self.args.style)
		setwndsize(self.prompt, fontscale_w(15), fontscale_h(20))
	else
		self.prompt     = xml:InitStatic("box", self.wnd)
		
		self.prompt_l   = xml:InitStatic("alt_interact:prompt_l", self.prompt)
		self.prompt_c   = xml:InitStatic("alt_interact:prompt_c", self.prompt)
		self.prompt_r   = xml:InitStatic("alt_interact:prompt_r", self.prompt)
		self.prompt_l:InitTexture("ui_catsy_keybind_bg_left_v" .. args.style)
		self.prompt_c:InitTexture("ui_catsy_keybind_bg_center_v" .. args.style)
		self.prompt_r:InitTexture("ui_catsy_keybind_bg_right_v" .. args.style)

		stretch_adj     = 2
		setwndsize(self.prompt_l, fontscale_w(5.3125), fontscale_h(20))
		setwndpos(self.prompt_l, 0, 0)
		setwndsize(self.prompt_c, boxlen, fontscale_h(20))
		setwndpos(self.prompt_c, fontscale_w(5.1125), 0)
		setwndpos(self.prompt_r, fontscale_w(4.78) + boxlen, 0)
		setwndsize(self.prompt_r, fontscale_w(5.3125), fontscale_h(20))
	end
	setwndpos(self.prompt, boxpos or 0, 0)

	-- Set up long press progress indicator
	if args.long then
		self.longpress  = xml:InitProgressBar("prog_longpress", self.prompt)
		self.longpress:SetColor(getargb(self.progress_color))
		self.longpress:SetProgressPos(0)
	end

	-- Set up text drop shadows
	self.bind_sh        = xml:InitStatic("alt_interact:label", self.prompt)
	self.label_sh       = xml:InitStatic("alt_interact:label", self.wnd)
	setwndsize(self.bind_sh, (boxlen or 0) + fontscale_w(15), fontscale_h(20))
	setwndpos(self.bind_sh,
		get_font_xoff() + fontscale_w(stretch_adj + cfg.bind_text_pos_x + 1.5),
		fontscale_h(cfg.bind_text_pos_y - 0.25)
	)
	setwndpos(self.label_sh, 
		get_font_xoff() + fontscale_w(cfg.action_text_pos_x + 0.5),
		fontscale_h(cfg.action_text_pos_y)
	)
	self.bind_sh:TextControl():SetFont(get_font_obj())
	self.label_sh:TextControl():SetFont(get_font_obj())

	-- Keybind text indicator
	self.bind           = xml:InitStatic("alt_interact:label", self.prompt)
	self:eleSetBaseColorScheme(self.bind, self.black_text and self.text_color_dark or self.text_color_light)
	self.bind:TextControl():SetFont(get_font_obj())

	self:SetBindText(bindtext(self:BindKey(), self:ModKey()))

	setwndsize(self.bind, (boxlen or 0) + fontscale_w(15), fontscale_h(20))
	setwndpos(self.bind,
		get_font_xoff() + fontscale_w(stretch_adj + cfg.bind_text_pos_x + (one_char and 1.5 or 0)),
		fontscale_h(cfg.bind_text_pos_y)
	)

	-- Width reference static
	self.lref      = xml:InitStatic("box", self.wnd)
	self.lref:Show(false)

	-- Prompt text label
	self.label          = xml:InitStatic("alt_interact:label", self.wnd)
	self:eleSetBaseColorScheme(self.label, self.text_color_light)
	setwndpos(self.label, get_font_xoff() + fontscale_w(cfg.action_text_pos_x), fontscale_h(cfg.action_text_pos_y))
	self.label:TextControl():SetFont(get_font_obj())

	self:eleSetBaseColorScheme(self.bind_sh, self.text_color_dark)
	if self.black_text then
		self.bind_sh:Show(false)
	end
	self:eleSetBaseColorScheme(self.label_sh, self.text_color_dark)

	local obj = self.args.id and get_game_object(self.args.id)
	self:SetupSuffix(obj)
	self:SetPrompt()

	if obj and self.args.pri then
		self:SetupItemCard(self.wnd, obj)
		self:SetupUtjanPartDots(self.itemcard)
	end

	if self.args.locked_screen_pos then
		self.wnd:SetWndPos(self.args.locked_screen_pos)
	else
		self:UpdateMainWndPos()
	end

	vl("Completed %sbuilding interact UI: %s", self.init_done and "re" or "", self.active_prompt)
	self.init_done = self.init_done or time_global()
	self:actor_on_update()
end

function InteractPrompt:SetupSuffix(obj)
	obj             = obj or (self.args.id and get_game_object(self.args.id))
	if (not obj) then return end
	if not (cfg.show_item_condition or cfg.show_item_charge) then return end

	local sec       = self.args.section or obj:section()
	local cls       = self.args.clsid or obj:clsid()
	local has_cond  = (sec and cls) and (utils_item.is_degradable(nil, sec) or IsWeapon(nil, cls) or IsOutfit(nil, cls) or IsHeadgear(nil, cls))
	local is_mag    = magazine_binder and sec and magazine_binder.is_magazine(sec)
	local wpn_cnd 	= (self.args.is_weapon and cfg.show_gun_condition)
	local gear_cnd  = (self.args.has_parts and cfg.show_item_condition) and not self.args.is_weapon
	local part_cnd 	= (self.args.is_part_cnd and cfg.show_item_condition)
	local batt_cnd  = ((self.args.has_power or self.args.has_battery) and cfg.show_item_charge)
	if self.args.multi_uses then
		-- Setup suffix text for multiuse items
		if cfg.show_multi_uses and (self.args.multi_uses > 1) then
			self.active_suffix = string.format(" (%s %s)", self.args.multi_uses, gts("st_alti_uses"))
		else
			self.active_suffix = ""
		end
	elseif has_cond and (wpn_cnd or gear_cnd or batt_cnd or part_cnd) and (not is_mag) then
		-- Setup suffix text for degradable items
		local cond = obj and obj:condition()
		vl("%s show_condition | wpn %s | gear %s | batt %s | part %s", self.args.name, wpn_cnd, gear_cnd, batt_cnd, part_cnd)
		self.show_condition = true
		self:SetConditionText(sec, cond)
	else
		self.active_suffix = ""
	end
end


function InteractPrompt:SetConditionText(sec, cond)
	 if (cond and sec) then
		cond = math.floor(cond * 100)
		local c = get_condition_color(cond, sec)
		local key = "clr_" .. cond .. (self.args.has_power and "_batt" or "_cond")
		local str   = c and string.format("%" .. "%c[%s,%s,%s,%s]", c.a, c.r, c.g, c.b)
		if str then set_color_token(key, str) end
		self.parse_text_colors = true
		if (cond < 0.01) and self.args.has_power then
			self.active_suffix = string.format(" ($%s%s$clr_def)", key, gts("st_alti_nopower"))
		else
			self.active_suffix = string.format(" ($%s%s%%$clr_def)", key, cond)
		end
	else
		self.active_suffix = ""
	end
end


function InteractPrompt:UpdatePromptLength()
	local len           = self.prompt_length
	self.prompt_length  = self.lref:GetWidth() + 25
	if len == self.prompt_length then return self.prompt_length end
	if self.itemcard then
		setwndpos(self.itemcard, cfg.item_card_pos_x + self.prompt_length, cfg.item_card_pos_y or 0)
	end
	return self.prompt_length
end

function InteractPrompt:UpdateWeightColor()
	if not (self.card_wgt_icon and self.card_wgt_text) then return end
	local c = get_state_color(self.weight, 3)
	local color = c and getargb(c)
	if not color then return end
	self.card_wgt_icon:SetTextureColor(color)
	self.card_wgt_text:TextControl():SetTextColor(color)
end

function InteractPrompt:SetupItemCard(anchor, obj)
	if (not cfg.show_item_card) or (not self.args.is_pickup) then return end
	if self.itemcard then self.itemcard:Show(false) end
	obj = obj or (self.args.id and get_game_object(self.args.id))
	sec = self.args.inv_section or (obj and obj:section())
	if not sec then return end

	self.weight     = dec2(ini_sys:r_float_ex(sec,"inv_weight") or 0)
	local value     = dec2(ini_sys:r_float_ex(sec,"cost") or 0)

	xml:ParseFile(cfg.interact_uifile)
	local offset    = fontscale_w(self:UpdatePromptLength())
	self.itemcard   = self.xml:InitStatic("box", anchor or self.wnd)

	local icon_sz   = cfg.item_card_icon_sz
	local wnd_x     = cfg.item_card_pos_x
	local wnd_y     = cfg.item_card_pos_y
	local text_y    = cfg.item_card_text_y
	local elem_x    = cfg.item_card_elem_x
	local elem_y    = cfg.item_card_elem_y
	local elem_h    = fontscale_w(cfg.item_card_elem_h)
	local icon_x    = cfg.item_card_icon_x
	local icon_y    = cfg.item_card_icon_y

	setwndpos(self.itemcard, wnd_x + offset, wnd_y)

	self.card_wgt = self.xml:InitStatic("box", self.itemcard)
	setwndpos(self.card_wgt, elem_x, elem_y)
	self.card_wgt_icon = self.xml:InitStatic("box", self.card_wgt)
	setwndsize(self.card_wgt_icon, icon_sz * cfg.unsquish_ratio, icon_sz)
	setwndpos(self.card_wgt_icon, icon_x, icon_y)
	self.card_wgt_icon:InitTexture(cfg.item_card_icon_weight)
	self.card_wgt_icon:Show(true)

	offset = elem_x + self.card_wgt_icon:GetWidth()
	self.card_wgt_text = self.xml:InitStatic("box", self.card_wgt)
	setwndsize(self.card_wgt_text, 0, elem_h)
	setwndpos(self.card_wgt_text, offset, text_y)
	self.card_wgt_text:TextControl():SetFont(get_font_obj(cfg.font_item_card or 0))
	self.card_wgt_text:TextControl():SetText(self.weight)
	self.card_wgt_text:AdjustWidthToText()
	self.card_wgt_text:Show(true)
	self:UpdateWeightColor()

	local weight_w = offset + self.card_wgt_text:GetWidth()
	setwndsize(self.card_wgt, weight_w + 6, elem_h)
	self.card_wgt:InitTexture("ui_dotmarks_card_drop")
	self.card_wgt:SetTextureColor(getargb( cfg.colors.clr_card_drop ))

	offset = elem_x
	self.card_val = self.xml:InitStatic("box", self.itemcard)
	setwndpos(self.card_val, offset, elem_y + elem_h)
	self.card_val_icon = self.xml:InitStatic("box", self.card_val)
	setwndsize(self.card_val_icon, icon_sz * cfg.unsquish_ratio, icon_sz)
	setwndpos(self.card_val_icon, icon_x, icon_y)
	self.card_val_icon:InitTexture(cfg.item_card_icon_value)
	self.card_val_icon:SetTextureColor(getargb( cfg.colors.clr_text_light ))
	self.card_val_icon:Show(true)

	offset = elem_x + self.card_val_icon:GetWidth()
	self.card_val_text = self.xml:InitStatic("box", self.card_val)
	setwndsize(self.card_val_text, 0, elem_h)
	setwndpos(self.card_val_text, offset, text_y - 0.5)
	self.card_val_text:TextControl():SetFont(get_font_obj(cfg.font_item_card or 0))
	self.card_val_text:TextControl():SetText(value)
	self.card_val_text:TextControl():SetTextColor(getargb( cfg.colors.clr_text_light )) 
	self.card_val_text:AdjustWidthToText()
	self.card_val_text:Show(true)

	local value_w = offset + self.card_val_text:GetWidth()
	setwndsize(self.card_val, value_w + 6, elem_h)
	self.card_val:InitTexture("ui_dotmarks_card_drop")
	self.card_val:SetTextureColor(getargb( cfg.colors.clr_card_drop ))
	
	self.card_sp_icon = self.xml:InitStatic("box", self.itemcard)
	self.longest_card = math.max(weight_w, value_w)

	self:UpdateFaveJunkIcon()

	self.itemcard:Show(true)
end

function InteractPrompt:UpdateFaveJunkIcon()
	if not (zzz_rax_sortingplus_mcm and cfg.sp_flag_favejunk) then return end
	if not self.card_sp_icon then return end

	local texture = (is_favorite(self.args.section) and cfg.icon_sp_fave_texture) or
					(is_junk(self.args.section) and cfg.icon_sp_junk_texture) or
					""
	self.card_sp_icon:InitTexture(texture)
	local has_icon = (texture ~= "")
	self.card_sp_icon:Show(has_icon)
	if not has_icon then return end

	setwndpos(self.card_sp_icon,
		self.longest_card + fontscale_w(cfg.sp_icon_pos_x or 0),
		(cfg.sp_icon_pos_y or 0)
	)
	setwndsize(self.card_sp_icon, 16 * cfg.unsquish_ratio, 16)
end

function InteractPrompt:SetupUtjanPartDots(anchor, obj)
	-- Adapted from z_item_icon_info in Utjan's Item UI
	if not cfg.show_part_condition then return end
	if not (z_item_icon_info and item_icon_info_mcm) then return end
	if self.parts_indicators then
		for k,v in pairs(self.parts_indicators) do
			self.parts_indicators[k]:Show(false)
		end
	end

	obj = obj or (self.args.id and get_game_object(self.args.id))
	sec = obj and obj:section()
	cls = obj and obj:clsid()

	if not (obj and has_parts(obj)) then return end
	if (not cfg.show_parts_weapons) and IsWeapon(nil, cls) then return end
	if (not cfg.show_parts_armor) and (IsHeadgear(nil, cls) or IsOutfit(nil, cls)) then return end

	local se_parts = item_parts.get_parts_con(obj, nil, true)
	if is_empty(se_parts) then return end
	local parts = dup_table(se_parts)

	local sep = cfg.parts_dot_sep_width or 1
	local base_x = (cfg.parts_dot_pos_x or 0)
	self.parts_container = self.xml:InitStatic("box", anchor or self.wnd)
	setwndpos(self.parts_container, base_x, cfg.parts_dot_pos_y or 0)
	self.parts_indicators = self.parts_indicators or {}
	self.parts_shadows = self.parts_shadows or {}

	self.xml:ParseFile("ui_utjan_icon_info.xml")

	local drop_rad 		= cfg.parts_dot_shadow_radius or 0.5
	local dot_scale 	= cfg.parts_dot_scale or 1
	local cond_dot_h 	= dot_scale * 5
	local cond_dot_w 	= cond_dot_h * cfg.unsquish_ratio
	local shadow_sz 	= cond_dot_h + (drop_rad * 2)
	local shadow_a 		= clamp((cfg.parts_dot_shadow_alpha or 0) * 255, 0, 255)

	for part, v in pairs(parts) do
		if SYS_GetParam(1, part, "cond_part") then
			if not self.parts_indicators[part] then
				self.parts_shadows[part]	= self.xml:InitStatic("cond_dot", self.parts_container)
				self.parts_indicators[part] = self.xml:InitStatic("cond_dot", self.parts_shadows[part])
				setwndsize(self.parts_shadows[part], shadow_sz * cfg.unsquish_ratio, shadow_sz)
				self.parts_shadows[part]:SetTextureColor(get_argb(shadow_a, 0, 0, 0))
				setwndsize(self.parts_indicators[part], cond_dot_w, cond_dot_h)
				setwndpos(self.parts_indicators[part], drop_rad * cfg.unsquish_ratio, drop_rad)
			end
		else
			parts[part] = nil
		end
	end

	local i = 0
	local size = 0

	for part, condition in spairs(parts, z_item_icon_info.parts_sort) do
		local x = base_x + 1 + ((cond_dot_w + sep) * i)
		local y = 0
		setwndpos(self.parts_shadows[part], x, y)
		--self.parts_indicators[part]:SetWndPos(vector2():set(x + (drop_rad * cfg.unsquish_ratio), y + drop_rad))

		local c = get_condition_color(condition)
		local color = get_argb(c.a, c.r, c.g, c.b)

		if color then
			self.parts_indicators[part]:SetTextureColor( color )
		end
		self.parts_shadows[part]:Show(true)
		self.parts_indicators[part]:Show(true)
		size = x + cond_dot_w + sep
		i = i + 1
	end
	setwndsize(self.parts_container, size, 0)
	self.parts_container:InitTexture(cfg.main_drop_texture)
end



function InteractPrompt:eleSetCurrentColor(element, a, r, g, b)
	if not element then return end
	local argb = get_argb(a, r, g, b)
	if element.SetTextureColor  then element:SetTextureColor(argb) end
	if element.TextControl      then element:TextControl():SetTextColor(argb) end
	element.currcolor = {
		a = tonumber(a) or 255,
		r = tonumber(r) or 255,
		g = tonumber(g) or 255,
		b = tonumber(b) or 255
	}
end

function InteractPrompt:eleSetCurrentColorScheme(element, c)
	c = c or element.basecolor or self.text_color_default
	self:eleSetCurrentColor(element, c.a, c.r, c.g, c.b)
end

function InteractPrompt:eleSetBaseColorScheme(element, c)
	element.basecolor = c or self.text_color_default
	self:eleSetCurrentColorScheme(element, c)
end

function InteractPrompt:GetARGB(clr_tbl)
	return clr_tbl and get_argb({
		a = clr_tbl.a,
		r = clr_tbl.r,
		g = clr_tbl.g,
		b = clr_tbl.b
	})

end

function InteractPrompt:Event(set)
	if set and self.args then self.args.event = set end
	return set or (self.args and self.args.event) or "sec_interact"
end

function InteractPrompt:BindKey(set)
	if set and self.args then self.args.key = set end
	return set or (self.args and self.args.key) or cfg["bind_" .. self:Event()] or 0
end

function InteractPrompt:ModKey(set)
	if set and self.args then self.args.mod = set end
	return set or (self.args and self.args.mod) or cfg["modk_" .. self:Event()] or 0 
end

function InteractPrompt:InputMode(set)
	if set and self.args then self.args.imod = set end
	return set or (self.args and self.args.imod) or 0 
end

function InteractPrompt:SetBindText(text)
	text = text or (self.args and self.args.bind) or ""
	self.bind:TextControl():SetText(text)
	self.bind_sh:TextControl():SetText(text)
end

function InteractPrompt:on_key_hold(key)
	--dump("[%s] InteractPrompt:on_key_hold | key %s", key)
	if (self.disabled or self.destroyed or self.busystate) then return end
	
	if (key == self.args.key) and (self.args.mode == 2) and ui_mcm.get_mod_key(self.args.mod) then
		local now = time_global()
		if ui_mcm.key_hold(self.uid, key, 5) then
			local tid = get_current_target()
			local obj = tid and get_game_object(tid) or nil
			cfg.last_hold   = {
				key         = cfg.held_key,
				time        = now,
				by          = self
			}
			self.peak_hold  = nil
			cfg.held_key    = nil
			cfg.held_mod    = nil
			cfg.held_time   = nil
			cfg.holding     = nil
			cfg.use_released= cfg.use_released or now
			--dump("[%s][InteractPrompt:on_key_hold] Setting cfg.use_released to %s", now, cfg.use_released)
			self.longpress:SetProgressPos(0)
			self.args.func(obj, self.args.mark)
			return
		elseif cfg.last_hold and (cfg.last_hold.key == self.args.key) and not timed_out(cfg.last_hold.time, cfg.long_press_delay or 50) then
			--dump("[%s][InteractPrompt:on_key_hold] Tried to start another hold too soon, aborting", now)
			self.longpress:SetProgressPos(0)
			return
		end

		if not cfg.held_key then
			self.longpress:SetProgressPos(0)
			--dump("[%s][InteractPrompt:on_key_hold] Beginning hold of key %s", now, self.args.key)
		end
		cfg.held_key    = key
		cfg.holding     = self
		cfg.held_mod    = self.args.mod
		cfg.held_time   = ui_mcm and ui_mcm.hold[key] and ui_mcm.hold[key][self.uid]
	end
end

function InteractPrompt:on_key_press(key, flags)
	-- make sure to test with all input types, not just long press
	if (self.disabled or self.destroyed or self.busystate) then return end

	if (key == self.args.key) then
		if not ui_mcm then
			self.args.func()
			return
		end
		local obj = get_game_object(self.args.id)
		local mark = self:GetMark()

		if (self.args.mode == 0) then
			ui_mcm.simple_press(self.uid, key, self.args.func, obj, mark)
		end
	
		if (self.args.mode == 1) and ui_mcm.get_mod_key(self.args.mod) and ui_mcm.double_tap(self.uid, key) then
			self.args.func(obj, mark)
			return
		end
	end    
end

function InteractPrompt:actor_on_net_destroy() 
	self.disabled = true
	self.destroyed = true
	get_hud():RemoveDialogToRender(self)
end

function InteractPrompt:on_option_change()
	if self.args.tutorial and self.init_done then
		self:Destroy()
		return
	end
	if self.args.pri then
		self.args.key   = self.args.key or bind_to_dik(key_bindings.kUSE)
	else
		local sec       = cfg.bind_sec_interact
		local tap_time  = self.args.tap_time or (ui_mcm and ui_mcm.get("mcm/mcm_kb/mcm_kb_main/dtaptime2")) or 200
		self.hold_time  = (self.args.hold_time or (ui_mcm and ui_mcm.get("mcm/mcm_kb/mcm_kb_main/presstime")) or 2) * tap_time
		self.args.key   = cfg["bind_" .. (self.args.event or "")] or sec or 0
		self.args.mod   = cfg["modk_" .. (self.args.event or "")] or sec or 0 
		self.args.mode  = cfg["imod_" .. (self.args.event or "")] or sec or 0
	end

	self:BuildUI()

	self.bind_sh:Show((not self.black_text) and (not cfg.hide_drop_shadow))
	self.label_sh:Show(not cfg.hide_drop_shadow)
end

function InteractPrompt:BusyState(tf, prefix, force_update)
	local last_state = self.busystate
	self.busystate = not not tf
	if force_update or ((tf ~= nil) and (self.busystate ~= last_state)) then
		--dump("InteractPrompt:BusyState has changed to %s, updating prompt visuals", self.busystate)
		if self.busystate then
			self.active_prefix  = (prefix or gts("st_alti_busy")) .. " "
			self.active_prompt  = first_lower(self.active_prompt)
			if self.text_color_busy then
				self:eleSetCurrentColorScheme(self.label, self.text_color_busy)
				self:eleSetCurrentColorScheme(self.bind, self.text_color_busy)
			end
		else
			self.active_prefix = self.args.act
			self:eleSetCurrentColorScheme(self.label, self.text_color_light)
			self:eleSetCurrentColorScheme(self.bind, self.black_text and self.text_color_dark or self.text_color_light)
			self.active_prompt  = first_upper(self.active_prompt)
		end
		if self.itemcard and cfg.show_item_card then
			self.itemcard:Show(not tf)
		end
		if self.parts_container and cfg.show_item_card then
			self.parts_container:Show(not tf)
		end
		self:RegisterScriptCallbacks(not self.busystate)
		self:SetPrompt()
	end
	return self.busystate
end

function InteractPrompt:AbortFadeIn() return self.fading_out or not self.fading_in end
function InteractPrompt:AbortFadeOut() return self.fading_in or not self.fading_out end

function InteractPrompt:SetAlpha(element_name, alpha, text_also)
	coef = coef or 1
	alpha = clamp(alpha, 0, 255)
	if self[element_name] then
		local ele = self[element_name]
		local c = {}
		if ele.GetTextureColor then
			local i = ele:GetTextureColor()
			c.r,c.g,c.b,c.a = i and int_to_rgba(i)
			c.a = alpha or c.a
			ele:SetTextureColor(get_argb(c.a,c.r,c.g,c.b))
		end
		if text_also then
			c = ele.currcolor or ele.basecolor or {}
			c.a = alpha or c.a
			c.r = c.r or 255
			c.g = c.g or 255
			c.b = c.b or 255
			ele.currcolor = c
			ele:TextControl():SetTextColor(get_argb(c.a,c.r,c.g,c.b))
		end
	end
end

function InteractPrompt:ManageFadeAnim(
		alpha_start, alpha_end, 
		duration, event_id, instanced, 
		r, g, b, 
		anim_curve_modifier_func, on_finish_func, abort_func
	)

	local fade_dir = (alpha_start > alpha_end) and "out" or "in"
	if (event_id == nil) then event_id = "anim_fade" end
	local anim_id = event_id.."_"..tostring(time_global())
	r = r or 255
	g = g or 255
	b = b or 255

	local start_time= time_global()
	local end_time  = time_global() + duration
	local mark 		= self:GetMark()
	local mark_id 	= mark and mark.mark_id or ""
	if not active_anims[mark_id] then 
		active_anims[mark_id] = {}
	end

	--dump("[%s] [fading: %s] AnimateFade passed initial checks, time to fade %s", time_global(), self.fading_out, fade_dir)

	if active_anims[mark_id][event_id] then
		--dump("[%s] Existing animation found for %s::%s, updating", time_global(), mark_id, event_id)
		local anim 		= active_anims[mark_id][event_id]
		anim.start_time = start_time
		anim.end_time 	= end_time
		anim.a_start 	= anim.a
		anim.a_end 		= alpha_end
		anim.r 			= r
		anim.g 			= g
		anim.b 			= b
		return
	end

	local anim_state = 0
	local anim_curve_modifier_func = anim_curve_modifier_func or function(x) return x end
	active_anims[mark_id][event_id] = {
		anim_id     = anim_id,
		start_time  = start_time,
		end_time    = end_time,
		active      = true,
		a_start     = alpha_start,
		a_end       = alpha_end,
		a           = alpha_start,
		r           = r,
		g           = g,
		b           = b,
	}

	CreateTimeEvent("animate_fade"..event_id..anim_id, time_global(), 0, 
		function()
			local abort = abort_func and abort_func(self)
			if abort then
				anim_state = 1
			else
				local anim = active_anims[mark_id][event_id]
				if anim then
					local x = anim_curve_modifier_func(anim_state)
					local alpha = lerp(alpha_start, alpha_end, x)
					anim.a = alpha
					self.curr_alpha = alpha
					--dump("[%s] anim_state %s | setting alpha to %s", anim_state, time_global(), alpha)
					for k,v in pairs(self.elements) do
						
						self:SetAlpha(k, alpha, v)
					end
				else
					anim_state = 1
				end
			end

			if (anim_state == 1) then
				active_anims[mark_id][event_id] = nil
				--dump("[%s] anim complete", time_global())
				if on_finish_func then on_finish_func(self) end
				return true
			end
			anim_state = math.min(1, normalize(time_global(), start_time, end_time))
		end
	)
end

function InteractPrompt:AnimateFade(inout)
	if inout and self.fading_in then return end
	if (not inout) and self.fading_out then return end

	local uid = "prompt_fade" .. self.args.event
	if not self.curr_alpha then
		self.curr_alpha = 0
	end
	if inout then
		if self.fading_out then
			-- Fadeout cancel
			self.fading_out = false
		end
		if (self.curr_alpha ~= 255) and (cfg.prompt_fade_in_time and (cfg.prompt_fade_in_time > 0)) then
			self.fading_in = true
			self:ManageFadeAnim(
				self.curr_alpha, 255, cfg.prompt_fade_in_time, uid .. "in", false, nil, nil, nil, 
				nil,
				nil, self.AbortFadeIn
			)
		end
	else
		if self.fading_in then
			self.fading_in = false
		end
		if (self.curr_alpha ~= 0) and (cfg.prompt_fade_out_time and (cfg.prompt_fade_out_time > 0)) then
			-- This doesn't seem to be working - investigate
			self.fading_out = true
			self:ManageFadeAnim(
				self.curr_alpha, 0, cfg.prompt_fade_out_time, uid .. "out", false, nil, nil, nil, 
				nil,-- easing.InSine
				self.UpdatePromptVisibility, self.AbortFadeOut
			)
		end
	end
end
		
function InteractPrompt:UpdatePromptVisibility(tf)
	self.wnd:Show(tf)
end

function InteractPrompt:RegisterScriptCallbacks(tf)
	if self.callbacks_set and not tf then
		UnregisterScriptCallback("on_key_hold", self)
		UnregisterScriptCallback("on_key_press", self)
		if self.args.physics_obj or self.args.iedmode then
			UnregisterScriptCallback("on_before_key_press", self)
			if self.args.iedmode and cfg.sec_use_mousewheel_timer then
				UnregisterScriptCallback("on_mouse_wheel", self)
			end
		end
		self.callbacks_set = false
	elseif tf and not self.callbacks_set then
		RegisterScriptCallback("on_key_hold", self)
		RegisterScriptCallback("on_key_press", self)
		if self.args.physics_obj or self.args.iedmode then
			RegisterScriptCallback("on_before_key_press", self)
			if self.args.iedmode and cfg.sec_use_mousewheel_timer then
				RegisterScriptCallback("on_mouse_wheel", self)
			end
		end
		self.callbacks_set = true
	end
end

function InteractPrompt:MarkConditionsValid()
	if self.args.func_valid then
		return self.args.func_valid(self:GetMark(), self.args)
	end
	return true
end

function InteractPrompt:UpdateMark(state)
	if not self:MarkConditionsValid() then
		self:Destroy("invalid prompt")
	end
	if not self.linked_mark then return end
	if (state == nil) then state = not self.disabled end
	--dump("Propagating state %s to linked mark %s", state, self.linked_mark.name)
	self.linked_mark:ActiveSwap(state)

	if state and can_start_popin_anim(self.linked_mark) then
		init_active_marker_popin(self.linked_mark)
	end
end

function InteractPrompt:CheckCampfireStates()
	if self.campfire_tut then
		_ = debug_dump and vl("Checking campfire state for %s", self.args.tutorial)
		local obj = get_nearby_campfire(5, false)
		if obj then
			local id = obj and obj:id()
			local mark = id and cfg.markers[id]
			if mark then
				self.linked_mark = mark
			end
			cfg.active_campfire = id
		else
			dl("Clearing stuck tutorial %s at %s", self.tutorial, time_global())
			cfg.active_campfire = nil
			self:Destroy()
		end
	elseif self.args.is_campfire then
		--

	end
end

function InteractPrompt:OnVisibilityChange(state, reason)
	local _ = debug_dump and vl("[%s][InteractPrompt:OnVisibilityChange] to %s%s", time_global(), state, reason)
	self:RegisterScriptCallbacks(state)
	self:CheckCampfireStates()
	self:UpdateMark(state)
end

function InteractPrompt:ShowPrompt(tf, reason)
	if (tf and self.destroyed) then return end
	tf = not not tf
	reason = reason and (" (" .. reason .. ")") or ""
	self.peak_hold = nil
	local _ = debug_dump and vl("ShowPrompt %s: %s%s", self.active_prompt, tf, reason)
	self.line:SetProgressPos(tf and (not cfg.hide_connecting_line) and 1 or 0)
	if self.longpress and not tf then
		self.longpress:SetProgressPos(0)
	end
	self.disabled = not tf
	if self.last_state ~= self.disabled then
		self.last_state = self.disabled
		self:OnVisibilityChange(tf, reason)
	end
	self:AnimateFade(tf)
	if not self.fading_out then
		self:UpdatePromptVisibility(tf)
	end
end

function InteractPrompt:Prefix(set)
	if set then self.active_prefix = set end
	return (set or self.active_prefix or (self.args and self.args.act) or "")
end

function InteractPrompt:Prompt(set)
	if set then self.active_prompt = set end
	return (set or self.active_prompt or (self.args and self.args.text) or "")
end

function InteractPrompt:Suffix(set)
	if set then self.active_suffix = set end
	return (set or self.active_suffix or (self.args and self.args.suffix) or "")
end

function InteractPrompt:GetFullPrompt(prefix, prompt, suffix)
	return self:Prefix(prefix) .. self:Prompt(prompt) .. self:Suffix(suffix)
end

function InteractPrompt:SetPrompt(new_prefix, new_prompt, new_suffix)
	local new_text  = self:GetFullPrompt(new_prefix, new_prompt, new_suffix)
	local color_text, plain_text
	if self.parse_text_colors then
		color_text = parse_color_tokens(new_text, nil, true)
		plain_text = parse_color_tokens(new_text, nil, false)
	end
	local _ = debug_dump and vl("InteractPrompt:SetPrompt(%s, %s, %s) | %s", new_prefix, new_prompt, new_suffix, new_text)
	self.label:TextControl():SetText(color_text or new_text)
	self.label_sh:TextControl():SetText(plain_text or new_text)
	self.lref:TextControl():SetText(plain_text or new_text)
	self.lref:AdjustWidthToText()
	local pos = self:UpdatePromptLength()
	setwndsize(self.drop, pos + fontscale_w(cfg.interact_drop_w or 55), fontscale_h(cfg.interact_drop_h or 25))
end

function InteractPrompt:UpdateLongPress()
	if self.longpress and not self.args.pri then
		local mark = self:GetMark()
		--dump("[%s] InteractPrompt:UpdateLongPress", time_global())
		if mark.is_active and (not self.busystate) and (cfg.held_key == self.args.key) and (cfg.held_mod == self.args.mod) then
			self.peak_hold = time_continual() - (cfg.held_time or 0)
			local prog = (self.peak_hold / self.hold_time)
			self.longpress:SetProgressPos(prog)
			CUIScriptWnd.Update(self)
		else
			self.peak_hold = nil
			self.longpress:SetProgressPos(0)
		end
	end
end

function InteractPrompt:on_quickhelp_text_update(raw_text, loc_string, trimmed_text)
	--dump("on_quickhelp_text_update | %s | %s | %s", raw_text, loc_string, trimmed_text)
	if not (loc_string and self.prompts[loc_string]) then return end
	if self.args.refresh_text then
		self.args.text = trimmed_text
		self:SetPrompt(nil, self.args.text)
		return
	end        
end

function InteractPrompt:UpdateFilteredHints()
	if not (self.prompts and (self.args.is_door or self.args.is_button or self.args.is_workshop or is_already_target(self.args.id))) then return end
	local hint
	for k,v in pairs(self.prompts) do
		hint = v()
		if hint then
			if self.args.refresh_text then
				self.args.text = hint
				self:SetPrompt(nil, self.args.text)
				return
			end            
		end
	end
	return hint
end

function InteractPrompt:UpdateMutantLootPrompt()
	if is_dead_mutant(self.args) and self.args.section then
		local can_loot, loot_msg = can_chop_body(self.args.section)
		local changed = (loot_msg ~= self.last_loot_msg)
		self.last_loot_msg = loot_msg
		local prefix = (not can_loot) and gts("st_alti_cannot") or nil
		self:Suffix(can_loot and "" or (loot_msg and (": " .. gts(loot_msg))) or "")
		self:BusyState(not can_loot, prefix, changed)
	end
end

function InteractPrompt:UpdateAnimBusyState()
	if anims_enabled and cfg.prompt_busy_during_anim and not self.busy_locked then
		self:BusyState(anim_playing)
	end
end

function InteractPrompt:UpdatePrimaryInteractText()
	if self.args.iedmode then
		self.active_prompt = self.args.iedtext .. " " .. get_ied_text()
		-- Update IED text
		return
	elseif self.prompts then
		-- Skip any markers checked against hint filters
		return
	end

	-- Check any special cases that slip through	
	if (
		self.door or
		(not self.args.text) or
		(self.args.text == "")
	) then
		local hint = hintfilters.last_raw_text and trimmed_prompt(hintfilters.last_raw_text)
		self:SetPrompt(nil, hint or self.args.text or "")
	end
end

function InteractPrompt:CheckForStuckTutorial()
	_ = (not self.init_done) and vl("Updates for this type are handled in main loop")
	if self.args.tutorial and (time_global() - self.init_done > 1000) then
		local monitor_active = state_monitor(self.args.tutorial)
		if ((not monitor_active) or (not game.has_active_tutorial())) then
			vl("No active tutorial, destroying prompt")
			self:Destroy("no active tutorial for " .. self.args.tutorial)
			return
		end
	end
end

function InteractPrompt:GetWoundedSuffix(last_aid, qty)
	if (last_aid ~= self.avail_aid) then
		self.aid_multi = nil
	end
	self.aid_multi = self.aid_multi or IsItem("multiuse", self.avail_aid)
	local text = string.format(" (%s %s%s)", qty or 0, self.aid_multi and (gts("st_alti_uses").." ") or "", gts("st_alti_owned"))
	return text
end

function InteractPrompt:CheckWoundedStalkers()
	self.avail_aid = nil
	local mark = self.args.id and cfg.markers[self.args.id]
	local last_aid = self.avail_aid
	self.avail_aid = cheapest_medical_help_owned()
	local qtyowned  = actor_aid_item_count(self.avail_aid) or 0
	if qtyowned < 1 then
		dump("InteractPrompt:CheckForWoundedStalkers found no health items")
		self.avail_aid = nil
		self:ShowPrompt(false)
		return
	end
	--dump("Generating heal prompt text for aid item %s", self.avail_aid)
	self.wounded_string = self.wounded_string or gts("st_alti_heal")
	local use_aid_name = gts(inventory_name(nil, self.avail_aid, true))
	self.args.text  = string.format(self.wounded_string, use_aid_name, mark.name)
	local suffix = self:GetWoundedSuffix(last_aid, qtyowned)
	self:SetPrompt(nil, self.args.text, suffix)
	self:UpdateAnimBusyState()
end

function InteractPrompt:actor_on_update()
	if self.destroyed then return end
	local _ = debug_dump and vl("[%s][%s]InteractPrompt:actor_on_update | %s%s", self.args.id, self.args.event, self.init_done and "" or "first run at ", time_global())
	self:UpdateFilteredHints()

	local mark = self:GetMark()

	if (self.args.tutorial or (mark and mark.is_stalker)) then
		self:CheckForStuckTutorial()
		self:CheckCampfireStates()
		self:UpdateMark()
		_ = (not self.args.pri) and mark and mark.is_wounded and self:CheckWoundedStalkers()
		self:UpdateLongPress()
		return
	end

	if self.disabled then return end

	if self.args.pri then
		self:UpdatePrimaryInteractText()
		self:UpdateFaveJunkIcon()
		self:UpdateMutantLootPrompt()
	else
		self:UpdateLongPress()
	end

	self:UpdateAnimBusyState()
end

function InteractPrompt:Destroy(reason)
	self:ShowPrompt(false)
	self:HideDialog()
	self.hint_filters   = nil
	self.destroyed      = true
	if self.linked_mark and self.linked_mark.use_pri then
		self.linked_mark:ActiveSwap(false)
		self.linked_mark.use_pri:ShowPrompt(false)
	end
	get_hud():RemoveDialogToRender(self)
	
	if reason then
		dl("[InteractPrompt:Destroy][%s][%s]", self.args.id, reason)
	end
end

-- =======================================================================
--      MAIN LOGIC
-- =======================================================================

function init_target_metadata(id, meta_dat)
	if not cfg.target_data[id] then
		cfg.target_data[id] = {}
	end
	if meta_dat ~= nil and not cfg.target_data[id][meta_dat] then
		cfg.target_data[id][meta_dat] = {}
	end
end

function set_target_data(id, meta_dat, result)
	if not (id and meta_dat) then return end
	init_target_metadata(id, meta_dat)
	cfg.target_data[id][meta_dat].result = result
	return result
end

function get_metadata_record(id, meta_dat)
	return id and meta_dat and cfg.target_data[id] and cfg.target_data[id][meta_dat]
end

function get_target_data(id, meta_dat)
	return id and meta_dat and cfg.target_data[id] and cfg.target_data[id][meta_dat] and cfg.target_data[id][meta_dat].result
end

function ismeta_mutant(id)
	return get_target_data(id, cfg.metadata_types.is_mutant)
end

function ismeta_container(id)
	return get_target_data(id, cfg.metadata_types.is_container)
end

function ismeta_pickup(id)
	return get_target_data(id, cfg.metadata_types.is_pickup)
end

function ismeta_empty_mutant(id)
	return get_target_data(id, cfg.metadata_types.empty_mutant)
end

function is_dead_mutant(args, id)
	if id and not args then
		args = id and cfg.markers[id]
	end
	if args then
		return args.is_mutant and not args.is_alive
	end
end

function is_empty_mutant_corpse(id)
	if not is_dead_mutant(nil, id) then return end
	if get_metadata_record(id, cfg.metadata_types.is_empty_mutant) then
		return ismeta_empty_mutant(id)
	end
	local obj = id and get_game_object(id)
	local looted = obj and se_load_var(id, obj:name(), "looted")
	local st = db.storage[id]
	local decayed = (st and st.death_time and game.get_game_time():diffSec(st.death_time) > cfg.mutant_decay_time)
	local empty = (looted or decayed)
	--dump("is_empty_mutant_corpse: %s | looted %s | decayed %s", empty, looted, decayed)
	return empty and set_target_data(id, cfg.metadata_types.is_empty_mutant, empty)
end

function can_chop_body(section)
	if not section then return end
	local result, tip
	if (item_knife.is_equipped()) then
		if (item_knife.get_condition() < 0.15) then
			tip = "st_body_knife_bad"
		elseif (not item_knife.can_loot(section)) then
			tip = "st_body_knife_weak"
		else
			result = true
			tip = "st_body_loot"
		end
	else
		tip = "st_body_knife_needed"
	end
	return result, tip
end

function is_actor_in_sleep_zone()
	for k,v in pairs(ui_sleep_dialog.sleep_zones) do
		if utils_obj.npc_in_zone(db.actor, v) then
			return true
		end
	end
end


function get_current_target()
	--dump("current target: %s | L %s | T %s", locked_id or targeted_id, locked_id, targeted_id)
	return locked_id or targeted_id or nil
end

function is_current_target(id)
	if not id then return end
	local curr_target = get_current_target()
	--dump("id %s is %sthe current target", id, curr_target and (id == curr_target) and "" or "not ")
	return curr_target and (id == curr_target)
end

function get_current_target_obj()
	local id = get_current_target()
	return id and get_game_object(id) or nil
end

function is_target_pickup(id)
	id = id or get_current_target()
	if get_metadata_record(id, cfg.metadata_types.is_pickup) then
		return get_target_data(id, cfg.metadata_types.is_pickup)
	end
	local result = id and (id == cfg.available_pickup) or (cfg.markers[id] and cfg.markers[id].is_pickup)
	return set_target_data(id, cfg.metadata_types.is_pickup, result)
end

function is_target_container(id, cls)
	id = id or get_current_target()
	if get_metadata_record(id, cfg.metadata_types.is_container) then
		-- Get cached result if it exists
		return ismeta_container(id)
	end
	local result, obj
	result = id and cfg.markers[id] and cfg.markers[id].is_container
	if not result then
		obj = get_game_object(id)
		cls = cls or (obj and obj:clsid())
		if (obj and cls) then
			result = (IsInvbox(nil, cls) or (IsStalker(nil, cls) and not (obj:alive())))
		else
			result = false
		end
	end
	return set_target_data(id, cfg.metadata_types.is_container, result)
end

function state_monitor(tid)
	if not tid then return end
	local state = tuthooks and tuthooks.monitors and tuthooks.monitors[tid] and tuthooks.monitors[tid].state
	local conds = state and cfg.state_conds and cfg.state_conds[tid] or nil
	local cond  = true
	if state and (conds ~= nil) then
		cond = cfg.state_conds[tid](tid)
	end
	cfg.monitors[tid] = state and cond or false
	return cfg.monitors[tid]
end

function show_interaction_dots(tf)
	cfg.hide_interaction_dots = not tf
end

function get_physpickup_name(mark)
	local text

end

function get_physpickup_action_text(mark)
	local text
	if mark.is_glowstick then
		text = gts("st_alti_take").." "..mark.name
	elseif mark.is_disarmable then
		text = gts("st_alti_disarm") .." "..trimmed_prompt(mark.name)
	end
	return text
end

function take_glowstick(id)
	local obj = id and get_game_object(id)
	if (obj and obj:section() == "lights_glowstick") then
		local glowsticks = zz_glowstick_mcm.glowsticks
		local pos2d = game.world2ui(obj:position())
		if (pos2d.x < 350 or pos2d.x > 750 or pos2d.y < 250 or pos2d.y > 500) then return end
		if (not obj:get_hanging_lamp():is_on()) then return end

		local section = glowsticks[id][1] or "device_glowstick"
		local con_d = glowsticks[id][2]
		local newid = alife_create_item(section, db.actor, {cond = con_d}).id
		glowsticks[id] = nil
		alife_release_id(id)
		CreateTimeEvent("glowstick", "try_draw_on_take", 0.1, zz_glowstick_mcm.try_draw_on_take, newid)
	end
end

-- =======================================================================
-- 		DEPENDENCY CHECK
--	Checks all hard dependencies one by one, logs which ones fail, and 
--	shows an appropriate message to the user at the end.
-- =======================================================================
function check_for_dependencies(silent, debug_test)
	dl("[%s] Checking for dependencies", time_global())
	local failmessage
	local no_config             = not cfg
	dl("config loaded: %s", not no_config)
	-- Trap load failure

	dl("using_modded_exes: %s", using_modded_exes)
	-- Modded exes are a hard requirement, nothing will function without them

	local exes_version          = MODDED_EXES_VERSION or (get_modded_exes_version and get_modded_exes_version()) or 0
	local no_callback_old_exes   = (exes_version < 20250306)
	dl("no_callback_old_exes: %s", no_callback_old_exes)
	-- Modded exes found, but too old to support actor_on_update_pickup callback

	local no_callback_old_dbs   = (_G.CPickupModeUpdate_COD == nil) or not cfg.update_pickup_firing
	dl("no_callback_old_dbs: %s | found in _G %s | callback firing %s", no_callback_old_dbs, not (_G.CPickupModeUpdate_COD == nil), cfg.update_pickup_firing)
	-- Modded exes up to date, but stale DB files causing missing callback

	local no_lookat_method      = (exes_version < 20250225) or (not db.actor.get_actor_object_looking_at)
	dl("no_lookat_method: %s", no_lookat_method)
	-- Modded exes found, but too old even to support get_actor_object_looking_at

	local bad_mcm_version       = not valid_mcm_version(true)
	local ui_functors           = not not (ui_mcm and ui_mcm.UI_MCM and ui_mcm.UI_MCM.Init_Wrapper_Box)
	local mcm_version           = ui_mcm and ui_mcm.VERSION or "NOT FOUND"
	dl("bad_mcm_version: %s", bad_mcm_version)
	-- Version of MCM older than 1.7.0

	local no_hud_mark_manager   = (not hmm)
	dl("no_hud_mark_manager: %s", no_hud_mark_manager)
	-- HUD Mark Manager not found, which is really bad because we should've asserted by now

	local epic_fail             = (not using_modded_exes) or
									no_callback_old_exes or
									no_callback_old_dbs or
									no_hud_mark_manager or
									no_pickup_callback or
									no_lookat_method or
									bad_mcm_version or
									no_config
	if not (epic_fail or debug_test) then return end
	cfg = cfg or {}
	cfg.killswitch_all = true
	set_handler_callbacks(true)
	alert("Dependency check failed!")

	if (not using_modded_exes) or (debug_test and debug_test == 1) then
		failmessage         = gts("st_dotmarks_fail_reason_noexes") ..
							gts("st_get_modded_exes")

	elseif no_callback_old_exes or (debug_test and debug_test == 2) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldexes"), 20250306, exes_version) ..
							gts("st_get_modded_exes")

	elseif no_lookat_method or (debug_test and debug_test == 3) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldexes"), 20250225, exes_version) ..
							gts("st_get_modded_exes")

	elseif no_callback_old_dbs or (debug_test and debug_test == 4) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_staledbs"), exes_version) ..
							gts("st_get_modded_exes")

	elseif bad_mcm_version or (debug_test and debug_test == 5) then
		failmessage         = string.format(gts("st_dotmarks_fail_reason_oldmcm"), mcm_version, ui_functors) ..
							gts("st_catsy_get_mcm")

	elseif no_hud_mark_manager or (debug_test and debug_test == 6) then
		failmessage         = gts("st_dotmarks_fail_reason_nohmm")

	elseif no_config or (debug_test and debug_test == 7) then
		failmessage         = gts("st_dotmarks_fail_reason_nocfg")
	end

	if failmessage then
		failmessage = gts("st_dotmarks_epicfail_error") .. failmessage .. gts("st_catsy_failmessage_in_log_or_pda")
		local log_msg = parse_color_tokens(failmessage, nil, false)
		alert(log_msg)
		if silent and not debug_test then
			return epic_fail
		end

		failmessage = parse_color_tokens(failmessage)
		CreateTimeEvent("dotmarks_dependency_warning", 0, 4, (
			function()
				dotip(failmessage, 10000, "Interaction Dot Marks", true, "ui_inGame2_V_zone_nedavno_proshel_vibros")
				return true
			end
		))
	end
	return true
end

function actor_on_first_update()
	hmm = utils_catspaw_hudmarks and utils_catspaw_hudmarks.get_hud_mark_manager()
	CreateTimeEvent("dotmark_scan_delay", 0, cfg.scan_start_delay, start_scanning)
	maingameui = ActorMenu.get_maingame()
	xml = CScriptXmlInit()
end

function start_scanning()
	if check_for_dependencies(false) then return true end
	scanning = true
	if utils_catspaw_taskmonitor then
		utils_catspaw_taskmonitor.set_monitor_active(true)
	end
	return true
end

function stop_scanning()
	scanning = false
	if utils_catspaw_taskmonitor then
		utils_catspaw_taskmonitor.set_monitor_active(false)
	end
	return true
end

function actor_on_net_destroy()
	stop_scanning()
end

function is_object_scannable(item_class)
	return not not (item_class and cfg.scan[item_class])
end

function get_args_for_valid_objects(obj)
	if not obj then return end
	local id = obj:id()
	local cls = obj:clsid()
	local sec = obj:section()
	local kind = get_obj_kind(obj)

	vl("get_args_for_valid_objects: %s - clsid %s", nameid(nil, id), cls)
	if is_blacklisted(id, cls, sec, kind) then
		local _ = debug_dump and vl("Object matched one or more blacklists: id %s | cls %s | sec %s | kind %s", cfg.blacklisted_ids[id], cfg.blacklisted_clsids[cls], cfg.blacklisted_sections[sec], cfg.blacklisted_kinds[kind])
		return
	end
	local args = { logged_type = "something else", section = sec, clsid = cls }

	local function setup_item_args(iclass)
		args            = get_cfg_for_type("args", iclass, obj) or {}
		if args.iclass_override then
			iclass      = args.iclass_override
			args        = get_cfg_for_type("args", iclass, obj) or {}
		end
		args.item_class	= iclass
		args.id         = id
		args.clsid      = cls
		args.kind       = kind
		args.section    = args.inv_section or sec
		args.hidden     = not is_object_scannable(iclass)
		args.has_power  = (item_device.dev_consumption[sec] or (sec == "batteries_dead")) or nil
	end

	local method
	local stype = get_type_for_section(sec)
	if stype then
		vl("Section %s found in lookup: %s", sec, stype)
		method = 0
		setup_item_args(stype)
	else
		local ktype = get_type_for_kind(kind)
		if ktype then
			vl("Kind %s found in lookup: %s", kind, ktype)
			method = 1
			setup_item_args(ktype)
		else
			for item_class, enabled in pairs(cfg.scan) do
				if cfg.is_item[item_class](obj, sec, cls, kind) then
					vl("Type found via iteration: %s", item_class)
					setup_item_args(item_class)
					method = 2
					break
				end
			end
		end
	end
	
	if not args.texture then
		local pid = cfg.available_pickup
		if (id == pid) then
			alert("Obj %s failed classification, but is detected by engine as a pickup!\n"..
				"$ Classifying \"Misc\" as a fallback, investigate: section %s | clsid %s | kind %s",
				nameid(nil, id), sec, cls, kind
			)
			setup_item_args("Misc")
		else
			dl("No args found for %s, no marker init | section %s | clsid %s | kind %s", nameid(nil, id), sec, cls, kind)
			return
		end
	end
	if not args.texture then return end

	local method_txt = (method > 1) and "iteration" or (method > 0) and "kind" or "section"
	local _ = (DEV_DEBUG or debuglogs) and printf("[DotMarks] get_args_for_valid_objects: %s classification is %s (matched by %s) | section %s | kind %s", nameid(obj), args.logged_type, method_txt, sec, kind)
	return args
end

-- =======================================================================

function setup_pri_interact_prompt(mark, args)
	dl("[%s] setup_pri_interact_prompt for %s", mark.mark_id or "fixed interaction", args and (args.name or args.logged_type) or "unknown type with no passed args")
	if not mark then return end
	if mark.use_pri then
		mark.use_pri:Destroy("re-init of existing prompt")
		mark.use_pri = nil
	end
	args            = args or {}
	local anchor    = mark.marker or args.anchor
	local key       = bind_to_dik(key_bindings.kUSE)
	local bind_text = bindtext(key, 0)
	local int_text  = trimmed_prompt(get_quickhelp_text())

	if mark.is_pickup then
		if mark.physics_obj then
			int_text = get_physpickup_action_text(mark)
		else
			int_text = nil
		end
		if not int_text then
			int_text = gts("st_alti_take") .. " " .. (mark.money or mark.name)
		end
	elseif mark and mark.is_stalker and mark.is_alive then
		int_text = gts("st_alti_speak") .. " " .. mark.name
	elseif mark and mark.is_door then
		int_text = int_text or trimmed_prompt(gts("car_character_use"))
	elseif mark and mark.is_container then
		int_text = gts("st_alti_search") .. " " .. mark.name
	elseif mark and (mark.is_npc and not mark.is_alive) then
		int_text = gts("st_body_loot")
	elseif mark and mark.hf_workshop then
		int_text = nil
	end

	local passed_args = {
		pri         = true,
		name        = mark.name or args.name or nil,
		text        = int_text,
		bind        = bind_text,
		key         = key,
		section     = section,
		func        = args and args.handler_func or (function() end),
		event       = "pri_interact",
		monitors    = mark.monitors,
	}
	if args and not is_empty(args) then for k,v in pairs(args) do passed_args[k] = v end end

	mark.use_pri = InteractPrompt(anchor or maingameui, passed_args)
	return mark.use_pri
end


function setup_sec_interact_prompt(mark)
	if not mark then return end
	if mark.alt_interact then return end
	if mark.checked_for_sec then return end
	mark.checked_for_sec = true
	local id        = mark.id
	dl("[%s][%s] setup_sec_interact_prompt for %s", id, mark.mark_id, mark.name)
	local anchor    = mark.marker
	local obj       = id and get_game_object(id)
	local section   = obj and obj:section()
	local mode      = cfg.imod_sec_interact
	local act_text  = (mode == 2) and gts("st_alti_hold").." " or (mode == 1) and gts("st_alti_doubletap").." " or ""
	local bind_text = bindtext(cfg.bind_sec_interact, cfg.modk_sec_interact)
	local int_text  = ""
	local iedmode 	= nil
	local func      = mark.handler_func or handle_secondary_interact

	if obj and IsWeapon(obj) then
		if not cfg.sec_enable_unload_act then return end
		local atype     = obj:get_ammo_type() + 1
		local ammos     = parse_list(ini_sys, obj:section(), "ammo_class")
		local sec       = ammos and atype and ammos[atype]
		local ammo      = find_best_localization(nil, nil, sec)
		int_text        = string.format(gts("st_alti_prompt_ammo"),
			mag_installed and gts("st_alti_eject_mag") or gts("st_alti_unload_weapon"),
			ammo,
			mark.ammo_count,
			gts("st_alti_from"),
			mark.name
		)
		func = unload_and_take_ammo
	elseif mark.placeable_mine then
		iedmode = get_ied_text()
		if not iedmode then return end
		int_text = string.format(gts("st_alti_ied"), trimmed_prompt(mark.name))
		func = plant_bomb
	elseif mark.is_wounded then
		if not cfg.sec_enable_heal_act then return end
		func = help_wounded_stalker
		func_valid = is_still_wounded
	elseif mark.hf_workshop then
		int_text = gts("st_hf_workshop_menu")
	elseif mark.is_container then
		if not cfg.sec_enable_takeall_act then return end
		-- Inventory box or stash
		local weight = nil
		if not obj:is_inv_box_empty() then
			local tbl = get_inventory_table(obj, id)
			weight = axr_companions.get_inventory_weight(tbl)
		end
		if (section == "inv_backpack") then
			-- Pick up backpack and everything in it
			int_text = first_upper(gts("st_alti_pickup_bp"))
			func = pick_up_backpack
		elseif z_auto_looter and cfg.takeall_does_autoloot and not mark.autolooted then
			-- Trigger iTheon's autoloot
			int_text = string.format("%s %s",
				first_upper(gts("st_alti_autoloot")),
				mark.name
			)
			func = trigger_autoloot
		else
			-- Take everything from box
			int_text = string.format("%s %s",
				first_upper(gts("st_alti_takeall")),
				mark.name
			)
			func = take_all_from_box
		end
	elseif cfg.is_item.Tools(obj) then
		if not cfg.sec_enable_use_act then return end
		-- Usable tool
		local verb      = mark.use_verb or "st_alti_takeuse"
		int_text        = string.format(gts("st_alti_prompt_usable"),
			gts(verb),
			mark.name,
			gts("st_alti_now")
		)

	elseif cfg.is_item.Consumables(obj) then
		if not cfg.sec_enable_use_act then return end
		-- Consumable
		local verb      = mark.use_verb or (
			(mark.kind == "i_medical") and "st_alti_use_booster" or
			(cfg.smokables[section] and "st_alti_smokeout") or
			"st_alti_consume_food"
		)
		int_text        = string.format(gts("st_alti_prompt_usable"),
			gts(verb),
			mark.name,
			gts("st_alti_now")
		)
	elseif (mark.kind == "i_letter") then
		if not cfg.sec_enable_use_act then return end
		-- Readable
		int_text        = string.format(gts("st_alti_prompt_usable"),
			gts("st_alti_read"),
			mark.name,
			gts("st_alti_now")
		)
		func = take_and_read
	elseif section and IsItem("device", section) then
		if not cfg.sec_enable_unload_act then return end
		-- Device with battery power
		int_text        = string.format(gts("st_alti_prompt_usable"),
			first_upper(gts("st_item_unpack_battery")),
			gts("st_alti_from"),
			mark.name
		) 
		func = unpack_batteries
	elseif (mark.clsid == clsid.equ_backpack) then
		-- Backpack inventory item
		int_text        = string.format("%s %s",
			first_upper(gts("st_alti_deploy_bp")),
			mark.name
		)
		func = deploy_backpack
	else
		if not cfg.sec_enable_use_act then return end
		-- Fallback to generic "use" prompt
		int_text        = string.format(gts("st_alti_prompt_booster"),
			gts("st_alti_takeuse"),
			mark.name,
			gts("st_alti_now")
		)
	end

	local args = {
		mark    	= mark,
		iedmode 	= iedmode,
		name    	= mark.name,
		text    	= int_text,
		act     	= act_text,
		bind    	= bind_text,
		long    	= (mode == 2),
		func    	= func,
		id      	= id,
		func_valid 	= func_valid,
		event   	= "sec_interact",
	}

	mark.alt_interact = InteractPrompt(anchor or maingameui, args)
end

function set_secondary_action(mark)
	if not mark then return end
	if mark.alt_interact then
		mark.alt_interact:Destroy("reinit as something else")
		mark.alt_interact = nil
	end
	setup_sec_interact_prompt(mark)
end

-- =======================================================================

local scanned = {}

function unregister_scanned_entity(id)
	if not id then return end
	if (locked_id == id) then
		locked_id = nil
	end
	if (targeted_id == id) then
		targeted_id = nil
	end
	local ind = pickup_index[id]
	if ind then
		nearby_pickups[ind] = nil
	end
	scanned[id] = nil
	cfg.invboxes[id] = nil
	pickup_index[id] = nil
	cfg.target_data[id] = nil
	cfg.in_pickup_range[id] = nil
	if cfg.markers[id] then
		local mark = cfg.markers[id]
		if mark.use_pri then
			mark.use_pri:Destroy("unregistering pri use" .. id)
		end
		if mark.alt_interact then
			mark.alt_interact:Destroy("unregistering sec use")
		end
		if mark.preset then
			destroy_marker(mark.mark_id, "unregister_scanned_entity")
		else
			destroy_prompt(id, "unregister_scanned_entity")
		end
	end
	

	vl("[%s] Unregistering scanned entity for %s and nulling all pointers to it", time_global(), nameid(name, id))
end

function set_loot_window_flag(val, reason)
	cfg.block_loot_window = val
	local text = val and "Setting to: " or "Clearing"
	vl("[%s] Flag cfg.block_loot_window: %s%s%s", time_global(), text, val or "", reason and (" ("..reason..")") or "")
end

function mark_is_shown(id)
	return id and cfg.markers[id] and cfg.markers[id].is_shown
end

function marked_obj_has_ammo(id)
	return id and cfg.markers[id] and (cfg.markers[id].ammo_count and cfg.markers[id].ammo_count > 0)
end

function can_interact_physpickup(obj, id, dist)
	if dist > get_interact_distance(id) then return false end
	obj         = obj or (id and get_game_object(id))
	id          = id or (obj and obj:id())
	local pos   = obj and obj:position()
	local dot   = pos and utils_catspaw_hudmarks and utils_catspaw_hudmarks.dotproduct_for_pos(pos) or 0
	return dot >= (cfg.target_lenience)
end

function obj_has_available_sec_interact(obj, id, mark)
	if not (obj or id) then return end
	if (not mark) or (mark.no_sec or mark.is_display) then return false end

	id = id or (obj and safeid(obj))
	obj = obj or (id and get_game_object(id))
	if not obj then return end
	if cfg.useless_shit[obj:section()] then return end

	local cls           = obj and obj:clsid()
	local is_melee      = IsMelee(nil, cls)
	local has_ammo      = marked_obj_has_ammo(id) and not is_meele
	local is_consumable = cfg.is_item.Consumables(obj)
	local is_readable   = (mark and mark.is_readable)
	local has_batteries = (mark and mark.has_battery)
	local is_backpack   = (mark and mark.is_backpack)
	local is_mine 		= (mark and mark.placeable_mine)
	local is_interact   = mark.is_container or mark.hf_workshop

	local required      = (
		is_consumable or
		has_batteries or
		is_readable or
		has_ammo or
		is_mine or
		is_interact
	)

	local banned        = (
		mark.money
	)

	local has_interact = required and not banned

	local _ = debug_dump and vl("[obj_has_available_sec_interact] %s: %s\n" ..
		"^ Required: interaction %s | batt %s | ammo %s | eatable %s | readable %s\n" ..
		"~ Banned: money %s",
		nameid(obj, id),
		has_interact,
		is_interact,
		has_batteries,

		has_ammo,
		is_consumable,
		is_readable,
		mark.money
	)
	return has_interact
end

function scan_nearby_object(obj)
	local id  = obj and obj:id()
	if not valid_id(id) then return end
	local name = obj and obj:name()

	if scanned[id] then
		-- Skip previously-scanned IDs if their name matches, otherwise clear the table entry assuming it's a reused ID
		if scanned[id] == name then
			--dump("%s has already been scanned, skipping", nameid(name, id))
		return end
		dl("%s has a new name, assuming the ID has been reused and clearing entry", id)
		scanned[id] = nil
	end

	local m_id  = "dotmark_" .. tostring(id)
	hmm = hmm or utils_catspaw_hudmarks.get_hud_mark_manager()
	if not hmm then return end

	local cls = obj:clsid()
	local sec = obj:section()

	if hmm:GetMarker(m_id) then
		-- Already a marker for this ID, skip
	else
		scanned[id] = name
		dl("Scanning unmarked object %s | clsid %s | [%s]", nameid(name, id), cls, sec)
		local args  = get_args_for_valid_objects(obj)
		if not args then return end

		args            = args or {}
		args.id         = id
		args.mark_id    = m_id
		args.name       = args.name or find_best_localization(obj, nil, sec) or nil
		args.preset     = "dotmark"
		if debug_dump then
			vl("Passing the following args to utils_catspaw_hudmarks:")
			for k,v in pairs(args) do
				vl("%s = %s", k, v)
			end
		end

		if not cfg.markers then cfg.markers = {} end
		cfg.markers[id] = hmm:AddMarker(args)
		local mark = cfg.markers[id]
		if mark.is_pickup then
			if cfg.pickup_los_pos_adj and not mark.los_pos_adjust then
				mark.los_pos_adjust = vector():set(0, cfg.pickup_los_pos_adj, 0)
			end
		end

		if (not cfg.hide_pri_interact_ui) and not (args.no_pri) then
			setup_pri_interact_prompt(mark, args)
		end
		if obj_has_available_sec_interact(obj, id, mark) and not (args.no_sec) then
			setup_sec_interact_prompt(mark)
		end
		if (not mark.active_swap) and cfg.enable_icon_targetdot then
			mark.active_swap = cfg.swap_dotactive
		end
		--init_ied_mark_anim(mark) -- not working yet

		has_cond = (sec and cls) and (utils_item.is_degradable(nil, sec) or IsWeapon(nil, cls) or IsOutfit(nil, cls) or IsHeadgear(nil, cls))
		local is_mag = magazine_binder and sec and magazine_binder.is_magazine(sec)
		if has_cond and not is_mag then
			mark.condition = obj and obj:condition()
		end
	end
end


function scan_nearby_entities(scan_radius)
	--dump("[%s] scan_nearby_entities(%s)", scan_radius)
	local pos = db.actor and db.actor:center()
	if not pos then return end
	level.iterate_nearest(pos, scan_radius, scan_nearby_object)
end


function dot_eye(position)
	-- Taken from Crook's Faction ID
	local toPoint = vector():set(position):sub(device().cam_pos):normalize()
	local toEye = device().cam_dir
	local dot = toPoint:dotproduct(toEye)
	
	return dot
end

local function log_target_acquisition(method, last_id)
	if not (debug_dump and method) then return end
	local target = targeted_id and get_game_object(targeted_id)
	if not target then return end
	local method_txt = ""
	if method < 0 then
		target = last_id and get_game_object(last_id)
		if target then
			dump("[%s] update_targeted_object: no longer targeting %s", time_global(), nameid(target))
		end
		return
	elseif method > 1 then
		method_txt = "avail_pickup"
	elseif method > 0 then
		method_txt = "looking_at"
	else
		method_txt = "target_obj"
	end
	dump("[%s] update_targeted_object: targeted_id is now %s (%s) | method %s", time_global(), targeted_id, target and target:name(), method_txt)
end

function is_marker_object_container(obj, id)
	id = id or (obj and obj:id())
	return id and cfg.markers[id] and cfg.markers[id].is_container
end

function update_targeted_object()
	local last_id = targeted_id
	local target, method

	if db.actor.get_actor_object_looking_at then
		-- 20250225 modded exes required for this method
		target = db.actor:get_actor_object_looking_at()
		method = 1
	elseif cfg.use_fallback_targeting then
		-- Vanilla but very finicky, requires the object to be precisely under the crosshair
		target = level.get_target_obj()
		method = 0
	end
	if cfg.available_pickup and not is_marker_object_container(target) then
		target = get_game_object(cfg.available_pickup)
		method = 2
		-- 20250306 modded exes required for pickup callback
	end    

	local id = target and target:id()
	if cfg.racked_items[id] then
		targeted_id = cfg.racked_items[id]
		target = get_game_object(targeted_id)
	else
		targeted_id = id
	end

	cfg.active_task_target_id = get_task_target()
	if targeted_id then
		if target and (method < 1) and cfg.fallback_distance_check and (targeted_id ~= last_id) then
			local apos = db.actor:position()
			local dist = apos:distance_to(target:position())
			if dist > (cfg.obj_interact_dist or 2.5) then
				targeted_id = nil
			end
		end
	elseif last_id then
		method = -1
	else
		return
	end
	log_target_acquisition(method, last_id)
end


function fake_take_anim(mark)
	if not (mark and mark.id and lam2 and liz_fdda_redone_item_pickup) then return end
	vl("Faking take animation for %s", mark.name)
	-- This is largely a stripped-down copy of the item-take animation function in FDDAR
	--if something other than pickup is playing right now, don't do anything
	if lam2.is_running() and not lam2.get_action_with_tag("item_pickup") then return end
	--if have body search in queue don't pickup items. Body search have priority
	if lam2.get_action_with_tag("body_search") then return end

	local hand, anm_name
	local id 	= mark.id
	local wpn 	= db.actor:active_slot() ~= 0
	local det 	= db.actor:active_detector() or nil
	local rhf 	= (not wpn and not liz_fdda_redone_item_pickup.is_hand_busy(0)) == true and true or false
	local lhf 	= (not det and not liz_fdda_redone_item_pickup.is_hand_busy(1)) == true and true or false

	if rhf and lhf then
		hand = math.random(0,1)
		local al = {
			[0] = "anm_ea_taker",
			[1] = "anm_ea_takel"
		}
		anm_name = al[hand]
	elseif rhf then
		hand = 0
		anm_name = "anm_ea_taker"
	elseif lhf then
		hand = 1
		anm_name = wpn and "anm_ea_takelw" or "anm_ea_takel"
	elseif wpn and det then
		hand = 1
		anm_name = wpn and "anm_ea_takelw" or "anm_ea_takel"
	else
		return
	end

	liz_fdda_redone_item_pickup.set_hand_busy(hand, 1)

	local action = lam2.get_template_action_play_animation()
	action.tag = "item_pickup"
	action.name = "item_pickup_" .. hand
	action.hands = hand
	action.sec = "item_ea_take_hud"
	action.anm = anm_name
	action.anm_blend = true
	action.speed = cfg.fddar_pickup_speed or 1.2
	action.on_enter = function (self)
		liz_fdda_redone_item_pickup.set_hand_busy(self.hands, self.duration)
	end
	action.on_execute = function (self, time)
		if time > self.duration / 2 then
			if self.on_take then self:on_take() end
		end
		if time > self.duration / 2 then
			if self.is_short then
				return lam2.states.success
			end
		end
	end
	if id then
		action.on_take = function(self)
			if mark.is_glowstick and zz_glowstick_mcm then
				take_glowstick(id)
			elseif not mark.physics_obj then
				local obj = get_game_object(id)
				force_actor_to_take(obj, true)
			end
		end
	end
	local current_pickup_action = lam2.get_action_with_tag("item_pickup")
	if current_pickup_action then current_pickup_action.is_short = true end
	--]]
	lam2.add_action(action)
	return true
end

function get_inventory_table(box, id)
	-- Streamlined version of the one in axr_companions
	box = box or (id and get_game_object(id))
	local t = {}
	local i = 0
	if box then
		id = id or box:id()
		local function iterate(owner, item)
			i = i + 1
			local item_id = item:id()
			local item_sec = item:section()
			t[item_id] = item_sec
		end
		iterate_any_inventory(box, iterate)
	end
	return t, i
end

function deploy_backpack(backpack)
	local pos = backpack and backpack:position()
	if not pos then return end
	local actor = db.actor
	local se_obj = actor and alife_create("inv_backpack", pos, actor:level_vertex_id(), actor:game_vertex_id())
	local section = backpack:section()
	if (se_obj and section) then
		local txt = string.format(gts("st_itm_stash_of_character"), db.actor:character_name())
		level.map_add_object_spot_ser(se_obj.id, "treasure", txt)
		actor_menu.set_msg(1, gts("st_stash_created"),4)
		
		local m_data = alife_storage_manager.get_state()
		if not (m_data.player_created_stashes) then 
			m_data.player_created_stashes = {}
		end
		
		m_data.player_created_stashes[se_obj.id] = section
		
		alife_release(backpack)
	end
end

function remove_placed_backpack(id)
	if not id then return end
	level.map_remove_object_spot(id, "treasure")
	local se_obj = alife_object(id)

	if se_obj then
		alife_release(se_obj)
	end
	
	local m_data = alife_storage_manager.get_state()
	if (m_data.player_created_stashes and m_data.player_created_stashes[id]) then 
		local section = m_data.player_created_stashes[id]
		alife_create_item(section, db.actor)
		m_data.player_created_stashes[id] = nil
	end
	return true
end

function iterate_any_inventory(box, func)
	if not (box and func) then return end
	if IsStalker(nil, box:clsid()) then
		box:iterate_inventory(func)
	else
		box:iterate_inventory_box(func)
	end
end

function cheapest_medical_help_owned(who)
	who = who or db.actor
	if not who then return end
	local medkit
	local medhelp = {
		[1] = "medkit",
		[2] = "medkit_army",
		[3] = "medkit_scientic",
		[4] = "stimpack",
		[5] = "stimpack_army",
		[6] = "stimpack_scientic"
	}
	for i = 1, #medhelp do
		medkit = medhelp[i]
		if medkit and who:object(medkit) then
			return medkit
		end
	end
end

function actor_aid_item_count(section)
	if not db.actor then return end
	local num_owned = section and utils_item.get_amount(db.actor, section, 1) or 0
	return num_owned   
end

function try_init_heal_anim(npc, mark, exec_func)
	end_mark_wounded_state(mark)
	anim_playing 			= true
	cfg.hidden_before_anim 	= mark.hidden
	mark.hidden 			= true
	if npc and exec_func and cfg.sec_enable_heal_anim and not cfg.healing_stalker then
		if zzz_wounded_heal_anim then
			cfg.healing_stalker = npc:id()
			zzz_wounded_heal_anim.use_injector(npc)
		end
		return true
	end
end

function heal_anim_end()
	local id = cfg.healing_stalker
	local npc = id and get_game_object(id)
	local mark = id and cfg.markers[id]
	if not (npc and mark) then return end
	help_wounded_stalker(npc, mark, true)
end

function help_wounded_stalker(npc, mark, skip_anim_check)
	if not mark then return end
	if (not skip_anim_check) and try_init_heal_anim(npc, mark, help_wounded_stalker) then
		vl("[%s] help_wounded_stalker: search anim check, not processing on this call", time_global())
		return true
	end
	mark.hidden 			= cfg.hidden_before_anim
	anim_playing 			= false
	cfg.hidden_before_anim 	= nil
	if not (npc and mark) then return true end
	local medkit    		= cheapest_medical_help_owned()
	local count     		= medkit and actor_aid_item_count(medkit)
	if (not count) or (count < 1) then return true end
	alife_create_item("medkit_script", npc)
	xr_wounded.unlock_medkit(npc)
	game_statistics.increment_npc_statistic(db.actor, "wounded_helped")
end


function hijack_autoloot_keybind()
	if z_auto_looter and cfg.takeall_does_autoloot and cfg.hijack_autoloot_keybind then
		z_auto_looter.config.looter_key = cfg.autoloot_hijack_value
	end
end

function can_play_search_anim(mark)
	if not mark then return end
	vl("can_play_search_anim | %s | stalker %s | container %s", nameid(mark.name, mark.id), mark.is_stalker, mark.is_container)
	if not (cfg.fddar_body_search and cfg.search_anim_on_takeall) then return end
	if mark.is_stalker then return true end
	if cfg.fddar_container_search and mark.is_container then return true end
end

function try_init_search_anim(box, mark, exec_func)
	if box and exec_func and can_play_search_anim(mark) then
		local action_start = fddar_bodysearch.get_template_action_looting_start(box)
		action_start.is_show_ui = true
		lam2.add_action(action_start)
		local action_idle = fddar_bodysearch.get_template_action_looting_idle(box)
		set_loot_window_flag(time_global(), "anim start")
		action_idle.on_execute = (
			function (self, time)
				if npc_loot_claim and npc_loot_claim.actor_looting_claimed then
					self.force_close = true
				end
				if self.force_close or (time > self.ui_open_delay) or lam2.has_queued_actions() then
					if not self.is_input_enabled then
						self.is_input_enabled = true
						if cfg.fddar_disable_walk then level.enable_input() end
					end
					if haru_skills then fddar_bodysearch.haruka_scavanger_effect() end
					self.force_close = true
					local action_stop = fddar_bodysearch.get_template_action_looting_end()
					lam2.add_action_first(action_stop)
					return lam2.states.success
				end
				return lam2.states.running
			end
		)
		lam2.add_action(action_idle)
		CreateTimeEvent("dotmarks_fddar_takeall", 0, 0.25, (
			function()
				if (not anim_playing) then
					exec_func(box, mark, true)
					set_loot_window_flag(nil, "anim complete")
					return true
				end
			end
		))
		return true
	end
end

function update_mark_after_autoloot(obj)
	local id = obj and obj:id()
	mark = id and cfg.markers[id]
	if not mark then return end
	mark.autolooted = true
	if mark.alt_interact then
		mark.alt_interact.args.func = take_all_from_box
		mark.alt_interact.args.name = string.format("%s %s", first_upper( gts("st_alti_takeall") ), mark.name)
		mark.alt_interact:Prompt(mark.alt_interact.args.name)
		mark.alt_interact:SetPrompt()
	end
end

function try_init_disarm_anim(obj, mark, skip_anim_check)
	-- placeholder, no current anim will stand in for it
	-- maybe the two-handed take anim?
	return false
end

function remove_bomb(mark)
	if not (mark and mark.id and mark.is_disarmable) then return true end
	vl("Disarming %s and returning a copy of %s", mark.name, mark.inv_section)
	local se_obj 	= alife_create_item(mark.inv_section, db.actor)
	txr_mines._mines[mark.id] = nil
	unregister_scanned_entity(mark.id)
	alife_release_id(mark.id)
	return true 
end


function disarm_ied(obj, mark, skip_anim_check)
	dl("disarm_ied | obj %s | mark %s | en %s", obj, mark, cfg.enable_disarm_ied_act)
	if not (obj and mark and cfg.enable_disarm_ied_act) then return end
	if (not skip_anim_check) and try_init_bomb_anim(obj, mark, plant_bomb) then
		vl("[%s] disarm_ied: disarm anim check, not deploying on this call", time_global())
		return true
	end
	if mark.func_allow_interact then
		local flags = {ret_value = true}
		func_allow_interact(mark, flags)
		if not flags.ret_value then return true end
	end
	CreateTimeEvent(0, "release_planted_mine", cfg.defuse_obj_delay or 1, remove_bomb, mark)
end


function replace_invitem_with_bomb(obj, mode, delay)
	-- Essentially a variation of txr_mines.plant_bomb
	--vl("replace_invitem_with_bomb(%s,%s,%s)", obj and obj:name(), mode, delay)
	if not (obj and mode) then return end
	
	local now 		= get_time_elapsed()
	local used_sec 	= obj:section()
	local used_id 	= obj:id()
	local bomb_sec	= txr_mines.EXPLOSIVE_SECTION_LOOKUP[used_sec]
	local pos 		= obj:position()
	local lvid 		= obj:level_vertex_id()
	local gvid 		= obj:game_vertex_id()
	local bomb_obj 	= alife_create(bomb_sec, pos, lvid, gvid)
	local bomb_id 	= bomb_obj.id
	
	_ = txr_mines.FX_BY_SECTION[used_sec] and actor_effects.play_item_fx(txr_mines.FX_BY_SECTION[used_sec])
	
	local witnesses = {}
	for i in pairs(db.OnlineStalkers) do
		local id 	= db.OnlineStalkers[i]
		local npc 	= level.object_by_id(id)
		if npc and IsStalker(npc) and npc:alive() then
			if npc:see(db.actor) then
				-- NPC witnessed player plant bomb
				witnesses[id] = now + math.random(txr_mines.MIN_FORGET_TIME, txr_mines.MAX_FORGET_TIME) * level.get_time_factor()
			end
		end
	end
	txr_mines._mines[bomb_id] = {
		exp_time 	= now + (delay or txr_mines.FUSE_TIME) * level.get_time_factor(),
		mode 		= mode,
		witnesses 	= witnesses,
		active 		= true,
		mine_type 	= obj:section(),
		mine_freq 	= item_radio.get_freq()
	}
		
	CreateTimeEvent(0, "release_planted_mine", 0, txr_mines.release_item, used_id)

	if not cfg.rce_installed then return end
	-- For Remote Controlled Explosives compatibility
	if mode == cfg.mine_modes.MODE_REMOTE and item_radio.get_freq() then
		actor_menu.set_msg(1, gts("st_plant_explosive_remote_freq").. " ".. tostring(item_radio.get_freq()).. " MHz", 4)
		level.map_add_object_spot_ser(
			bomb_id,
			"alife_presentation_squad_monster_1",
			gts("st_plant_explosive_remote_map_marker_pt1") .. " ".. txr_mines.EXPLOSIVE_TYPE[obj:section()].. ", ".. gts("st_plant_explosive_remote_map_marker").. " ".. tostring(item_radio.get_freq()).. " MHz"
		)
	end
	if mode == cfg.mine_modes.MODE_PROX then
		level.map_add_object_spot_ser(
			bomb_id,
			"alife_presentation_squad_monster_1",
			gts("st_plant_explosive_proximity_map_marker") .. " ".. EXPLOSIVE_TYPE[obj:section()]
		)
	end
	if mode == cfg.mine_modes.MODE_TIMER then
		level.map_add_object_spot_ser(
			bomb_id,
			"alife_presentation_squad_monster_1",
			gts("st_plant_explosive_timed_map_marker") .. " ".. EXPLOSIVE_TYPE[obj:section()]
		)
	end
end

function try_init_bomb_anim(obj, mark, skip_anim_check)
	-- placeholder, no current anim will stand in for it
	-- maybe the take anim? one or two handed?
	return false
end

function plant_bomb(ied, mark, skip_anim_check)
	if (cfg.mine_mode < 0) or not ied then return end
	if (not skip_anim_check) and try_init_bomb_anim(ied, mark, plant_bomb) then
		vl("[%s] plant_bomb: bomb anim check, not deploying on this call", time_global())
		return true
	end
	cfg.bomb_timer 	= cfg.bomb_timer or 30
	local timer 	= (cfg.mine_mode ~= 0) and cfg.bomb_timer or nil
	vl("[%s] plant_bomb: mode %s | timer %s", time_global(), cfg.mine_mode, cfg.bomb_timer)
	replace_invitem_with_bomb(ied, cfg.mine_mode, timer)
	return true
end

function trigger_autoloot(box, mark, skip_anim_check)
	vl("[%s] trigger_autoloot | %s | skip_anim_check %s", time_global(), nameid(box), not not skip_anim_check)
	if not (zz_autoloot_dotmarks and z_auto_looter and z_auto_looter.auto_looter) then return true end
	local id = box and box:id()
	if not id then return true end
	if is_body_claimed(id) then return true end
	if (not skip_anim_check) and try_init_search_anim(box, mark, trigger_autoloot) then
		vl("[%s] trigger_autoloot: search anim check, not processing inv on this call", time_global())
		return true
	end

	dl("[%s] Calling Auto Looter for %s", time_global(), nameid(box))
	zz_autoloot_dotmarks.override_id = id
	hijack_autoloot_keybind()
	z_auto_looter.auto_looter(z_auto_looter.config.looter_key)
	return true
end

function take_all_from_box(box, mark, skip_anim_check)
	vl("take_all_from_box | %s | skip_anim_check %s", nameid(box), not not skip_anim_check)
	if not box then return end
	if (not skip_anim_check) and try_init_search_anim(box, mark, take_all_from_box) then
		return true
	end
	local id = box:id()
	if is_body_claimed(id) then return true end

	local function itr_inv(temp, item)
		box:transfer_item(item, db.actor)
		SendScriptCallback("actor_on_item_take_from_box", box, item)
	end
	iterate_any_inventory(box, itr_inv)
	if cfg.markers[id] then
		cfg.markers[id].has_items = false
	end
	utils_obj.play_sound("interface\\items\\inv_items_take_all")
	return true
end


function pick_up_backpack(obj)
	local id = obj and obj:id()
	if not id then return end

	local data = {
		stash_id = id,
		cancel = false,
	}
	SendScriptCallback("actor_on_stash_remove",data)
	if data.cancel then
		return
	end

	if not obj:is_inv_box_empty() then
		take_all_from_box(obj)
	end
	
	CreateTimeEvent("bp_take_all", 0, 0.05, remove_placed_backpack, id)
end


function eject_mag_from_ground(wpn)
	-- Largely adapted from the similar eject function in Mags Redux
	if not mags_installed then return end
	if wpn:weapon_in_grenade_mode() or not magazine_binder.is_supported_weapon(wpn) then return end
	local id = wpn:id()

	magazine_binder.validate_wep(id)
	
	local mag_data = magazine_binder.get_mag_loaded(id)
	
	if mag_data then
		wpn:force_unload_magazine(false)
		wpn:unload_magazine()
		if magazines.retain_round(wpn) and #mag_data.loaded > 0 then
			vl("retaining round of type %s in chamber", stack.peek(mag_data.loaded))
			stack.pop(mag_data.loaded)
			wpn:set_ammo_elapsed(1)
		else
			wpn:set_ammo_elapsed(0)
		end
		
		se_mag = alife_create_item(mag_data.section, db.actor)
		if se_mag then
			magazines.create_time_event("mag_redux", "timer_eject_"..id, 0, magazines.timer_eject_magazine, id, se_mag.id, mag_data)
		else
			dl("Could not create magazine %s", mag_data.section)
		end
		magazine_binder.set_data(id, {
			section     = "no_mag",
			loaded      = {},
			is_weapon   = true,
		})
		magazine_binder.dump_data(mag_data)
		return se_mag.id
	end
end

function unload_and_take_ammo(wpn)
	if not (wpn and IsWeapon(wpn)) then return end
	local count = wpn:get_ammo_in_magazine()
	if count < 1 then return end
	local atype = wpn:get_ammo_type() + 1
	local ammos = parse_list(ini_sys, wpn:section(), "ammo_class")
	local sec   = ammos and atype and ammos[atype]
	
	if mags_installed then
		vl("Ejecting magazine with %s rounds of %s from %s and giving the mag to actor", count, sec, wpn:name())
		eject_mag_from_ground(wpn)
	else
		vl("Unloading %s rounds of %s from %s and giving the ammo to actor", count, sec, wpn:name())
		alife_create_item(sec, db.actor, {ammo = count})
		wpn:unload_magazine()
	end

	local id = wpn:id()
	cfg.markers[id].ammo_count = 0
end

function unpack_batteries(obj)
	-- like in item_device.func_battery, except without the parent check
	local sec   = obj:section()
	local con   = obj:condition()
	local batt  = item_device.device_battery
	local id    = obj:id()
	local dead  = 0.0001
	if ini_sys:section_exist(batt) then
		-- Create new battery for actor and process old one
		alife_create_item(batt, db.actor, {cond = con})
		alife_process_item(sec, id, {cond = dead})
		actor_effects.play_item_fx(batt)
		utils_obj.play_sound("interface\\inv_batt")
	end
	local mark = id and cfg.markers[id]
	if not (mark and mark.use_pri) then return end
	mark.condition = dead
	mark.use_pri:SetConditionText(sec, dead)
	mark.use_pri:SetPrompt()
end

--function is_obj_interact_dist(obj)
	--return is_in_range(obj and obj:id())
	--if not (obj and db.actor) then return end
	--local pos = obj:center()
	--return pos and (pos:distance_to(db.actor:center()) <= (cfg.obj_interact_dist or 2.5))
--end


function prompt_blocked_by_anim()
	if (not anim_playing) then
		return false
	end
	return not cfg.show_prompt_during_anim
end

function do_consume_action(id, manual_use)
	local obj = id and get_game_object(id)
	if not obj then return true end
	if (anims_enabled and not manual_use) then
		local _ = debug_dump and vl("[%s] passing consume action of %s to FDDA", time_global(), nameid(obj, id))
		SendScriptCallback("actor_on_item_before_use", obj, {ret_value = true})
	else
		local _ = debug_dump and vl("[%s] causing actor to consume/use %s", time_global(), nameid(obj, id))
		db.actor:eat(obj)
	end
end

function delay_action_for_anim(args)
	args = args or {}
	local id        = args.id
	local manual_use= args.manual
	local functor   = args.func
	vl("[%s] delay_action_for_anim start: id %s | manual %s | functor passed: %s", time_global(), id, manual, not not functor)
	if not (id and functor and (type(functor) == "function")) then return true end
	if not cfg.pending_actions[id] then
		-- Pending action record cleared, abort action
		return true
	end

	local timed_out = false
	if time_global() > cfg.pending_actions[id] then
		cfg.pending_actions[id] = nil
		timed_out = true
		-- Pending action timed out, execute action
	end
	
	if fdda_callback and anim_playing and not timed_out then
		return
	end
	if not functor then return true end
	functor(id, manual_use)
	return true
end

function force_actor_to_take(obj, skip_anim)
	if not obj then return end
	vl("Forcing actor to take %s via active pickup callback", obj and obj:name())
	local send_pickup_callback = fdda_callback or item_pickup_intercept
	send_pickup_callback(obj, {force = true, ret_value = true, skip_anim = skip_anim})
end

function take_and_use(obj)
	if not (obj and db.actor) then return end
	local id = obj:id()
	force_actor_to_take(obj)
	if id then
		cfg.pending_actions[id] = time_global() + (cfg.item_use_timeout or 0)
		local manual_use = is_item_manual_use(obj)
		local args = {
			id = id,
			manual = manual_use,
			func = do_consume_action,
		}
		CreateTimeEvent("delayed_actor_use", time_global(), cfg.item_use_delay, delay_action_for_anim, args)
	end
end

function is_item_manual_use(obj, mark)
	local id    = obj and obj:id()
	local mark  = mark or (id and cfg.markers[id]) or {}
	local sec   = mark.section or (obj and obj:section())
	return mark.manual_use or cfg.manual_use[sec]
end

function delay_read_action(id)
	if fdda_callback and anim_playing then return end
	local obj = id and get_game_object(id)
	item_recipe.func_recipe(obj)
	return true
end

function take_and_read(obj)
	if not (obj and db.actor) then return end
	force_actor_to_take(obj)
	local id = obj and obj:id()
	if id then
		CreateTimeEvent("delayed_actor_use", time_global(), cfg.item_use_delay, delay_read_action, id)
	end
end

function handle_secondary_interact(obj)
	if prompt_blocked_by_anim() then
		local _ = debug_dump and vl("Actor tried to interact but is busy with another item animation")
	return end

	-- Get target object and do validation checks
	local id = get_current_target()
	obj = obj or (id and get_game_object(id))
	--if not is_obj_interact_dist(obj) then return end
	local mark = cfg.markers[id]
	if not is_in_range(id, nil, mark) then return end
	local prompt = mark and mark.alt_interact
	if cfg.prompt_busy_during_anim and prompt and prompt.busystate then return end

	-- Passed validation - identify handler, if any
	if IsWeapon(obj) then
		unload_and_take_ammo(obj)
	elseif (IsItem("eatable", obj:section())) then
		take_and_use(obj)
	elseif mark.hf_workshop then
		-- Do nothing, it opens its own menu
	else
		take_and_use(obj)
	end
end

function on_item_use_anim_start()
	anim_playing = true
end

function on_item_use_anim_stop()
	anim_playing = false
end

function cycle_targeted_pickup(dir)
	vl("cycle_targeted_pickup: %s | locked %s | target %s", dir and (dir > 0) and "next" or "previous", locked_id, targeted_id)
	if not (dir and get_current_target()) then return end
	local max       = size_table(nearby_pickups)
	local _ = debug_dump and vl("max %s | in_pickup_range %s", max, size_table(cfg.in_pickup_range))
	if (max < 2) or is_empty(cfg.in_pickup_range) then return end
	local id_curr   = get_current_target()
	local ind_curr  = pickup_index[id_curr] or 1
	local ind_new
	if (dir > 0) then
		ind_new     = (ind_curr < max) and (ind_curr + 1) or 1
	else
		ind_new     = (ind_curr > 1) and (ind_curr - 1) or max
	end
	locked_id       = nearby_pickups[ind_new]
	local _         = ind_new and (ind_new ~= ind_curr) and play_snd_path(cfg.snd_path_blip)
	vl("Pickup cycled | prev ind %s id %s | new ind %s id %s", ind_curr, nearby_pickups[ind_curr], ind_new, locked_id)
end

function reset_nearby_item_tables()
	actor_moved     = true
	locked_id       = nil
	cfg.last_pickup = nil
	nearby_pickups  = {}
	pickup_index    = {}
end

function update_actor_move_state()
	if not db.actor then return end
	actor_moving = (level.actor_moving_state() > 0)
	if actor_moving then
		if not cfg.last_actor_pos then
			cfg.last_actor_pos = db.actor:position()
		end
		local dist = db.actor:position():distance_to(cfg.last_actor_pos)
		actor_moving = dist > (cfg.actor_move_threshold or 0.1)
	end
	return actor_moving
end

function update_nearby_pickups()
	if update_actor_move_state() then
		reset_nearby_item_tables()
		return true
	end

	if is_empty(cfg.in_pickup_range) then return end
	cfg.last_pickup = cfg.available_pickup
	if not is_empty(nearby_pickups) then return end
	-- pickup tables haven't been updated since actor stopped moving

	local i = 1
	for k,v in spairs(cfg.in_pickup_range) do
		if mark_is_shown(k) then
			nearby_pickups[i] = k
			pickup_index[k] = i
			i = i + 1
		end
	end
	actor_moved = false
end

function setup_tutorial_prompt(tutorial)
	dl("Need to set up a new interact UI for tutorial %s", tutorial)
	local args = get_cfg_for_type("args", "Tutorials") or {}
	args.tutorial           = tutorial
	args.fixed              = true
	args.anchor             = maingameui
	args.active_prompt      = trimmed_prompt(gts(cfg.tutorial_hints[tutorial]))
	args.logged_type        = "tutorial prompt"
	cfg.markers[tutorial]   = setup_pri_interact_prompt(maingameui, args)
end

function dump_monitor_states()
	for k,v in pairs(cfg.monitors) do
		dump("State monitor for %s: %s", k, state_monitor(k))
	end
end

function check_tutorial_states()
	if cfg.tutorial_hints and is_not_empty(cfg.tutorial_hints) then
		if game.has_active_tutorial() then
			cfg.tutorials_cleared = false
		elseif (not cfg.tutorials_cleared) then
			for k,v in pairs(cfg.tutorial_hints) do
				if cfg.markers[k] then
					destroy_prompt(k, "destroying orphaned tutorial prompt")
				end
			end
			cfg.tutorials_cleared = true
		end
	end
end

function start_tutorial_prompt(tutorial, text, flags)
	vl("Tutorial start callback for %s: %s", tutorial, text)
	cfg.monitors[tutorial] = state_monitor(tutorial)
	if cfg.monitors[tutorial] then
		flags.ret_value = not cfg.hide_van_interact_ui
		cfg.tutorials_cleared = false
		if cfg.markers[tutorial] then
			cfg.markers[tutorial]:ShowPrompt(true)
		else
			setup_tutorial_prompt(tutorial)
		end
	end
end

function stop_tutorial_prompt(tutorial, text, flags)
	vl("Tutorial stop callback for %s, shutting down prompt", tutorial)
	cfg.monitors[tutorial] = false
	if cfg.markers[tutorial] then
		destroy_prompt(tutorial, "ending inactive tutorial via callback")
	end 
end

function update_skill_bonus_range()
	local skill = haru_skills and cfg.haru_skill_name and haru_skills.skills_levels[cfg.haru_skill_name]
	local sklev = skill and skill.current_level or 0
	cfg.skill_bonus_range = sklev * (cfg.haru_skill_coef or 0)
	return cfg.skill_bonus_range
end

function do_garbage_collection()
	local now = time_global()
	if cfg.pending_actions and not is_empty(cfg.pending_actions) then
		for k,v in pairs(cfg.pending_actions) do
			if now > (tonumber(v) or 0) then
				cfg.pending_actions[k] = nil
			end
		end
	end
	if cfg.block_loot_window then
		if (now - cfg.block_loot_window) > 3000 then
			vl("cfg.block_loot_window has been set for longer than 3 seconds, clearing")
			set_loot_window_flag(nil, "timeout")
		end
	end
end

function update_hint_filters()
	if not (cfg.hint_filter and cfg.hint_filter.enabled) then return end
	local hint = cfg.hint_filter.last_raw_text
	if is_empty(cfg.hint_filter.enabled) then return end
	local text = cfg.hint_filter.update_text()
	if not text then return end
	--dump("[%s] Hint filter update%s", time_global(), text and (" - text is: "..text) or ", no text")
end

local function perform_debugging_checks()
	dump("last target: %s | crosshair %s", hmm.last_target, hmm.last_crosshair)
end

-- =======================================================================
--      MAIN SCAN LOOP
-- =======================================================================
function actor_on_update()
	--perform_debugging_checks() -- only uncommented when needed
	if not scanning then return end
	do_garbage_collection()
	update_hint_filters()
	cfg.actor_comm  = character_community(db.actor):sub(7)
	-- ===================================================================
	--  Tutorial monitors
	--  Watches for state flags set by modxml_tutorial_hooks.script
	--  Mostly cleanup now that tutorials are handled via callbacks
	-- ===================================================================
	if cfg.tut_check_interval then
		if (next_tut_check <= time_global()) then
			next_tut_check = get_next_tg_interval(cfg.tut_check_interval)
			dotmarks_main.in_sleep_zone = is_actor_in_sleep_zone()
			check_tutorial_states()
		end
	end
	-- ===================================================================
	--  Update nearby pickup items and identifies current/locked target
	--  Accuracy is critical, should happen as often as possible
	-- ===================================================================    
	update_nearby_pickups()
	if locked_id then
		local _ = debug_dump and vl("locked_id is %s, skipping target updates and scans", locked_id)
		return
	end
	update_targeted_object()
	-- ===================================================================
	--  Skill system updates
	--  Rare, skillups don't occur often
	--  Needs to run before near_scan so that it applies radius changes
	-- ===================================================================
	if cfg.skill_upd_interval then
		if (next_skill_upd <= time_global()) then
			next_skill_upd  = get_next_tg_interval(cfg.skill_upd_interval)
			update_skill_bonus_range()
		end
	end
	-- ===================================================================
	--  Near scan - iterate objects within near_scan_radius
	--  This quickly picks up newly-spawned or dropped objects
	--  Frequent
	-- ===================================================================
	if cfg.near_scan_interval then
		if (next_near_scan <= time_global()) then
			next_near_scan   = get_next_tg_interval(cfg.near_scan_interval)
			scan_nearby_entities(near_scan_radius())
		end
	end
	-- ===================================================================
	--  Early scan - iterate within near_scan_radius + early_scan_radius
	--  Instantiates markers for objects before they would become visible
	--  Less frequent
	-- ===================================================================
	if cfg.early_scan_interval then
		if (next_early_scan <= time_global()) then
			next_early_scan   = get_next_tg_interval(cfg.early_scan_interval)
			scan_nearby_entities(early_scan_radius())
		end
	end
end

-- =======================================================================

function targeted_deployable_bomb()
	local id = get_current_target()
	local mark = id and cfg.markers[id]
	return mark and mark.placeable_mine and id or nil
end

function on_before_key_press(key, bind, dis, flags)
	if cfg.watch_use and (key == use_dik) then
		cfg.use_released = nil
		set_loot_window_flag(time_global(), "key press")
		--dump("[%s][on_before_key_press] Beginning hold of key %s", time_global(), key)
		cfg.held_key = key
		local id = get_current_target()
		if not id then return end
		local mark = cfg.markers[id]
		if not (mark and mark.is_stalker and mark.is_wounded) then return end
		flags.ret_value = false
	end
end

function do_use_release_action_manually(id)
	local obj = get_game_object(id)
	local mark = id and cfg.markers[id]
	-- Target exists, no completed hold action
	if is_target_pickup(id) and ((id == locked_id) or not locked_id) then
		cfg.use_released = nil
		dump("[%s] No completed hold action, item pickup should occur", time_global())
		force_actor_to_take(obj)
	elseif is_target_container(id, obj:clsid()) then
		dl("[%s] No completed hold action, target is a container", time_global())
		if is_body_claimed(id) then
			if cfg.grok_claim then
				vl("Calling Grok loot claim")
				local dik = bind_to_dik(key_bindings.kUSE)
				local flags = {ret_value = true}
				grok_loot_claim.on_before_key_press(dik, key_bindings.kUSE, nil, flags)
				if not flags.ret_value then return end
			else
				vl("Calling NPC loot claim")
				npc_loot_claim.actor_looting(obj)
				if npc_loot_claim.actor_looting_claimed then return end
				vl("Loot claim passed, looting")
			end
		end

		if z_ui_inventory_dotmarks then
			dl("[%s] No completed hold action, allow inventory interaction with %s", time_global(), obj:name())
			cfg.use_released = nil
			obj:use(db.actor)
		else
			alert("ERROR! z_ui_inventory_dotmarks could not be found, please reinstall DotMarks")
		end
	elseif mark and mark.is_stalker and mark.is_wounded then
		dl("Forcing actor to talk with wounded NPC")
		cfg.use_released = nil
		xr_effects.force_talk(db.actor, obj, {true})
	else
		vl("No manual action found for %s, assume engine will handle it", nameid(obj, id))
	end
end

function on_key_release(key)
	set_loot_window_flag(nil, (key == use_dik) and "released use key")
	if key == cfg.held_mod then cfg.held_mod = nil end
	if (key == cfg.held_key) then
		if (key == use_dik) then
			cfg.held_key = nil
			cfg.use_released = cfg.use_released or time_global()
			local id = get_current_target()
			if not id then return end
			local dur = cfg.holding and cfg.holding.peak_hold
			local time = cfg.holding and cfg.holding.hold_time
			local can_trigger_action = not (dur and time and (dur >= time))
			local action_text = (DEV_DEBUG or debuglogs or debug_dump) and can_trigger_action and ", checking for action" or ", no action to trigger"
			dump("[%s] use key released%s | set at %s | dur held %s | hold time %s", time_global(), action_text, cfg.use_released, dur, time)
			if can_trigger_action then
				do_use_release_action_manually(id)
			end
		end
	end
end

function actor_on_update_pickup(obj)
	cfg.update_pickup_firing = true
	cfg.last_pickup = cfg.available_pickup
	cfg.available_pickup = obj and obj:id() or nil

	if cfg.last_pickup and cfg.available_pickup and (cfg.last_pickup ~= cfg.available_pickup) then
		reset_nearby_item_tables()
	end
end

function actor_on_item_take(obj)
	local id = obj and obj:id()
	if id and cfg.markers[id] then
		dump("Actor just took %s, unregistering scanned object", nameid(obj, id))
		unregister_scanned_entity(id)
	end
end

function remove_obj_from_box_table(box, item)
	if not (box and item) then return end
	local b_id = box:id()
	if not cfg.invboxes[b_id] then return end
	if not cfg.invboxes[b_id].items then
		cfg.invboxes[b_id].items = {}
	end
	local i_id = item:id()
	cfg.invboxes[b_id].items[i_id] = nil

	local mark      = cfg.markers[b_id] or {}
	local was_items = mark.has_items
	local num_items = size_table(cfg.invboxes[b_id].items)
	mark.has_items  = num_items > 0
	vl("remove_obj_from_box_table completed for %s <- %s", item:name(), box:name())
end

function add_obj_to_box_table(box, item)
	if not (box and item) then return end
	local b_id = box:id()
	if not cfg.invboxes[b_id] then
		cfg.invboxes[b_id] = {}
	end
	if not cfg.invboxes[b_id].items then
		cfg.invboxes[b_id].items = {}
	end
	local i_id      = item:id()
	local sec       = item:section()
	cfg.invboxes[b_id].items[i_id] = sec

	local mark      = cfg.markers[b_id] or {}
	mark.has_items  = true
	vl("add_obj_to_box_table completed for %s -> %s", item:name(), box:name())
end

function ActorMenu_on_item_after_move(box_id, item, mode, bag_from)
	vl("ActorMenu_on_item_after_move: box %s | item %s | bag_from %s", box_id, nameid(item), bag_from)
	if (mode == 2) or (mode == "loot") then
		local box = box_id and get_game_object(box_id)
		if (bag_from == 7) or (bag_from == "npc_bag") then
			remove_obj_from_box_table(box, item)
		else
			add_obj_to_box_table(box, item)
		end
	end
end

function handle_npc_death(npc)
	local id = npc and npc:id()
	if not (id and cfg.markers[id]) then return end
	vl("NPC %s has died, unregistering them and re-registering as corpse object", nameid(npc))
	unregister_scanned_entity(id)
	scan_nearby_object(npc)
end

function ignore_mouse_wheel()
	return (
		axr_main.scoped_weapon_is_zoomed or
		axr_main.binoc_is_zoomed or
		actor_menu.inventory_opened() or
		item_device.is_pda_active() or
		(ui_workshop.GUI and ui_workshop.GUI:IsShown())
	)
end

function on_mouse_wheel(scroll_dir, flags)
	local id = get_current_target()
	if (not cfg.wheel_cycles_pickups) then return end
	if (not id) or ignore_mouse_wheel() then return end
	local direction         = (scroll_dir > 0) and 1 or -1
	local _ = debug_dump and vl("on_mouse_wheel: %s | direction: %s", scroll_dir, direction)
	cycle_targeted_pickup(direction)
	flags.ret_value         = false
end

function on_before_level_changing()
	dl("Shutting down for level change")
	shut_down()
end

function parse_color_data(color_key, csv_string)
	if not (color_key and csv_string) then return end
	local c         = csv_argb_to_tbl(csv_string)
	cfg.colors[color_key]   = c
	local str       = string.format("%" .. "%c[%s,%s,%s,%s]", c.a, c.r, c.g, c.b)
	set_color_token(color_key, str)
	return c
end

function parse_file_data()
	local ini_cfg = ini_file_ex(dotmarks_config_file)
	for k,_ in pairs(cfg.reset_table) do
		local ver = tonumber(k)
		local res = "reset_" .. tostring(k)
		cfg.version_resets[ver] = ini_cfg:collect_section(res)
	end
	cfg.mine_mode = clamp(cfg.sec_mode_setupthebomb or 0, -1, 2)
	cfg.rce_installed = not not txr_mines.func_remote_plant
	for k,v in pairs (txr_mines.EXPLOSIVE_SECTION_LOOKUP) do
		cfg.disarmables[v] = k
	end
	if cfg.colors then
		for k,v in pairs(cfg.colors) do
			if k:find("clr_") then
				parse_color_data(k, v)
			else
				cfg.colors[k]   = nil
			end
		end
	end
	cfg.weight_colors = {
		[0] = "clr_weight_ok",
		[1] = "clr_weight_high",
		[2] = "clr_weight_over"
	}
	cfg.show_part_condition     = (cfg.show_parts_weapons or cfg.show_parts_armor)
	cfg.color_icon_itemcard     = clr_tbl(cfg.color_icon_itemcard)
	cfg.unsquish_ratio          = utils_catspaw_hudmarks.update_unsquish_ratio() or 1
	cfg.unsquish                = (function(w) return (w or 0) * (cfg.unsquish_ratio or 1) end)
	local ini_mutant            = ini_file("items\\settings\\mutant_loot.ltx")
	cfg.mutant_decay_time       = ini_mutant:r_float_ex("mutant_loot_mod","decay_time") or 7200
	local factions      = game_relations.factions_table
	local ini_fac       = ini_file_ex("plugins\\faction_profile.ltx")
	cfg.notable_npcs    = {}
	cfg.vendors         = cfg.vendors or {}
	for _,fac in pairs(factions) do
		local fd = ini_fac:collect_section(fac)
		cfg.notable_npcs[fac] = {
			leader      = fd.leader,
			trader      = fd.trader,
			mechanic    = fd.mechanic,
			medic       = fd.medic,
			barman      = fd.barman,
			guide       = fd.guide
		}
		if fd.leader then   cfg.vendors[fd.leader]    = "leader" end
		if fd.trader then   cfg.vendors[fd.trader]    = "trader" end
		if fd.mechanic then cfg.vendors[fd.mechanic]  = "mechanic" end
		if fd.medic then    cfg.vendors[fd.medic]     = "medic" end
		if fd.barman then   cfg.vendors[fd.barman]    = "barman" end
		if fd.guide then    cfg.vendors[fd.guide]     = "guide" end
	end
	if debug_dump then
		vl("Loaded NPC vendors:")
		for k,v in pairs(cfg.vendors) do
			vl("|| %s = %s", k,v)
		end
	end
	hintfilters = cfg.hint_filter
	cfg.grok_claim = not not grok_loot_claim
end

function set_item_pickup_callbacks(kill)
	if kill or killswitch("pickup") then
		UnregisterScriptCallback("actor_on_item_before_pickup", item_pickup_intercept)
	elseif not get_fdda_callback() then
		RegisterScriptCallback("actor_on_item_before_pickup", item_pickup_intercept)
		dl("No form of FDDA installed, registering internal pickup callback")
		cfg.pickup_callback_set = true
	end
end

function set_item_anim_callbacks(kill)
	if lam2 and fddar_installed then
		if anims_enabled and not (kill or killswitch()) then
			if lam2.Subscribe then
				dl("Subscribing FDDAR item animation callbacks")
				lam2.Subscribe("on_anim_queue_start", on_item_use_anim_start)
				lam2.Subscribe("on_anim_queue_stop", on_item_use_anim_stop)
			else
				RegisterScriptCallback("actor_on_update", fddar_update_current_anim_state)
			end
		else
			if lam2.Unsubscribe then
				dl("Unsubscribing FDDAR item animation callbacks")
				lam2.Unsubscribe("on_anim_queue_start", on_item_use_anim_start)
				lam2.Unsubscribe("on_anim_queue_stop", on_item_use_anim_stop)
			else
				UnregisterScriptCallback("actor_on_update", fddar_update_current_anim_state)
			end
		end
	elseif ea_callbacks and fdda_installed then
		if anims_enabled and not (kill or killswitch()) then
			dl("Registering FDDA item animation callbacks")
			ea_callbacks.EA_RegisterScriptCallback("ea_on_item_use", on_item_use_anim_start)
			ea_callbacks.EA_RegisterScriptCallback("ea_on_item_anim_stop", on_item_use_anim_stop)
		else
			dl("Unregistering FDDA item animation callbacks")
			ea_callbacks.EA_UnregisterScriptCallback("ea_on_item_use", on_item_use_anim_start)
			ea_callbacks.EA_UnregisterScriptCallback("ea_on_item_anim_stop", on_item_use_anim_stop)
		end
	end
end

function set_handler_callbacks(kill)
	if kill or killswitch() then
		UnregisterScriptCallback("actor_on_update", actor_on_update)
		UnregisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		UnregisterScriptCallback("on_key_release", on_key_release)
		UnregisterScriptCallback("on_before_key_press", on_before_key_press)
		UnregisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		UnregisterScriptCallback("on_tutorial_prompt_start", start_tutorial_prompt)
		UnregisterScriptCallback("on_tutorial_prompt_stop", stop_tutorial_prompt)
		if kill then
			UnregisterScriptCallback("on_option_change", on_option_change)
		end
	else
		RegisterScriptCallback("actor_on_update", actor_on_update)
		RegisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		RegisterScriptCallback("on_key_release", on_key_release)
		RegisterScriptCallback("on_before_key_press", on_before_key_press)
		RegisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		RegisterScriptCallback("on_tutorial_prompt_start", start_tutorial_prompt)
		RegisterScriptCallback("on_tutorial_prompt_stop", stop_tutorial_prompt)
	end
	set_item_pickup_callbacks(kill)
	set_item_anim_callbacks(kill)
end

local function log_other_addon_settings()
	if not debug_dump then return end
	vl("Loaded settings from other addons:\n"..
		"fddar/pickup/multipickup -> fddar_multipickup %s\n" ..
		"fddar/pickup/enable -> fddar_pickup_anim %s\n" ..
		"EA_settings/enable_animations -> fdda_anims_enabled: %s\n" ..
		"EA_settings/take_item_anim -> fdda_pickup_anim: %s\n" ..
		"item_icon_info/part_dots/show_on_wpn -> show_parts_weapons: %s\n" ..
		"item_icon_info/part_dots/show_on_armor -> show_parts_armor: %s\n" ..
		"item_icon_info/part_dots/wpo_green -> parts_wpo_grn: %s\n" ..
		"item_icon_info/part_dots/wpo_yellow -> parts_wpo_yel: %s\n" ..
		"item_icon_info/part_dots/wpo_orange -> parts_wpo_orn: %s",
		cfg.fddar_multipickup, cfg.fddar_pickup_anim,
		cfg.fdda_anims_enabled, cfg.fdda_pickup_anim,
		cfg.show_parts_weapons, cfg.show_parts_armor,
		cfg.parts_wpo_grn, cfg.parts_wpo_yel, cfg.parts_wpo_orn
	)
end

function on_option_change()
	local _ = debug_dump and vl("on_option_change() triggered at %s", time_global())
	dl("Iterating through settings and looking for MCM overrides\n" ..
		"+ You may see a burst of MCM warnings about bad paths during this process. These are completely harmless and should be ignored."
	)
	debuglogs   = get_mcm("dotmarks/dmarkadv/debuglogs", debuglogs)
	verbose     = get_mcm("dotmarks/dmarkadv/verbose", verbose)
	local log 	= (debuglogs or debug_dump or verbose or DEV_DEBUG)
	local _ 	= log and printf("Debug logging enabled: %s | verbose %s | debug_dump %s | DEV_DEBUG %s", debuglogs, verbose, debug_dump, DEV_DEBUG)
	local reset	= {}

	if not cfg.first_update then
		cfg.first_update = true
		local last_version = ui_mcm.get("dotmarks/dmarkmain/last_version")
		local last_release = ui_mcm.get("dotmarks/dmarkmain/last_release")
		if not last_release then
			_=log and printf("No previous DotMarks version information found in MCM, setting to current version")
		else
			local vtext = "Found MCM config from DotMarks version %s, rel %s"
			if tonumber(last_release) < release_date then
				vtext = vtext .. ", updating to v"..script_version.." release "..release_date
			end
			_=log and printf(vtext, last_version, last_release)
		end
		
		if cfg.version_resets then
			for rel, opts in pairs(cfg.version_resets) do
				if (not last_release) or (last_release < rel) then
					dump("Existing release %s is older than %s, adding opts to reset table", last_release, rel)
					for k,_ in pairs(opts) do
						dump("Will reset opt %s", k)
						reset[k] = true
					end
				end
			end
		end
		ui_mcm.set("dotmarks/dmarkmain/last_version", script_version)
		ui_mcm.set("dotmarks/dmarkmain/last_release", release_date)
	end

	vl("Loading config table")

	for k,v in pairs(cfg) do
		if type(v) ~= "table" then
			local mcm_path = cfg.mcm_paths[k]
			if mcm_path and mcm_path:find("/$") then
				mcm_path = mcm_path .. k
			end
			if mcm_path then
				if reset[k] then
					dl("Defaulting MCM value %s = %s (was %s)", k, v, get_mcm(mcm_path, cfg[k]))
					ui_mcm.set(mcm_path, v)
				else
					local foo = ui_mcm.get(mcm_path)
					cfg[k] = get_mcm(mcm_path, cfg[k])
					vl("Loading MCM value %s = %s", k, cfg[k])
				end
			else
				_ = debug_dump and vl("No MCM path found for %s, skipping", k)
			end
		end
	end
	if zz_autoloot_dotmarks then
		zz_autoloot_dotmarks.hijack_autoloot_keybind = cfg.hijack_autoloot_keybind
		cfg.keybind_hijack_value = zz_autoloot_dotmarks.keybind_hijack_value
	end
	log_other_addon_settings()

	if cfg.argb_dot_normal then
		parse_color_data("clr_dmark_norm", cfg.argb_dot_normal)
	end
	for k,v in pairs(cfg) do
		if k:find("^swap_") and v.load_argb then
			v.custom_argb = csv_argb_to_tbl(cfg[v.load_argb])

			if v.custom_argb then
				for i,j in pairs(v.custom_argb) do
				end
			end
			v.load_argb = nil
		end
	end

	for k,v in pairs(cfg.scan) do
		cfg.scan[k] = get_mcm("dotmarks/dmarkobjs/scan_" .. string.lower(k), cfg.scan[k])
		_ = debug_dump and vl("Scanning %s = %s", k, v)
	end

	if z_fdda_pickup_intercept_dotmarks then
		fddar_installed = (not not z_fdda_pickup_intercept_dotmarks.fddar_oibp)
		fdda_installed  = (not not z_fdda_pickup_intercept_dotmarks.fdda_oibp)
		anims_enabled   = (fddar_installed and cfg.fddar_pickup_anim) or (fdda_installed and cfg.fdda_pickup_anim and cfg.fdda_anims_enabled)
	end

	cfg.pending_actions = {}
	scanned             = {}
	use_dik             = bind_to_dik(key_bindings.kUSE)
	if cfg.bind_sec_interact == nil then
		cfg.bind_sec_interact = use_dik
	end
	cfg.watch_use   = (use_dik == cfg.bind_sec_interact) and not cfg.hide_sec_interact_ui
	if cfg.markers and not is_empty(cfg.markers) then
		for k,v in pairs(cfg.markers) do
			v:Destroy(nil, "reset after on_option_change")
		end
	end
	cfg.bind_fmprev = key_bindings.kWPN_FIREMODE_PREV
	cfg.bind_fmnext = key_bindings.kWPN_FIREMODE_NEXT
	reset_nearby_item_tables()
	set_handler_callbacks()
	st_kg           = gts("st_kg")
	CreateTimeEvent("autoloot_override", 0, 0.25, hijack_autoloot_keybind)
end

function on_game_start()
	local script_version = dotmarks_main and dotmarks_main.script_version
	local release_date = dotmarks_main and dotmarks_main.release_date
	printf("Interaction Dot Marks %s (rel %s) began initialization at %s",
		script_version or "(version not found)", release_date or "missing", time_global()
	)
	valid_mcm_version = dotmarks_mcm and dotmarks_mcm.valid_mcm_version
	local bad_mcm_version = (not valid_mcm_version) or not valid_mcm_version()
	RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
	-- This callback is always registered so that we can notify the player of init failure
	local base_failed = not init_base_config(dotmarks_config_file, { logging = debug_dump, called_by = script_name })
	if cfg and (not bad_mcm_version) then
		mags_installed = (magazines and magazine_binder)
		parse_file_data()
		RegisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
		RegisterScriptCallback("actor_on_item_take", actor_on_item_take)
		RegisterScriptCallback("ActorMenu_on_item_after_move", ActorMenu_on_item_after_move)
		RegisterScriptCallback("actor_on_item_take_from_box", remove_obj_from_box_table)
		RegisterScriptCallback("actor_on_item_put_in_box", add_obj_to_box_table)
		RegisterScriptCallback("actor_on_net_destroy", actor_on_net_destroy)
		RegisterScriptCallback("on_key_release", on_key_release)
		RegisterScriptCallback("on_before_key_press", on_before_key_press)
		RegisterScriptCallback("on_option_change", on_option_change)
		RegisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
		RegisterScriptCallback("npc_on_death_callback", handle_npc_death)
		RegisterScriptCallback("monster_on_death_callback", handle_npc_death)
		RegisterScriptCallback("on_before_level_changing", on_before_level_changing)
		if stealth_kill_detection then
			RegisterScriptCallback("npc_on_silent_kill_callback", handle_npc_death)
		end
		on_option_change()
		if (fdda_installed and fddar_installed) then
			alert("WARNING: Both FDDA and FDDA Redone scripts were found, but FDDA scripts should be disabled! Leaving them both active can lead to busyhands or other serious issues.")
		end
		return
	end

	local failmsg = ""
	if base_failed then
		cfg = nil
		failmsg = " to load base config from dotmarks_main"
	elseif bad_mcm_version then
		failmsg = string.format(" to detect MCM 1.7.0 or higher")
	elseif not cfg then
		cfg = nil
		failmsg = string.format(" to load config file %s", dotmarks_config_file)
	end
	alert("[%s] ERROR: Initialization failed%s!\n" ..
		"! DotMarks startup aborted, skipping callback registration", script_name, failmsg)
end
