-- =======================================================================
--[[    Interaction Dot Marks ("DotMarks")
    
    PRE-RELEASE TEST BUILD - THIS IS A WORK IN PROGRESS

-- ===================================================================--]]
script_name     = "ui_hud_dotmarks"
--[[======================================================================
    Author: Catspaw (CatspawMods @ ModDB)
    Source: https://github.com/CatspawMods/Anomaly-Addon-Archive

    I post gameplay video on my Youtube channel, Catspaw Adventures: 
    https://www.youtube.com/@CatspawAdventures
-- =======================================================================
    A blatant imitation of the "interaction dot" HUD markers in Stalker 2,
    and some of its other UI niceties such as floating prompts and 
    secondary interactions.

    Except not quite as cool, because Anomaly is jank. Hopefully this 
    makes it a little less jank.

    Also implements an "Alternate Interact" keybind with contextual 
    actions such as unloading a weapon without having to pick it up.
-- =======================================================================
    Requires modded exes by demonized:
    https://github.com/themrdemonized/xray-monolith

    If your version of the modded exes is earlier than 20250306, you will
    see this error in your log:

    ![axr_main callback_set] callback actor_on_update_pickup doesn't exist!

    If you are seeing that, you MUST update your version of the modded 
    exes in order for object targeting to work properly. If you think you
    have updated and are still seeing that error, you need to do a clean
    reinstall of the modded exes from scratch.

    If it's even older than that, some stuff may not work at all. You
    should update your modded exes ASAP.
-- =======================================================================
    TODO:
    -   Need to optimize and clean up a whole lot of WIP code
    -   Test with EVERY distinct type of item
    -   Keep an eye out for explodey things that aren't IsExplosive
    -   Dropped roubles showing "consume" prompt again
    -   So does M17 glue tube
    -   No localized name for Agroprom stash
            agr_smart_terrain_4_4_n_3_box
-- ===================================================================--]]
--      DEPENDENCIES
-- =======================================================================
assert(dotmarks_main, "\n\n"..
    "! ui_hud_dotmarks requires script dotmarks_main, which does not exist!\n\n"
)
assert(utils_catspaw_common, "\n\n"..
    "! ui_hud_dotmarks requires script utils_catspaw_common, which does not exist!\n\n"
)
assert(utils_catspaw_hudmarks, "\n\n"..
    "! ui_hud_dotmarks requires script utils_catspaw_hudmarks, which does not exist!\n\n"
)
assert(utils_catspaw_text and utils_catspaw_text.bindtext, "\n\n"..
    "! ui_hud_dotmarks requires script utils_catspaw_text, which does not exist or is an older version!\n" ..
    "Version found: " .. (utils_catspaw_text and utils_catspaw_text.script_version or "missing!") .. " | Required: 1.4+\n" ..
    "If the version is outdated, try moving this addon to the bottom of your load order."
)
assert(utils_catspaw_mapspots, "\n\n"..
    "! ui_hud_dotmarks requires script utils_catspaw_mapspots, which does not exist!\n\n"
)
--assert(false,"debug killswitch")
-- =======================================================================
local dl, vl, xml
logprefix   = "[DotMarks] "
debuglogs   = false
verbose     = false
debug_dump  = false

function allow_local_logging(onoff)
    -- By default, logging in this script inherits its debuglogs/verbose settings from utils_catspaw_common
    -- This function allows anyone to temporarily switch on debug logging for this script's operations only
    if onoff then
        dl = function(logtext, ...) utils_catspaw_common.dlog(this, logtext, ...) end
        vl = function(logtext, ...) utils_catspaw_common.vlog(this, logtext, ...) end
    else
        dl = function(logtext, ...) utils_catspaw_common.dlog(nil, logtext, ...) end
        vl = function(logtext, ...) utils_catspaw_common.vlog(nil, logtext, ...) end
    end
end
allow_local_logging(true)

function set_debug_logging(debug_en, verbose_en, dump_en)
    if (debug_en ~= nil) then debuglogs = debug_en end
    if (verbose_en ~= nil) then verbose = verbose_en end
    if (dump_en ~= nil) then debug_dump = dump_en end
end
--set_debug_logging(true, true, true) --uncomment this line to enable all logging for troubleshooting
-- First two values will be overridden by MCM once the game loads

-- ======================================================================
--      SHORTCUTS
-- ======================================================================
local get_next_check    = utils_catspaw_common.get_next_tg_interval
local valid_id          = utils_catspaw_common.valid_id
local get_obj_section   = utils_catspaw_common.get_obj_section
local is_living_thing   = utils_catspaw_common.is_living_thing
local strbool           = utils_catspaw_common.strbool
local safeid            = utils_catspaw_common.safeid
local get_mcm           = utils_catspaw_common.get_mcm_or_default_val
local fade_curve        = utils_catspaw_common.easing.OutQuint
local lerp              = utils_catspaw_common.lerp
local dec2              = utils_catspaw_common.dec2
local get_stash_hint    = utils_catspaw_common.get_stash_hint
local easeOutElastic    = utils_catspaw_common.easing.easeOutElastic
local get_obj_kind      = utils_catspaw_common.get_obj_kind
local safename          = utils_catspaw_text.safename
local bindtext          = utils_catspaw_text.bindtext
local get_localization  = utils_catspaw_text.find_best_localization
local parse_colors      = utils_catspaw_text.parse_color_tokens
local set_color_token   = utils_catspaw_text.set_color_token
local int_to_rgba       = utils_catspaw_text.int_to_rgba
local first_lower       = utils_catspaw_text.first_lower
local first_upper       = utils_catspaw_text.first_upper
local nameid            = utils_catspaw_text.obj_name_and_id
local get_argb          = utils_catspaw_mapspots.get_argb
local is_already_target = utils_catspaw_hudmarks.is_object_already_targeted
local is_favorite       = zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.is_favorite
local is_junk           = zzz_rax_sortingplus_mcm and zzz_rax_sortingplus_mcm.is_junk
local fdda_pickup       = z_fdda_pickup_intercept_dotmarks
local gts               = game.translate_string
-- ======================================================================
local config_file       = dotmarks_main.dotmarks_config_file
get_type_for_kind       = dotmarks_main.get_type_for_kind
get_type_for_section    = dotmarks_main.get_type_for_section
near_scan_radius        = dotmarks_main.near_scan_radius
early_scan_radius       = dotmarks_main.early_scan_radius
get_nearby_campfire     = dotmarks_main.get_nearby_campfire
get_nearest_firebinder  = dotmarks_main.get_nearest_campfire_binder
get_val_or_funcval      = dotmarks_main.get_val_or_funcval
get_cfg_for_type        = dotmarks_main.get_cfg_for_type
is_fdda_installed       = dotmarks_main.is_fdda_installed
is_blacklisted          = dotmarks_main.is_blacklisted
is_empty_mutant_corpse  = dotmarks_main.is_empty_mutant_corpse
get_fixed_screen_pos    = dotmarks_main.get_fixed_screen_pos
csv_argb_to_tbl         = dotmarks_main.csv_argb_to_tbl
clr_tbl                 = dotmarks_main.clr_tbl
clr_tbl_to_index        = dotmarks_main.clr_tbl_to_index
getargb                 = dotmarks_main.getargb
fonts                   = dotmarks_main.fonts
targeted_id, locked_id  = nil
cfg                     = {}
pickup_index            = {}
nearby_pickups          = {}
active_anims            = {}
-- ======================================================================
local st_kg             = gts("st_kg")
local maingameui        = nil
local hmm               = nil
local scanning          = false
local ea_enabled        = false
local anim_playing      = false
local actor_moved       = false
local popin_active      = nil
local extra_carry       = nil
local use_dik           = nil
local fdda_callback     = nil
local fallback_font     = 3
local _uiscale          = 1
local next_skill_upd    = 0
local next_near_scan    = 0
local next_early_scan   = 0
local next_tut_check    = 0

-- ======================================================================
--      HUD MARKER PRESET PATCH
--  Set up "dotmark" preset and patch it into utils_catspaw_hudmarks
-- ======================================================================
utils_catspaw_hudmarks.marker_presets["dotmark"] = (
    function(args)
        --[[    This defines all the "default" values for any marker instantiated as
                a "dotmark" preset by utils_catspaw_hudmarks      --]]
        local id    = args and args.id
        local preset_args = {
            -- ================================================================================
            --  Presets that need to be generated on marker create rather than static LTX defs
            -- ================================================================================
            id                  = id,
            far_fade_dist       = near_scan_radius() - 0.5,
            far_hide_dist       = near_scan_radius(),
            far_end_dist        = early_scan_radius() + 3,
            scale_dist_min      = (near_scan_radius() or 4) - 1,
            scale_dist_mid      = (near_scan_radius() or 4) - 0.5,
            scale_dist_max      = (near_scan_radius() or 4),
            los_check_int       = (not cfg.ignore_los) and 250 or nil, -- interval in ms to check LOS to marker object
            los_check_range     = (near_scan_radius() or 4) + 1,
            func_anim_take_curve= utils_catspaw_common.easing.InSine, -- easing function used for item take animation

            coord_args = { -- zero out all default screen coordinate adjustments
                near_adj = 0, 
                far_adj = 0,
                base_y  = 0,
            },
            -- ================================================================================
            func_on_update = (
            -- ================================================================================
            --      MAIN UPDATE LOOP FOR DOT MARKER OBJECTS
            -- ================================================================================
            --  Runs at the start of every marker update
            --  Determines prompt and marker visibility for most objects
            --  Updates condition and other metadata that are visible on prompts, if enabled
            -- ================================================================================
                function(mark, args)
                    local now           = time_global()
                    local id            = mark and mark.id
                    local hide          = mark and mark.hidden
                    local _             = debug_dump and printf("[DotMarks] [%s][%s] Visibility and UI checks for %s", mark.id, now, mark.name or mark.tutorial or mark.text)
                    local obj           = id and get_object_by_id(id)
                    if not obj then return end
                    
                    if mark.is_arty and (not can_actor_see_artefact(obj)) then
                        -- Check whether object is an artefact that is not currently visible
                        hide            = true
                    end
                    -- ================================================================================
                    -- Check whether this marker is for a junk object
                    local sec           = obj:section()
                    if (not hide) and obj and zzz_rax_sortingplus_mcm and cfg.sp_hide_junk_items then
                        local sec = obj:section()
                        if is_junk(sec) then
                            hide = true
                        end
                    end
                    -- ================================================================================
                    -- Check whether any logic has shut off interaction prompts entirely
                    local targeted      = is_current_target(id)
                    local show_pri      = targeted
                    local show_sec      = false
                    if (hide and not cfg.hidden_show_prompts) then
                        --printf("Aborting all prompt display")
                        _ = mark.use_pri and mark.use_pri:ShowPrompt(false)
                        _ = mark.alt_interact and mark.alt_interact:ShowPrompt(false)
                    else
                        -- ================================================================================
                        -- Check marker display conditions and whether animations are playing
                        local dist = mark.last_dist or 999
                        cfg.in_pickup_range[id] = mark.pickup and (dist <= 2.5) and dist or nil
                        --local in_pickup_range = cfg.in_pickup_range[id]
                        -- ================================================================================
                        -- Check availability of primary interact prompt
                        if (not hide) and mark.use_pri and mark.use_pri.init_done then
                            --printf("pri interact check")
                            local _ = debug_dump and printf("[DotMarks] Checking whether to show pri interact prompt for %s | targeted %s", mark.name, targeted)
                            if obj and mark.is_npc then
                                --printf("obj is NPC")
                                if (not mark.is_alive) then
                                    --printf("obj is dead body | mpda rules: %s | empty %s", cfg.bodies_use_mpda_rules, is_empty_mutant_corpse(obj))
                                    local tracked = true
                                    if is_empty_mutant_corpse(obj) then
                                        --printf("mutant corpse is empty, destroying")
                                        mark:Destroy()
                                        cfg.markers[id] = nil
                                        return
                                    elseif cfg.bodies_use_mpda_rules and item_milpda then
                                        -- Hide bodies that Milspec PDA won't show
                                        tracked = (ish_kill_tracker and ish_kill_tracker.tracked_kill and ish_kill_tracker.tracked_kill(id))
                                        if not tracked then
                                            hide = true
                                        end
                                        --printf("Using MPDA rules, body is tracked: %s", tracked)
                                    else
                                        --printf("dead corpse checks out")
                                    end
                                elseif mark.is_stalker then
                                    --printf("%s is stalker", mark.name)
                                    if (not obj:is_talk_enabled()) then
                                        --printf("Living NPC %s can't have conversation", mark.name)
                                        mark.use_pri:ShowPrompt(false)
                                        return
                                    end
                                end
                            elseif (not mark.is_display) and (mark.is_stash or (mark.is_stalker and not mark.is_alive)) then
                                -- Update contents of inventory containers
                                mark.has_items = not obj:is_inv_box_empty()
                                local text = nil
                                if mark.has_items and (not cfg.invboxes[id]) then
                                    --printf("getting inv table")
                                    cfg.invboxes[id] = get_inventory_table(obj, id)
                                end
                                if mark.has_items and cfg.invboxes[id] and (not is_empty(cfg.invboxes[id])) then
                                    --printf("container not empty, showing prompt")
                                    mark.weight = axr_companions.get_inventory_weight(cfg.invboxes[id])
                                    local wc = mark.weight and actor_weight_class(mark.weight)
                                    local code  = wc and cfg.weight_colors[wc] or cfg.weight_colors[0]
                                    mark.use_pri.parse_text_colors = true
                                    text = string.format(" ($%s%.2f %s$clr_def)", code, mark.weight, st_kg)
                                elseif treasure_manager.caches[mark.id] and not cfg.invboxes[id] then
                                    --printf("container not yet searched")
                                    text = " (" .. gts("st_paw_unknown") .. ")"
                                else
                                    --printf("container empty")
                                    text = " " .. gts("st_alti_empty")
                                end
                                mark.use_pri:SetPrompt(nil, nil, text or "")
                            end
                            --printf("passed NPC and container checks")
                            if mark.pickup then
                                --printf("Mark is an item pickup")
                                if cfg.show_item_card then
                                    mark.use_pri:UpdateWeightColor()
                                end
                            elseif (not show_pri) then
                                local available_pickup = mark.pickup and cfg.available_pickup and (mark.id == cfg.available_pickup)
                                local not_hidden_by_anim = (cfg.alti_show_during_anim or not anim_playing)
                                -- If nothing else has allowed visibility yet, final checks
                                show_pri = (
                                    (locked_id and targeted) or
                                    (available_pickup and not locked_id) or
                                    ((not mark.pickup) and (targeted)) and
                                    (dist < 5) and
                                    not_hidden_by_anim
                                )
                            end
                            if mark.condition then
                                -- Update condition for degradable objects
                                local cond = obj:condition()
                                if cond ~= mark.condition then
                                    mark.condition = cond
                                    mark.use_pri:SetConditionText(sec, cond)
                                    mark.use_pri:SetPrompt()
                                end
                            end
                            --printf("Final primary interact state: %s | %s", show_pri, nameid(mark.name, mark.id), show_pri)
                            mark.use_pri:ShowPrompt(show_pri)
                            -- ================================================================================
                            -- Check availability of secondary interact prompt
                            if mark.alt_interact then
                                show_sec = show_pri
                                if show_sec then
                                    if cfg.hide_sec_interact_ui then
                                        show_sec        = false
                                        local _         = debug_dump and vl("Secondary interactions disabled via config, hiding UI for %s", mark.name)
                                    else
                                        if mark.ammo_count and (mark.ammo_count == 0) then
                                            show_sec    = false
                                        elseif mark.has_battery and mark.condition and (mark.condition < 0.01) then
                                            show_sec    = false
                                        elseif mark.is_stash or (mark.is_npc and not mark.is_alive) then
                                            show_sec    = show_pri and mark.has_items
                                        end
                                        local _ = debug_dump and vl("[DotMarks] Checking whether to show alt interact prompt for %s | show_pri %s | targeted %s", mark.name, show_pri, targeted)
                                    end
                                end
                                mark.alt_interact:ShowPrompt(show_sec)
                            end
                        end
                    end
                    _ = debug_dump and vl("[%s][%s] Done with both prompt checks:\n* show_pri %s | show_sec %s | hide %s | pri prompt %s", time_global(), mark.name, show_pri, show_sec, hide, (mark.use_pri ~= nil) and "exists")
                    -- ================================================================================
                    local texture = mark.texture or ""

                    if (not hide) and (mark.use_pri and mark.active_swap) then
                        mark:ActiveSwap(show_pri)
                        texture = mark.texture
                        mark.use_pri:SetupConnectingLine()

                        if show_pri and can_start_popin_anim(mark) then
                            --printf("Trying to begin popin effect | active %s | done %s", popin_active, mark.popin_done)
                            init_active_marker_popin(mark)
                        end
                    end

                    if (hide or cfg.hide_interaction_dots) then
                        --printf("Hiding marker")
                        -- Clear texture for hidden markers
                        texture = ""
                    else
                        --mark:ScaleMarkerByDistance(mark.base_w, mark.base_h, nil, cfg.dot_marker_size)
                        mark.width = mark.base_w * (cfg.dot_marker_size or 1)
                        mark.height = mark.base_h * (cfg.dot_marker_size or 1)

                        mark:ScaleMarkerByDistance()
                        --printf("Base size is %sx%s, setting to %sx%s after UI scaling", mark.base_w, mark.base_h, mark.width, mark.height)
                    end
                    mark.loop_num = mark.loop_num and (mark.loop_num + 1) or 0
                    _ = debug_dump and vl("[DotMarks] [%s][%s] End of main update loop %s | Final size: [%s x %s]", time_global(), mark.name, mark.loop_num, dec2(mark.width), dec2(mark.height))
                    mark.marker:InitTexture(texture)

                end
            ),
            -- ================================================================================
            func_los_check = (
            -- ================================================================================
            --  Runs during the LOS check phase of every marker update
            --  Force LOS check to succeed if the marked object is the current interact target
            -- ================================================================================
                function(mark, args)
                    if not (mark.pickup or mark.is_stalker or mark.is_stash) then return end
                    local pri_shown = (mark and mark.use_pri and mark.use_pri.wnd and mark.use_pri.wnd:IsShown())
                    --printf("Overriding LOS check while primary prompt is shown")
                    return pri_shown and true or nil
                end
            ),
            -- ================================================================================
            func_on_destroy = (
            -- ================================================================================
            --  When any marker is destroyed, unregister that ID and clear its metadata
            -- ================================================================================
                function(mark) this.unregister_scanned_entity(mark and mark.id) end
            ),
        }
        -- Most static values are loaded from the cfg.dotmark_preset table, thus loaded from the config file
        for k,v in pairs(cfg.dotmark_preset) do
            preset_args[k] = v
        end
        return preset_args
    end
)
-- ======================================================================
--      ACTIVE SWAP OF MARKER ATTRIBUTES
--  Monkeypatches utils_catspaw_hudmarks to add support for hotswapping
--  the marker texture and other parameters on the fly
-- ======================================================================
function utils_catspaw_hudmarks.UIHUDMarker:ActiveSwap(state)
    --printf("[%s][UIHUDMarker:ActiveSwap] for %s: %s", time_global(), self.name or self.tutorial, state)
    if self.destroyed or not self.active_swap then return end

    if state == nil then state = is_current_target(self.id) end
    local _
    for k,v in pairs(self.active_swap) do
        if state then
            if (popin_active ~= self.mark_id) then
                _ = debug_dump and vl("[%s][%s][Swap on] Setting: %s = %s", time_global(), self.name, k, v)
                self[k] = v
                if self.use_pri then
                    self.use_pri.args[k] = v
                end
            end
        else
            self.popin_done = false
            self[k] = self.args[k]
            if self.use_pri then
                self.use_pri.args[k] = self.args[k]
            end
            _ = debug_dump and vl("[%s][%s][Swap off] Reverting: %s = %s", time_global(), self.name, k, self.args[k])
        end
        self.base_w = self.width
        self.base_h = self.height
    end
    if self.is_active ~= state then
        vl("[%s][%s] Mark active status changed to %s (was %s)", time_global(), self.name, state, self.is_active)
        self.last_active_state = self.is_active
        self.is_active = state
        self.next_update = 0
    end
end

-- ======================================================================

function get_fdda_callback()
    --local anim_en = (cfg.fdda_pickup_anim or cfg.fddar_pickup_anim) or nil
    --printf("Animations enabled: %s | FDDA %s | FDDAR %s", anim_en, cfg.fdda_pickup_anim, cfg.fddar_pickup_anim)
    --fdda_callback = anim_en and fdda_pickup and fdda_pickup.get_fdda_oibp_callback() or nil
    fdda_callback = fdda_pickup and fdda_pickup.get_fdda_oibp_callback() or nil
    return fdda_callback
end

function fdda_handles_pickups()
    return get_fdda_callback() and (cfg.fdda_pickup_anim or cfg.fddar_pickup_anim)
end

function item_pickup_intercept(obj, flags)
    -- Called directly by actor_on_item_before_pickup if neither FDDA nor FDDAR are installed
    -- Called by my monkeypatch of FDDA/FDDAR's pickup if they are
    local now = time_global()
    vl("[%s][item_pickup_intercept] %s - ret %s | force %s", now, nameid(obj), flags.ret_value, flags.force)
    if flags.force then
        --printf("Skipping all long-press checks")
    else
        if (cfg.held_key == use_dik) then
            --printf("[%s][item_pickup_intercept] Long press in progress, aborting pickup of %s", now, obj and obj:name())
            flags.ret_value = false
            return
        elseif cfg.watch_use then
            if (time_global() - (cfg.use_released or 0)) < (cfg.long_press_delay or 50) then
                --printf("[%s][item_pickup_intercept] Actor just released use key at %s, aborting pickup of %s", now, cfg.use_released, obj and obj:name())
                flags.ret_value = false
                return
            end
        end
    end

    vl("[%s][item_pickup_intercept] Actor tried to take item %s", now, nameid(obj))
    local curr_target = get_current_target()
    --vl("Current target: %s", curr_target)
    local taken_obj = curr_target and get_object_by_id(curr_target)
    
    if taken_obj then
        vl("[%s][item_pickup_intercept] Forcing actor to take %s", now, nameid(taken_obj))
        if cfg.markers[curr_target] then
            cfg.markers[curr_target]:HideAll("dotmarks taking item")
        end
        if flags.ret_value then
        -- The monkeypatch in z_fdda_pickup_intercept_dotmarks sets flags.ret_value to false
        -- if flags.ret_value is already false when it gets to DotMarks, DotMarks will assume
        -- that FDDA is handling the pickup part
        -- However, some items don't appear to respond to this handling, so we use them manually
            flags.ret_value = false
            db.actor:take_item(taken_obj)
        end
    end
    return taken_obj
end


function easeOutElastic(x)
    local c4 = 2 * math.pi / 3
    return x == 0 and 0 or (x == 1 and 1 or 2 ^ (-10 * x) * math.sin((x * 10 - 0.75) * c4) + 1)
end

function set_adjusted_marker_size(mark_id)
    local mark = hmm:GetMarker(mark_id)
    if not mark then return end
    mark.width = mark.base_w * (cfg.dot_marker_size or 1)
    mark.height = mark.base_h * (cfg.dot_marker_size or 1)
    --printf("Final mark size: %sx%s", mark.width, mark.height)
end

function do_marker_popin(
        mark_id,
        w_start, h_start, w_end, h_end, duration,
        easing_func, on_finish_func, abort_func
    )
    if not mark_id then return end
    --printf("Initializing popin for %s at %s", mark_id, time_global())

    local anim_state = 0

    local anim_id = mark_id .. "_popin"

    if active_anims[mark_id] then
        --printf("Repeat invocation of popin event, restarting")
        popin_active = nil
    end
    popin_active = mark_id

    --printf("[%s] do_marker_popin: start %sx%s end %sx%s dur %sms", time_global(), w_start, h_start, w_end, h_end, duration)
    local mark      = hmm:GetMarker(mark_id)
    if not mark then return end

    local start_time= time_global()
    local end_time  = time_global() + duration
    easing_func = easing_func or function(x) return x end
    active_anims[mark_id] = {
        mark_id     = mark_id,
        anim_id     = anim_id,
        start_time  = start_time,
        end_time    = end_time,
        active      = true,
        w_start     = function(mark) return mark and mark.is_active and mark.args.width or w_start or 0 end,
        w_end       = function(mark) return mark and mark.is_active and mark.active_swap.width or mark.args.width or w_end or 0 end,
        h_start     = function(mark) return mark and mark.is_active and mark.args.height or h_start or 0 end,
        h_end       = function(mark) return mark and mark.is_active and mark.active_swap.height or mark.args.height or h_end or 0 end,
    }
    
    
    --printf("Creating popin time event %s", mark_id)
    CreateTimeEvent("animate_popin_"..mark_id, time_global(), 0, 
        function()
            local abort = abort_func and abort_func()
            if abort then
                --printf("Received anim abort for %s", mark_id)
                anim_state = 1
            elseif start_time - end_time > 5000 then
                --printf("Timeout, aborting event %s", mark_id)
                anim_state = 1
            else
                local anim = active_anims[mark_id]
                local mark = hmm:GetMarker(mark_id)
                if not (mark and mark.is_shown) then
                    anim_state = 1
                elseif mark and anim and anim.active then
                    if mark.is_active then
                        local x = easing_func(anim_state)
                        anim.w = lerp(anim.w_start(mark), anim.w_end(mark), x)
                        anim.h = lerp(anim.h_start(mark), anim.h_end(mark), x)
                        --printf("[%s] Popin time event: setting base width for %s to %s", time_global(), anim_id, mark.base_w)
                    else
                        --printf("[%s] Mark %s is no longer active, canceling animation and reverting to base", time_global(), mark_id)
                        anim_state = 1
                    end
                    mark.base_w = anim.w or anim.w_end(mark)
                    mark.base_h = anim.h or anim.h_end(mark)
                    set_adjusted_marker_size(mark_id)
                else
                    --printf("Event conditions for %s cleared, aborting", mark_id)
                    anim_state = 1
                end
            end

            if (anim_state == 1) then
                --printf("Popin animation %s completed at %s", mark_id, time_global())
                if on_finish_func then on_finish_func() end
                active_anims[mark_id] = nil
                popin_active = nil
                return true
            end
            anim_state = math.min(1, normalize(time_global(), start_time, end_time))
        end
    )
end

function init_active_marker_popin(mark)
    if type(mark) == "string" then
        -- Assume a mark_id got passed instead of the mark itself
        mark = hmm:GetMarker(mark)
    end
    if not (mark and mark.mark_id) then return end

    do_marker_popin(
        mark.mark_id,
        mark.args.width * 0.5, mark.args.height * 0.5,
        mark.active_swap.width, mark.active_swap.height,
        cfg.popin_anim_dur,
        easeOutElastic,
        (function()
            mark.next_update = 0
            mark.popin_done = true
            popin_active = nil
        end),
        (function() 
            return  (not popin_active) or
                    (not mark.texture) or
                    (popin_active ~= mark.mark_id) or
                    (mark.texture ~= mark.active_swap.texture)
        end)
    )
end

function can_start_popin_anim(mark)
    return cfg.popin_anim_dur and (cfg.popin_anim_dur > 0) and not (popin_active or mark.popin_done)
end

function can_actor_see_artefact(obj)
    local arty  = obj and obj:cast_Artefact()
    local vstate= arty and arty.getVisible and arty:getVisible() or 0
    return (vstate == 1) and true or false
end

function get_bones_for_obj(obj)
    local bones = obj and obj.list_bones and obj:list_bones()
    --printf("bones for %s", obj:name())
    --for k,v in pairs(bones) do
        --printf("[%s] = %s", k, v)
    --end
    return bones
end

local ini_parts = itms_manager.ini_parts
function has_parts(obj)
    if not obj then return end
    local sec = SYS_GetParam(0, obj:section(), "parent_section") or obj:section()
    local parts = ini_parts:r_string_ex("con_parts_list", sec)
    return parts ~= nil
end

function is_door_open(obj, id)
    id = id or (obj and obj:id())
    obj = obj or (id and get_object_by_id(id))
    if not id then return end
    local door = id and db.storage[id]["ph_door"] and db.storage[id]["ph_door"].door_action
    local is_open = door:is_open()
    vl("Door %s is open: %s", obj and obj:name(), is_open)
end

function is_vanilla_ui_hidden()
    return (cfg.hide_van_interact_ui and not cfg.hide_pri_interact_ui)
end

function trimmed_prompt(txt)
    local pos = txt and txt:find("%(")
    return pos and txt:sub(1, pos - 2) or txt or ""
end

function interact_vert_offset(ui_interact)
    local args = ui_interact and ui_interact.args
    return args and (not args.pri) and (not cfg.hide_pri_interact_ui) and cfg.sec_use_y_offset or cfg.pri_use_y_offset
end

function lerp_color(val, mi, md, mx)
    --printf("lerp_color: %s, %s, %s, %s", val, mi, md, mx)
    -- like in utils_xml, except returning a table I can do something with instead of ARGB
    local m1,m2
    if (val >= mi[5]) and (val < md[5]) then
        m1 = mi
        m2 = md
    elseif (val >= md[5]) and (val <= mx[5]) then
        m1 = md
        m2 = mx
    end
    if not (m1 and m2) then
        return clr_tbl(255,255,255,255)
    end
    
    local t = {}
    for i=1,4 do
        if m1[i] == m2[i] then
            t[i] = m1[i]
        else
            t[i] = math.floor( m1[i] + ((m2[i] - m1[i]) * normalize(val, m1[5], m2[5])) )
            --printf(" [%s] %s = %s [ %s , %s ] | diff: %s - normalize: %s", self.section, i, t[i], m1[i], m2[i], (m2[i] - m1[i]), 1 - normalize(val, m1[5], m2[5]))
        end
    end
    return clr_tbl(t[1], t[2], t[3], t[4])
end

function is_already_target(id)
    local is_xhair  = hmm and hmm.current_pickup and (id == hmm.current_crosshair)
    local is_pickup = hmm and hmm.current_pickup and (id == hmm.current_pickup)
    local is_target = hmm and hmm.current_target and (id == hmm.current_target)
    local result = is_pickup or is_target or is_xhair
    --vl("is_already_target(%s): %s | pickup: %s | look_target: %s | crosshair: %s", id, result, is_pickup, is_target, is_xhair)
    return result
end

function get_condition_color(condition, section)
    if not condition then return end
    local c = cfg.colors
    local critical = section and item_device.dev_critical[section]
    if critical then
        if (condition * 0.01) < critical then
            return c.clr_wpo_red
        else
            return c.clr_battery
        end
    end
    local cc = {
        min = c.clr_cnd_min,
        mid = c.clr_cnd_mid,
        max = c.clr_cnd_max,
        grn = c.clr_wpo_grn,
        yel = c.clr_wpo_yel,
        orn = c.clr_wpo_orn,
        red = c.clr_wpo_red
    }
    local color
    if cfg.parts_wpo_colors then
        -- Weapon Parts Overhaul color thresholds
        color = cfg.colors.clr_missing
        if condition >= (cfg.parts_wpo_grn or 85) then color = cc.grn
        elseif condition >= (cfg.parts_wpo_yel or 60) then color = cc.yel
        elseif condition >= (cfg.parts_wpo_orn or 20) then color = cc.orn
        elseif condition > -1 then color = cc.red end
    else
        -- Vanilla gradient lerp
        if condition >= 0 then
            local cond = clamp(condition / 99, 0, 1)
            color = lerp_color(cond, cc.min , cc.mid , cc.max)
        else
            color = c.clr_missing
        end
    end
    return color
end

function timed_out(stamp, interval)
    if not (stamp and interval) then return end
    return (time_global() - stamp) >= interval
end

-- =======================================================================
--[[    Custom interaction prompt
    Anyone could probably reuse this with some adjustments to remove the
    stuff specific to DotMarks.

    It takes the following args (among others I need to document):
        event       ::  String ID for the event, used to construct internal UID
        func        ::  Required, the function to execute when the interaction is activated
        text        ::  The descriptive text for the interaction
        bind        ::  The text to display inside the keybind icon
        long        ::  Whether to display a progress indicator for a long press, autodetected from mode
        key         ::  The DIK code of the bound key for the interact
        mod         ::  The modifier key code (alt, shift, ctrl)
        mode        ::  The input mode of the interaction (0=simple, 1=doubletap, 2=longpress/hold)
        xoffset     ::  Horizontal pos offset
        yoffset     ::  Vertical pos offset
        act         ::  Action text to display as a prefix to the prompt text, usually handled automatically
        argb_light  ::  Index of four values used as the ARGB for light-colored text
        argb_light  ::  Index of four values used as the ARGB for dark-colored text
        argb_busy   ::  Index of four values used as the ARGB for text when the interact is visible but disabled

    Need to trim the fat off of this after DotMarks is done and I know what isn't needed.
-- =====================================================================]]


class "InteractPrompt" (CUIScriptWnd)

function InteractPrompt:__init(anchor, args) super()
    vl("InteractPrompt:__init | event %s | name %s | tutorial %s", args and args.event, args and args.name, args and args.tutorial)
    self:SetAutoDelete(true)
    self.elements = {
        ["wnd"]         = true,
        ["prompt"]      = false,
        ["prompt_l"]    = false,
        ["prompt_c"]    = false,
        ["prompt_r"]    = false,
        ["bind"]        = true,
        ["bind_sh"]     = true,
        ["label"]       = true,
        ["label_sh"]    = true,
        ["line"]        = false,
        ["longpress"]   = false,
    }   -- bool is whether to scale alpha
    self.xml    = CScriptXmlInit()
    self.uid    = "dotmarks_" .. args.event
    args        = args or {}
    args.func   = args.func or (function() end)
    args.event  = self:Event(args.event)
    args.key    = self:BindKey(args.key)
    args.mod    = self:ModKey(args.mod)
    args.mode   = self:InputMode(args.mode)
    args.bind   = args.bind or bindtext(key, mod)
    args.long   = args.long or (args.mode == 2)
    args.xoffset= args.xoffset or (args.pri and cfg.pri_use_x_offset or cfg.sec_use_x_offset)
    args.yoffset= args.yoffset or (args.pri and cfg.pri_use_y_offset or cfg.sec_use_y_offset)
    if (not args.no_sec_yscale) and (not args.pri) then
        local pxoff = cfg.pri_use_x_offset
        local pyoff = cfg.pri_use_y_offset
        local sxoff = cfg.sec_use_x_offset
        local syoff = cfg.sec_use_y_offset
        local ydiff = syoff - pyoff
        args.yoffset = args.yoffset - ydiff + fontscale(ydiff)
    end

    args.act    = args.act or ""
    args.name   = args.name or ""
    args.fixed  = ((args.fixed ~= nil) and args.fixed) or cfg.fixed_screen_pos
    self.anchor = args.fixed and maingameui or anchor or maingameui
    if args.fixed then
        local x,y   = get_fixed_screen_pos()
        args.locked_screen_pos = vector2():set(x, y)
    end
    if args.mark_id then
        self.mark   = hmm:GetMarker(args.mark_id)
    end
    if args.scheme and args.scheme.door_action then
        self:SetupDoorHandlers(args)
    end

    if debug_dump then
        printf("[InteractPrompt] Passed args:")
        for k,v in pairs(args) do printf("|| %s = %s", k, v) end
    end
    if args.hint_filters then
        local mon = {}
        for k,v in pairs(args.hint_filters) do
            mon[gts(k)]     = trimmed_prompt(gts(v))
        end
        args.hint_filters   = args.pri and mon or nil
    end

    local color             = cfg.colors
    local csv2clr           = csv_argb_to_tbl
    self.text_color_default = clr_tbl(255, 255, 255, 255)
    self.text_hidden        = clr_tbl(0, 0, 0, 0)
    self.text_color_busy    = csv2clr(args.argb_busy)   or color.clr_text_busy  or self.text_color_default
    self.text_color_light   = csv2clr(args.argb_light)  or color.clr_text_light or self.text_color_default
    self.text_color_dark    = csv2clr(args.argb_dark)   or color.clr_text_dark  or self.text_color_default
    self.progress_color     = csv2clr(args.argb_prog)   or color.clr_key_hold or csv_argb_to_tbl({255,255,215,0})

    self.active_prefix      = args.active_prefix or args.act    or ""
    self.active_prompt      = args.active_prompt or args.text   or (args.tutorial and trimmed_prompt(gts(args.tutorial))) or ""
    self.active_suffix      = args.active_suffix or args.suffix or ""
    self.args               = args
    if self.args.tutorial and (self.args.tutorial:find("campfire")) then
        self.campfire_tut   = true
    end
    self.last_state         = false
    self:on_option_change()
    self:BusyState(false)
    self:ShowPrompt(false, "init")

    RegisterScriptCallback("on_option_change", self)
    RegisterScriptCallback("actor_on_update", self)
    RegisterScriptCallback("actor_on_net_destroy", self)

    self.init_done = time_global()
    
    vl("[%s][InteractPrompt] Completed setup for prompt: %s", self.init_done, self:GetFullPrompt())
end


function InteractPrompt:SetupDoorHandlers(args)
    self.door = {
        data = args.scheme,
        ctrl = args.scheme.door_action
    }
    local door = self.door
    if not door.ctrl then return end

    door.lo, door.hi = door.ctrl.joint:get_limits(0, 0, 0)
    door.mid = (door.lo + door.hi) * 0.5
    door.deadzone = 0.1
    door.is_open = (
        function()
            return self.door.ctrl and self.door.ctrl.is_open and self.door.ctrl:is_open()
        end
    )
    door.tips = {
        close   = self.door.data and self.door.data.tip_close,
        open    = self.door.data and self.door.data.tip_open,
        unlock  = self.door.data and self.door.data.tip_unlock,
    }
    door.joint_pos = (
        function()
            return self.door.ctrl and
                self.door.ctrl.joint and
                self.door.ctrl.joint.get_axis_angle and
                self.door.ctrl.joint:get_axis_angle(0)
        end
    )
    door.tip = (
        function()
            local locked = self.door.data and self.door.data.locked
            local tips = self.door.tips
            local msg = locked and tips.unlock or self.door.is_open() and tips.close or tips.open
            --printf("door %s is open: %s | locked %s | returning msg %s", args.name, self.door.ctrl:is_open(), locked, msg)
            return msg
        end
    )
    args.text = gts(self.door.tip())
end

function InteractPrompt:SetupConnectingLine()
    -- White line
    if not self.line then
        self.line = self.xml:InitProgressBar("prog_dotpointer", self.anchor)
    end

    if self.args.pri then
        self.line:SetWndPos(vector2():set((self.args.line_adj_x or 0) + -3.5, (self.args.line_adj_y or 0) + 3))
        self.line:SetWndSize(vector2():set(5 + (self.args.line_adj_w or 0), 26 + (self.args.line_adj_h or 0)))
    else
        self.line:Show(false)
    end
end

function InteractPrompt:BuildUI()
    vl("InteractPrompt:BuildUI | %s", self.args.name or self.args.text or self.args.tutorial or self.args.event)
    if self.wnd then
        for k,_ in pairs(self.elements) do
            self[k] = nil
        end
    end

    local xml           = self.xml
    xml:ParseFile(cfg.interact_uifile)
    local args          = self.args
    local boxlen        = fontscale(#args.bind * 5.825)
    local boxpos        = -(boxlen - 4)
    self.args.style     = cfg.keybind_bg_style or 0
    vl("Keybind icon style is %s", self.args.style)
    self.black_text     = (self.args.style == 2) or (self.args.style == 3)
    local stretch_adj   = 0
    self.wnd            = xml:InitStatic("alt_interact", self.anchor)
    if self.args.locked_screen_pos then
        self.wnd:SetWndPos(self.args.locked_screen_pos)
    else
        local x             = args.xoffset
        local y             = args.yoffset
        self.wnd:SetWndPos(vector2():set(x, y))
    end

    self.drop           = xml:InitStatic("box", self.wnd)
    self.drop:SetWndPos(vector2():set(-boxlen, -1))
    self.drop:InitTexture(cfg.main_drop_texture)
    self.drop:SetTextureColor(get_argb(clamp(cfg.interact_drop_alpha * 255, 0, 255), 255, 255, 255))
    self:SetupConnectingLine()

    local one_char = (#args.bind == 1)
    if one_char then
        self.prompt     = xml:InitStatic("alt_interact:prompt", self.wnd)
        self.prompt:InitTexture("ui_catsy_keybind_bg_single_v" .. self.args.style)
        self.prompt:SetWndSize(vector2():set(fontscale(15), fontscale(20)))
    else
        self.prompt     = xml:InitStatic("box", self.wnd)
        
        self.prompt_l   = xml:InitStatic("alt_interact:prompt_l", self.prompt)
        self.prompt_c   = xml:InitStatic("alt_interact:prompt_c", self.prompt)
        self.prompt_r   = xml:InitStatic("alt_interact:prompt_r", self.prompt)
        self.prompt_l:InitTexture("ui_catsy_keybind_bg_left_v" .. args.style)
        self.prompt_c:InitTexture("ui_catsy_keybind_bg_center_v" .. args.style)
        self.prompt_r:InitTexture("ui_catsy_keybind_bg_right_v" .. args.style)

        stretch_adj     = 2
        self.prompt_l:SetWndSize(vector2():set(fontscale(5.3125), fontscale(20)))
        self.prompt_l:SetWndPos(vector2():set(0, 0))
        self.prompt_c:SetWndSize(vector2():set(boxlen, fontscale(20)))
        self.prompt_c:SetWndPos(vector2():set(fontscale(5.1125), 0))
        self.prompt_r:SetWndPos(vector2():set(fontscale(4.78) + boxlen, 0))
        self.prompt_r:SetWndSize(vector2():set(fontscale(5.3125), fontscale(20)))
    end
    self.prompt:SetWndPos(vector2():set(boxpos or 0, 0))

    -- Set up long press progress indicator
    if args.long then
        self.longpress  = xml:InitProgressBar("prog_longpress", self.prompt)
        self.longpress:SetColor(getargb(self.progress_color))
        self.longpress:SetProgressPos(0)
        --[[
        cfg.input_filters[self.args.id] = {
            key     = self.args.key,
            mod     = self.args.mod,
            mode    = self.args.mode,
            ctrl    = self
        }
        --]]
    end

    -- Set up text drop shadows
    self.bind_sh        = xml:InitStatic("alt_interact:label", self.prompt)
    self.label_sh       = xml:InitStatic("alt_interact:label", self.wnd)
    self.bind_sh:SetWndSize(vector2():set((boxlen or 0) + fontscale(15), fontscale(20)))
    self.bind_sh:SetWndPos(vector2():set(fontscale(stretch_adj + 4.5), fontscale(3.25)))
    self.label_sh:SetWndPos(vector2():set(fontscale(24.5), fontscale(3.25)))
    self.bind_sh:TextControl():SetFont(get_font())
    self.label_sh:TextControl():SetFont(get_font())

    -- Keybind text indicator
    self.bind           = xml:InitStatic("alt_interact:label", self.prompt)
    self:eleSetBaseColorScheme(self.bind, self.black_text and self.text_color_dark or self.text_color_light)
    self.bind:TextControl():SetFont(get_font())

    self:SetBindText(bindtext(self:BindKey(), self:ModKey()))

    self.bind:SetWndSize(vector2():set((boxlen or 0) + fontscale(15), fontscale(20)))
    if one_char then
        self.bind:SetWndPos(vector2():set(fontscale(stretch_adj + 4.5), fontscale(2.5)))
    else
        self.bind:SetWndPos(vector2():set(fontscale(stretch_adj + 3), fontscale(2.5)))
    end

    -- Width reference static
    self.lref      = xml:InitStatic("box", self.wnd)
    self.lref:Show(false)

    -- Prompt text label
    self.label          = xml:InitStatic("alt_interact:label", self.wnd)
    self:eleSetBaseColorScheme(self.label, self.text_color_light)
    self.label:SetWndPos(vector2():set(fontscale(24), fontscale(3.5)))
    self.label:TextControl():SetFont(get_font())

    self:eleSetBaseColorScheme(self.bind_sh, self.text_color_dark)
    if self.black_text then
        self.bind_sh:Show(false)
    end
    self:eleSetBaseColorScheme(self.label_sh, self.text_color_dark)

    local obj = self.args.id and get_object_by_id(self.args.id)
    self:SetupSuffix(obj)
    self:SetPrompt()

    if obj and self.args.pri then
        self:SetupItemCard(self.wnd, obj)
        self:SetupUtjanPartDots(self.itemcard)
    end
    vl("Completed %sbuilding interact UI: %s", self.init_done and "re" or "", self.active_prompt)
    self:actor_on_update()
end

function InteractPrompt:SetupSuffix(obj)
    obj             = obj or (self.args.id and get_object_by_id(self.args.id))
    if (not obj) then return end
    --if self.args.money then
        --self.active_suffix = string.format(" ($clr_gld%s$clr_def)", self.args.money)
        --self.parse_text_colors = true
        --return
    --end

    if not (cfg.show_item_condition or cfg.show_item_charge) then return end

    local sec       = self.args.section or obj:section()
    local cls       = self.args.clsid or obj:clsid()
    local has_cond  = (sec and cls) and (utils_item.is_degradable(nil, sec) or IsWeapon(nil, cls) or IsOutfit(nil, cls) or IsHeadgear(nil, cls))
    local is_mag    = magazine_binder and sec and magazine_binder.is_magazine(sec)
    local gear_cnd  = (self.args.has_parts and cfg.show_item_condition)
    local batt_cnd  = ((self.args.has_power or self.args.has_battery) and cfg.show_item_charge)

    vl("[InteractPrompt:SetupSuffix][%s][has_cond %s][multi %s]", sec, has_cond, self.args.multi_uses)

    if self.args.multi_uses then
        -- Setup suffix text for multiuse items
        if cfg.show_multi_uses and (self.args.multi_uses > 1) then
            self.active_suffix = string.format(" (%s %s)", self.args.multi_uses, gts("st_alti_uses"))
        else
            self.active_suffix = ""
        end
    elseif has_cond and (gear_cnd or batt_cnd) and (not is_mag) then
        -- Setup suffix text for degradable items
        vl("setting up condition label")
        local cond = obj and obj:condition()
        self:SetConditionText(sec, cond)
    else
        self.active_suffix = ""
    end
end


function InteractPrompt:SetConditionText(sec, cond)
     if (cond and sec) then
        cond = math.floor(cond * 100)
        local c = get_condition_color(cond, sec)
        local key = "cond_" .. cond
        local str   = string.format("%" .. "%c[%s,%s,%s,%s]", c.a, c.r, c.g, c.b)
        set_color_token(key, str)
        self.parse_text_colors = true
        if (cond < 0.01) and self.args.has_power then
            self.active_suffix = string.format(" ($%s%s$clr_def)", key, gts("st_alti_nopower"))
        else
            self.active_suffix = string.format(" ($%s%s%%$clr_def)", key, cond)
        end
    else
        self.active_suffix = ""
    end
end


function InteractPrompt:UpdatePromptLength()
    local len           = self.prompt_length
    self.prompt_length  = self.lref:GetWidth() + 25
    --printf("prompt length was %s, is now %s", len, self.prompt_length)
    if len == self.prompt_length then return self.prompt_length end
    if self.itemcard then
        self.itemcard:SetWndPos(vector2():set(cfg.item_card_pos_x + self.prompt_length, cfg.item_card_pos_y or 0))
    end
    return self.prompt_length
end

function InteractPrompt:UpdateWeightColor()
    if not (self.card_wgt_icon and self.card_wgt_text) then return end
    local c = get_color_for_weight(self.weight or 0)
    --printf("Weight of %s is %s | color %s,%s,%s,%s ", self.args.name, self.weight, c.a, c.r, c.b, c.g)
    local color = getargb(c)
    self.card_wgt_icon:SetTextureColor(color)
    self.card_wgt_text:TextControl():SetTextColor(color)
end

function InteractPrompt:SetupItemCard(anchor, obj)
    if (not cfg.show_item_card) or (not self.args.pickup) then return end
    if self.itemcard then self.itemcard:Show(false) end
    obj = obj or (self.args.id and get_object_by_id(self.args.id))
    sec = obj and obj:section()
    if not sec then return end

    self.weight     = dec2(ini_sys:r_float_ex(sec,"inv_weight") or 0)
    local value     = dec2(ini_sys:r_float_ex(sec,"cost") or 0)

    --printf("setting up item card | weight %s | w %s f %s | value %s", weight, whole, frac, value)
    xml:ParseFile(cfg.interact_uifile)
    local offset    = fontscale(self:UpdatePromptLength())
    self.itemcard   = self.xml:InitStatic("box", anchor or self.wnd)

    local icon_sz   = cfg.item_card_icon_sz
    local wnd_x     = cfg.item_card_pos_x
    local wnd_y     = cfg.item_card_pos_y
    local text_y    = cfg.item_card_text_y
    local elem_x    = cfg.item_card_elem_x
    local elem_y    = cfg.item_card_elem_y
    local elem_h    = fontscale(cfg.item_card_elem_h)
    local icon_x    = cfg.item_card_icon_x
    local icon_y    = cfg.item_card_icon_y

    self.itemcard:SetWndPos(vector2():set(wnd_x + offset, wnd_y))

    self.card_wgt = self.xml:InitStatic("box", self.itemcard)
    self.card_wgt:SetWndPos(vector2():set(elem_x, elem_y))
    self.card_wgt_icon = self.xml:InitStatic("box", self.card_wgt)
    self.card_wgt_icon:SetWndSize(vector2():set(icon_sz * cfg.unsquish_ratio, icon_sz))
    self.card_wgt_icon:SetWndPos(vector2():set(icon_x, icon_y))
    self.card_wgt_icon:InitTexture(cfg.item_card_icon_weight)
    self.card_wgt_icon:Show(true)

    offset = elem_x + self.card_wgt_icon:GetWidth()
    self.card_wgt_text = self.xml:InitStatic("box", self.card_wgt)
    self.card_wgt_text:SetWndSize(vector2():set(0, elem_h))
    self.card_wgt_text:SetWndPos(vector2():set(offset, text_y))
    self.card_wgt_text:TextControl():SetFont(get_font(cfg.font_item_card or 0))
    self.card_wgt_text:TextControl():SetText(self.weight)
    self.card_wgt_text:AdjustWidthToText()
    self.card_wgt_text:Show(true)
    self:UpdateWeightColor()

    local weight_w = offset + self.card_wgt_text:GetWidth()
    self.card_wgt:SetWndSize(vector2():set(weight_w + 6, elem_h))
    self.card_wgt:InitTexture("ui_catsy_card_drop")
    self.card_wgt:SetTextureColor(getargb( cfg.colors.clr_card_drop ))

    offset = elem_x
    self.card_val = self.xml:InitStatic("box", self.itemcard)
    self.card_val:SetWndPos(vector2():set(offset, elem_y + elem_h))
    self.card_val_icon = self.xml:InitStatic("box", self.card_val)
    self.card_val_icon:SetWndSize(vector2():set(icon_sz * cfg.unsquish_ratio, icon_sz))
    self.card_val_icon:SetWndPos(vector2():set(icon_x, icon_y))
    self.card_val_icon:InitTexture(cfg.item_card_icon_value)
    self.card_val_icon:SetTextureColor(getargb( cfg.colors.clr_text_light ))
    self.card_val_icon:Show(true)

    offset = elem_x + self.card_val_icon:GetWidth()
    self.card_val_text = self.xml:InitStatic("box", self.card_val)
    self.card_val_text:SetWndSize(vector2():set(0, elem_h))
    self.card_val_text:SetWndPos(vector2():set(offset, text_y - 0.5))
    self.card_val_text:TextControl():SetFont(get_font(cfg.font_item_card or 0))
    self.card_val_text:TextControl():SetText(value)
    self.card_val_text:TextControl():SetTextColor(getargb( cfg.colors.clr_text_light )) 
    self.card_val_text:AdjustWidthToText()
    self.card_val_text:Show(true)
    local value_w = offset + self.card_val_text:GetWidth()
    self.card_val:SetWndSize(vector2():set(value_w + 6, elem_h))
    self.card_val:InitTexture("ui_catsy_card_drop")
    self.card_val:SetTextureColor(getargb( cfg.colors.clr_card_drop ))
    self.card_sp_icon = self.xml:InitStatic("box", self.itemcard)
    self.longest_card = math.max(weight_w, value_w)

    self:UpdateFaveJunkIcon()

    self.itemcard:Show(true)
end

function InteractPrompt:UpdateFaveJunkIcon()
    if not (zzz_rax_sortingplus_mcm and cfg.sp_flag_favejunk) then return end
    if not self.card_sp_icon then return end

    local texture = (is_favorite(self.args.section) and cfg.icon_sp_fave_texture) or
                    (is_junk(self.args.section) and cfg.icon_sp_junk_texture) or
                    ""
    self.card_sp_icon:InitTexture(texture)
    local has_icon = (texture ~= "")
    self.card_sp_icon:Show(has_icon)
    if not has_icon then return end

    self.card_sp_icon:SetWndPos(vector2():set(self.longest_card + fontscale(cfg.sp_icon_pos_x or 0), (cfg.sp_icon_pos_y or 0)))
    self.card_sp_icon:SetWndSize(vector2():set(16 * cfg.unsquish_ratio, 16))    
end

function InteractPrompt:SetupUtjanPartDots(anchor, obj)
    -- Adapted from z_item_icon_info in Utjan's Item UI
    if not cfg.show_part_condition then return end
    if not item_icon_info_mcm then return end
    if self.parts_indicators then
        for k,v in pairs(self.parts_indicators) do
            self.parts_indicators[k]:Show(false)
        end
    end

    obj = obj or (self.args.id and get_object_by_id(self.args.id))
    sec = obj and obj:section()
    cls = obj and obj:clsid()

    if not (obj and has_parts(obj)) then return end
    if (not cfg.show_parts_weapons) and IsWeapon(nil, cls) then return end
    if (not cfg.show_parts_armor) and (IsHeadgear(nil, cls) or IsOutfit(nil, cls)) then return end

    local se_parts = item_parts.get_parts_con(obj, nil, true)
    if is_empty(se_parts) then return end
    local parts = dup_table(se_parts)

    local sep = (cfg.parts_dot_sep_width or 2)
    local base_x = (cfg.parts_dot_pos_x or 0)
    self.parts_container = self.xml:InitStatic("box", anchor or self.wnd)
    self.parts_container:SetWndPos(vector2():set(base_x, cfg.parts_dot_pos_y or 0))
    self.parts_indicators = self.parts_indicators or {}

    self.xml:ParseFile("ui_utjan_icon_info.xml")
    for part, v in pairs(parts) do
        if SYS_GetParam(1, part, "cond_part") then
            self.parts_indicators[part] = self.parts_indicators[part] or self.xml:InitStatic("cond_dot", self.parts_container)
        else
            parts[part] = nil
        end
    end

    local i = 0
    local size = 0
    for part, condition in spairs(parts, parts_sort) do
        local cond_dot_h = 4
        local cond_dot_w = cond_dot_h * cfg.unsquish_ratio
        cond_dot_h = cond_dot_h * 1
        cond_dot_w = cond_dot_w * 1

        self.parts_indicators[part]:SetWndRect(Frect():set(0, 0, cond_dot_w, cond_dot_h))
        
        local x = base_x + 1 + (cond_dot_w + sep) * i
        local y = 0
        self.parts_indicators[part]:SetWndPos(vector2():set(x, y))

        local c = get_condition_color(condition)
        local color = get_argb(c.a, c.r, c.g, c.b)

        if color then
            self.parts_indicators[part]:SetTextureColor( color )
        end
        self.parts_indicators[part]:Show(true)
        size = x + cond_dot_w + sep
        i = i + 1
    end
    self.parts_container:SetWndSize(vector2():set(size, 0))
    self.parts_container:InitTexture(cfg.main_drop_texture)
end



function InteractPrompt:eleSetCurrentColor(element, a, r, g, b)
    --printf("[InteractPrompt:eleSetCurrentColor] %s | %s | %s | %s", a, r, g, b)
    if not element then return end
    local argb = get_argb(a, r, g, b)
    if element.SetTextureColor  then element:SetTextureColor(argb) end
    if element.TextControl      then element:TextControl():SetTextColor(argb) end
    element.currcolor = {
        a = tonumber(a) or 255,
        r = tonumber(r) or 255,
        g = tonumber(g) or 255,
        b = tonumber(b) or 255
    }
    --printf("Current colors set to %s,%s,%s,%s", element.currcolor.a, element.currcolor.r, element.currcolor.g, element.currcolor.b)
end

function InteractPrompt:eleSetCurrentColorScheme(element, c)
    c = c or element.basecolor or self.text_color_default
    self:eleSetCurrentColor(element, c.a, c.r, c.g, c.b)
end

function InteractPrompt:eleSetBaseColorScheme(element, c)
    element.basecolor = c or self.text_color_default
    self:eleSetCurrentColorScheme(element, c)
end

function InteractPrompt:GetARGB(clr_tbl)
    return clr_tbl and get_argb({
        a = clr_tbl.a,
        r = clr_tbl.r,
        g = clr_tbl.g,
        b = clr_tbl.b
    })

end

function InteractPrompt:Event(set)
    if set and self.args then self.args.event = set end
    return set or (self.args and self.args.event) or "sec_interact"
end

function InteractPrompt:BindKey(set)
    if set and self.args then self.args.key = set end
    return set or (self.args and self.args.key) or cfg["bind_" .. self:Event()] or 0
end

function InteractPrompt:ModKey(set)
    if set and self.args then self.args.mod = set end
    return set or (self.args and self.args.mod) or cfg["modk_" .. self:Event()] or 0 
end

function InteractPrompt:InputMode(set)
    if set and self.args then self.args.imod = set end
    return set or (self.args and self.args.imod) or 0 
end

function InteractPrompt:SetBindText(text)
    text = text or (self.args and self.args.bind) or ""
    self.bind:TextControl():SetText(text)
    self.bind_sh:TextControl():SetText(text)
end


function InteractPrompt:on_key_hold(key)
    if (self.disabled or self.destroyed or self.busystate) then return end
    
    if (key == self.args.key) and (self.args.mode == 2) and ui_mcm.get_mod_key(self.args.mod) then
        local now = time_global()
        if ui_mcm.key_hold(self.uid, key, 5) then
            local tid = get_current_target()
            local obj = tid and get_object_by_id(tid) or nil
            cfg.last_hold   = {
                key         = cfg.held_key,
                time        = now,
                by          = self
            }
            self.peak_hold  = nil
            cfg.held_key    = nil
            cfg.held_mod    = nil
            cfg.held_time   = nil
            cfg.holding     = nil
            cfg.use_released= cfg.use_released or now
            --printf("[%s][InteractPrompt:on_key_hold] Setting cfg.use_released to %s", now, cfg.use_released)
            self.longpress:SetProgressPos(0)
            self.args.func(obj, self.args.mark)
            return
        elseif cfg.last_hold and (cfg.last_hold.key == self.args.key) and not timed_out(cfg.last_hold.time, cfg.long_press_delay or 50) then
            --printf("[%s][InteractPrompt:on_key_hold] Tried to start another hold too soon, aborting", now)
            return
        end

        if not cfg.held_key then
            --printf("[%s][InteractPrompt:on_key_hold] Beginning hold of key %s", now, self.args.key)
        end
        cfg.held_key    = key
        cfg.holding     = self
        cfg.held_mod    = self.args.mod
        cfg.held_time   = ui_mcm and ui_mcm.hold[key] and ui_mcm.hold[key][self.uid]
    end
end


function InteractPrompt:on_key_press(key, flags)
    if (self.disabled or self.destroyed or self.busystate) then return end

    if (key == self.args.key) then
        if not ui_mcm then
            self.args.func()
            return
        end

        if (self.args.mode == 0) then
            ui_mcm.simple_press(self.uid, key, self.args.func)
        end
    
        if (self.args.mode == 1) and ui_mcm.get_mod_key(self.args.mod) and ui_mcm.double_tap(self.uid, key) then
            self.args.func()
            return
        end
    end    
end

function InteractPrompt:actor_on_net_destroy() self:Destroy("shutdown") end

function InteractPrompt:on_option_change()
    if self.args.tutorial and self.init_done then
        self:Destroy()
        return
    end
    if self.args.pri then
        self.args.key   = self.args.key or bind_to_dik(key_bindings.kUSE)
    else
        local sec       = cfg.bind_sec_interact
        local tap_time  = self.args.tap_time or ui_mcm.get("mcm/mcm_kb/mcm_kb_main/dtaptime2")
        self.hold_time  = (self.args.hold_time or ui_mcm.get("mcm/mcm_kb/mcm_kb_main/presstime")) * tap_time
        --self.unbound    = (not sec) or (sec == -1)
        self.args.key   = cfg["bind_" .. (self.args.event or "")] or sec or 0
        self.args.mod   = cfg["modk_" .. (self.args.event or "")] or sec or 0 
        self.args.mode  = cfg["imod_" .. (self.args.event or "")] or sec or 0
    end

    self:BuildUI()

    self.bind_sh:Show((not self.black_text) and (not cfg.hide_drop_shadow))
    self.label_sh:Show(not cfg.hide_drop_shadow)
end

function InteractPrompt:BusyState(tf, prefix, force_update)
    local last_state = self.busystate
    self.busystate = not not tf
    if force_update or ((tf ~= nil) and (self.busystate ~= last_state)) then
        vl("InteractPrompt:BusyState has changed to %s, updating prompt visuals", self.busystate)
        if self.busystate then
            self.active_prefix  = (prefix or gts("st_alti_busy")) .. " "
            self.active_prompt  = first_lower(self.active_prompt)
            if self.text_color_busy then
                self:eleSetCurrentColorScheme(self.label, self.text_color_busy)
                self:eleSetCurrentColorScheme(self.bind, self.text_color_busy)
            end
        else
            self.active_prefix = self.args.act
            self:eleSetCurrentColorScheme(self.label, self.text_color_light)
            self:eleSetCurrentColorScheme(self.bind, self.black_text and self.text_color_dark or self.text_color_light)
            self.active_prompt  = first_upper(self.active_prompt)
        end
        if self.itemcard and cfg.show_item_card then
            self.itemcard:Show(not tf)
        end
        if self.parts_container and cfg.show_item_card then
            self.parts_container:Show(not tf)
        end
        self:RegisterScriptCallbacks(not self.busystate)
        self:SetPrompt()
    end
    return self.busystate
end

function InteractPrompt:AbortFadeIn() return self.fading_out or not self.fading_in end
function InteractPrompt:AbortFadeOut() return self.fading_in or not self.fading_out end

function InteractPrompt:SetAlpha(element_name, alpha, text_also)
    coef = coef or 1
    alpha = clamp(alpha, 0, 255)
    if self[element_name] then
        local ele = self[element_name]
        local c = {}
        if ele.GetTextureColor then
            local i = ele:GetTextureColor()
            c.r,c.g,c.b,c.a = i and int_to_rgba(i)
            c.a = alpha or c.a
            ele:SetTextureColor(get_argb(c.a,c.r,c.g,c.b))
        end
        if text_also then
            c = ele.currcolor or ele.basecolor or {}
            c.a = alpha or c.a
            c.r = c.r or 255
            c.g = c.g or 255
            c.b = c.b or 255
            ele.currcolor = c
            ele:TextControl():SetTextColor(get_argb(c.a,c.r,c.g,c.b))
        end
    end
end

function InteractPrompt:ManageFadeAnim(
        alpha_start, alpha_end, 
        duration, event_id, instanced, 
        r, g, b, 
        anim_curve_modifier_func, on_finish_func, abort_func
    )
    local fade_dir = (alpha_start > alpha_end) and "out" or "in"
    --printf("Initializing fade %s at %s", fade_dir, time_global())
    if (event_id == nil) then event_id = "anim_fade" end
    local anim_id = event_id.."_"..tostring(time_global())
    r = r or 255
    g = g or 255
    b = b or 255

    if active_anims[event_id] then
        alpha_start = active_anims[event_id].a
        -- Repeat invocation of non-instanced fade event, aborting fade and starting anew
        active_anims[event_id] = nil
        if on_finish_func then on_finish_func(self) end
    end

    --printf("anim_fade: start %s end %s dur %s | event_id %s | instanced %s ",alpha_start,alpha_end, duration,event_id,instanced)

    local anim_state = 0
    local start_time= time_global()
    local end_time  = time_global() + duration
    local anim_curve_modifier_func = anim_curve_modifier_func or function(x) return x end
    active_anims[event_id] = {
        instanced   = instanced and true or false,
        anim_id     = anim_id,
        start_time  = start_time,
        end_time    = end_time,
        active      = true,
        a_start     = alpha_start,
        a_end       = alpha_end,
        a           = alpha_start,
        r           = r,
        g           = g,
        b           = b,
    }
    
    --vl("Creating fade-%s time event %s | %s",fade_dir,event_id,anim_id)
    CreateTimeEvent("animate_fade"..event_id..anim_id, time_global(), 0, 
        function()
            local abort = abort_func and abort_func(self)
            if abort then
                --printf("Received abort for %s",event_id)
                anim_state = 1
            else
                local anim = active_anims[event_id]
                if anim then
                    local x = anim_curve_modifier_func(anim_state)
                    local alpha = lerp(alpha_start, alpha_end, x)
                    self.curr_alpha = alpha
                    for k,v in pairs(self.elements) do
                        self:SetAlpha(k, alpha, v)
                    end
                    --printf("Fade-%s time event: setting transparency for %s to %s at time %s",fade_dir,event_id,alpha,time_global())
                else
                    --printf("Event data for %s has cleared, aborting",event_id)
                    anim_state = 1
                end
            end

            if (anim_state == 1) then
                --printf("Fade-%s animation %s completed at %s",fade_dir,event_id,time_global())
                if on_finish_func then on_finish_func(self) end
                return true
            end
            anim_state = math.min(1, normalize(time_global(), start_time, end_time))
        end
    )
end

function InteractPrompt:AnimateFade(inout)
    --printf("[InteractPrompt:AnimateFade] %s", inout)
    if inout and self.fading_in then return end
    if (not inout) and self.fading_out then return end


    local uid = "prompt_fade" .. self.args.event
    if not self.curr_alpha then
        self.curr_alpha = 0
    end
    --printf("curr alpha: %s", self.curr_alpha)
    if inout then
        if self.fading_out then
            --printf("flagging fadeout cancel")
            self.fading_out = false
        end
        if (self.curr_alpha ~= 255) and (cfg.prompt_fade_in_time and (cfg.prompt_fade_in_time > 0)) then
            vl("Beginning new fade-in effect over %sms from alpha %s to 255 at %s", cfg.prompt_fade_in_time, self.curr_alpha, time_global())
            self.fading_in = true
            self:ManageFadeAnim(
                self.curr_alpha, 255, cfg.prompt_fade_in_time, uid .. "in", false, nil, nil, nil, 
                nil,--fade_curve,
                nil, self.AbortFadeIn
            )
        end
    else
        if self.fading_in then
            --printf("flagging fadein cancel")
            self.fading_in = false
        end
        if (self.curr_alpha ~= 0) and (cfg.prompt_fade_out_time and (cfg.prompt_fade_out_time > 0)) then
            vl("Beginning new fade-out effect over %sms from alpha %s to 0 at %s", cfg.prompt_fade_out_time, self.curr_alpha, time_global())
            self.fading_out = true
            self:ManageFadeAnim(
                self.curr_alpha, 0, cfg.prompt_fade_out_time, uid .. "out", false, nil, nil, nil, 
                nil,--fade_curve,
                self.UpdatePromptVisibility, self.AbortFadeOut
            )
        end
    end
end
        
function InteractPrompt:UpdatePromptVisibility(tf)
    self.wnd:Show(tf)
end

function InteractPrompt:RegisterScriptCallbacks(tf)
    if self.callbacks_set and not tf then
        UnregisterScriptCallback("on_key_hold", self)
        UnregisterScriptCallback("on_key_press", self)
        self.callbacks_set = false
    elseif tf and not self.callbacks_set then
        RegisterScriptCallback("on_key_hold", self)
        RegisterScriptCallback("on_key_press", self)
        self.callbacks_set = true
    end
end

function InteractPrompt:OnVisibilityChange(state, reason)
    local _ = debug_dump and vl("[%s][InteractPrompt:OnVisibilityChange] to %s%s", time_global(), state, reason)

    self:RegisterScriptCallbacks(state)

    if self.campfire_tut then
        _ = debug_dump and vl("Checking campfire state for %s", self.args.tutorial)
        local obj = get_nearby_campfire(5, false)
        if obj then
            local id = obj:id()
            self.mark = id and cfg.markers[id]
            if self.mark then
                self.mark:ActiveSwap(state)
                if state and can_start_popin_anim(self.mark) then
                    init_active_marker_popin(self.mark)
                end
            end
        else
            dl("Clearing stuck tutorial %s at %s", self.tutorial, time_global())
            self:Destroy()
        return end
    end
end

function InteractPrompt:ShowPrompt(tf, reason)
    if (tf and self.destroyed) then return end
    tf = not not tf
    reason = reason and (" (" .. reason .. ")") or ""
    self.peak_hold = nil
    local _ = debug_dump and vl("ShowPrompt %s: %s%s", self.active_prompt, tf, reason)
    --printf("[%s][%s][InteractPrompt:ShowPrompt] %s: %s", time_global(), self.args.id, self.active_prompt, tf)
    self.line:SetProgressPos(tf and (not cfg.hide_connecting_line) and 1 or 0)
    if self.longpress and not tf then
        self.longpress:SetProgressPos(0)
    end
    self.disabled = not tf
    if self.last_state ~= self.disabled then
        self.last_state = self.disabled
        self:OnVisibilityChange(tf, reason)
    end
    self:AnimateFade(tf)
    if not self.fading_out then
        self:UpdatePromptVisibility(tf)
    end
end

function InteractPrompt:Prefix(set)
    if set then self.active_prefix = set end
    return (set or self.active_prefix or (self.args and self.args.act) or "")
end

function InteractPrompt:Prompt(set)
    if set then self.active_prompt = set end
    return (set or self.active_prompt or (self.args and self.args.text) or "")
end

function InteractPrompt:Suffix(set)
    if set then self.active_suffix = set end
    return (set or self.active_suffix or (self.args and self.args.suffix) or "")
end

function InteractPrompt:GetFullPrompt(prefix, prompt, suffix)
    return self:Prefix(prefix) .. self:Prompt(prompt) .. self:Suffix(suffix)
end

function InteractPrompt:SetPrompt(new_prefix, new_prompt, new_suffix)
    local new_text  = self:GetFullPrompt(new_prefix, new_prompt, new_suffix)
    local color_text, plain_text

    if self.parse_text_colors then
        color_text = parse_colors(new_text, nil, true)
        plain_text = parse_colors(new_text, nil, false)
    end
    local _ = debug_dump and vl("InteractPrompt:SetPrompt(%s, %s, %s) | %s", new_prefix, new_prompt, new_suffix, new_text)
    self.label:TextControl():SetText(color_text or new_text)
    self.label_sh:TextControl():SetText(plain_text or new_text)
    self.lref:TextControl():SetText(plain_text or new_text)
    self.lref:AdjustWidthToText()
    local pos = self:UpdatePromptLength()
    self.drop:SetWndSize(vector2():set(pos + fontscale(55), fontscale(22)))
end

function InteractPrompt:GetQuickHelp()
    local hint = maingameui.UIStaticQuickHelp:GetText()
    if (hint == "") or (hint == " ") then hint = nil end
    --printf("Contents of QuickHelp static: \"%s\"", hint)
    return hint or nil
end

function InteractPrompt:SetQuickHelp(text)
    maingameui.UIStaticQuickHelp:SetText(text)
end

function InteractPrompt:UpdateLongPress()
    if self.longpress then
        if (not self.busystate) and (cfg.held_key == self.args.key) and (cfg.held_mod == self.args.mod) then
            --printf("cfgkey %s | argskey %s | cfgmod %s | argsmod %s", cfg.held_key, self.args.key, cfg.held_mod, self.args.mod)
            self.peak_hold = time_continual() - (cfg.held_time or 0)
            local prog = (self.peak_hold / self.hold_time)
            self.longpress:SetProgressPos(prog)
            CUIScriptWnd.Update(self)
        else
            self.longpress:SetProgressPos(0)
        end
    end
end

function InteractPrompt:UpdateFilteredHints(hint)
    --printf("[InteractPrompt:UpdateFilteredHints][%s][%s][%s]", self.args.id, self.args.event, self.args.name)
    self.last_hint_match = nil
    if not (self.args.is_door or is_already_target(self.args.id)) then return end
    hint = hint or self:GetQuickHelp()
    
    if not hint then return end
    -- QuickHelp static is empty, nothing to filter

    if not self.args.hint_filters then return end
    -- No filters to process
    
    local filters = self.args.hint_filters

    for k,v in pairs(filters) do
        if (hint == k) then
            self.last_hint_match = hint
            if is_vanilla_ui_hidden() then
                local _ = debug_dump and vl("Filter match %s found, hiding QuickHelp static contents", hint)
                self:SetQuickHelp("")
            end
            if self.args.refresh_text then
                self.args.text = v
                self:SetPrompt(self.args.text)
                return
            end
        end
    end
    return hint
end

function InteractPrompt:UpdateDoorState()
    local hint  = self:GetQuickHelp()
    if self.door and self.door.tip then
        local tip   = self.door.tip()
        local msg   = tip and gts(tip)
        if hint and msg and (hint == msg) then
            if is_vanilla_ui_hidden() then
                --printf("Hiding vanilla hint")
                self:SetQuickHelp("")
            end
            hint = msg
        end
    else
        hint = self:GetQuickHelp()
    end
    return hint and trimmed_prompt(hint)
end

function InteractPrompt:actor_on_update()
    if self.destroyed then return end
    local _ = debug_dump and vl("[%s][%s]InteractPrompt:actor_on_update | %s%s", self.args.id, self.args.event, self.init_done and "" or "first run at ", time_global())
    local hint

    if self.args.hint_filters then
        hint = self:UpdateFilteredHints(hint)
    end

    if (self.args.tutorial or self.args.is_stalker) then
        _ = (not self.init_done) and vl("Updates for this type are handled in main loop")
        return
    end

    if self.disabled then return end

    if self.args.pri then
        if (
            self.door or
            (not self.args.text) or
            (self.args.text == "")
        ) then
            hint = self:UpdateDoorState()
            self:SetPrompt(nil, hint or self.args.text or "")
        end
        self:UpdateFaveJunkIcon()
    else
        self:UpdateLongPress()
    end
    
    if is_dead_mutant(self.args) and self.args.section then
        local can_loot, loot_msg = can_chop_body(self.args.section)
        local changed = (loot_msg ~= self.last_loot_msg)
        self.last_loot_msg = loot_msg
        local prefix = (not can_loot) and gts("st_alti_cannot") or nil
        self:Suffix(can_loot and "" or (loot_msg and (": " .. gts(loot_msg))) or "")
        self:BusyState(not can_loot, prefix, changed)
    end

    if ea_enabled and cfg.alti_busy_during_anim and not self.busy_locked then
        self:BusyState(anim_playing)
    end
end

function InteractPrompt:Destroy(reason)
    self:ShowPrompt(false)
    self.hint_filters   = nil
    self.tutorial       = nil
    self.destroyed      = true
    get_hud():RemoveDialogToRender(self)
    
    if reason then
        dl("[InteractPrompt:Destroy][%s][%s]", self.args.id, reason)
    end
end

-- =======================================================================
--      MAIN LOGIC
-- =======================================================================

function uiscale(i)
    return i * (_uiscale or 1)
end

function get_font(num)
    local font = fonts[num or cfg.font_main_prompt or fallback_font]
    return font and font.font
end

function get_font_size(num)
    local font = fonts[num or cfg.font_main_prompt or fallback_font]
    return font and font.size
end

function get_font_scale(num)
    local scale = get_font_size() / 16
    return scale
end

function fontscale(i)
    return i * get_font_scale()
end

function is_dead_body(args)
    return args.is_npc and not args.is_alive
end

function is_dead_mutant(args)
    return args.is_mutant and not args.is_alive
end

function can_chop_body(section)
    -- Don't think this is working with the "knife in inventory" flavor of mod
    -- Need to figure out why
    if not section then return end
    local result, tip
    if (item_knife.is_equipped()) then
        -- knife equipped
        if (item_knife.get_condition() < 0.15) then
            -- bad condition
            tip = "st_body_knife_bad"
        elseif (not item_knife.can_loot(section)) then
            -- weak knife
            tip = "st_body_knife_weak"
        else
            result = true
            tip = "st_body_loot"
        end
    else
        -- no knife
        tip = "st_body_knife_needed"
    end
    --printf("can_chop_body: %s | %s", result, tip)
    return result, tip
end

function is_actor_in_sleep_zone()
    for k,v in pairs(ui_sleep_dialog.sleep_zones) do
        if utils_obj.npc_in_zone(db.actor, v) then
            return true
        end
    end
end

function get_current_target()
    --printf("current target: %s | L %s | T %s", locked_id or targeted_id, locked_id, targeted_id)
    return locked_id or targeted_id or nil
end

function is_current_target(id)
    if not id then return end
    local curr_target = get_current_target()
    --printf("id %s is %sthe current target", id, curr_target and (id == curr_target) and "" or "not ")
    return curr_target and (id == curr_target)
end

function get_current_target_obj()
    local id = get_current_target()
    return id and get_object_by_id(id)
end

function get_target_pickup()
    local id = get_current_target()
    return id and cfg.markers[id] and cfg.markers[id].pickup and get_object_by_id(id) or nil
end

function is_pickup_targeted()
    local pickup = get_target_pickup()
    return not not pickup
end

function get_target_container()
    local body, box
    local obj   = get_current_target_obj()
    local id    = obj and obj:id()
    local mark  = id and cfg.markers[id]
    body        = mark and mark.is_stalker and not mark.is_alive

    if not body then
        local cls   = obj and obj:clsid()
        box         = cls and IsInvbox(nil, cls)
    end

    return body or box
end

function state_monitor(tid)
    local state = tid and modxml_tutorial_hooks and modxml_tutorial_hooks.monitors and modxml_tutorial_hooks.monitors[tid] and modxml_tutorial_hooks.monitors[tid].state
    local conds = state and cfg.state_conds and cfg.state_conds[tid] or nil
    local cond  = true
    if state and (conds ~= nil) then
        cond = cfg.state_conds[tid](tid)
    end
    --printf("state_monitor check for %s: state %s | conditions %s", tid, state, cond)
    cfg.monitors[tid] = state and cond or false
    return cfg.monitors[tid]
end

function show_interaction_dots(tf)
    cfg.hide_interaction_dots = not tf
end

function actor_on_first_update()
    hmm = utils_catspaw_hudmarks and utils_catspaw_hudmarks.get_hud_mark_manager()
    assert(hmm, "\n\n"..
        "! ERROR: The Hud Mark Manager could not be found! Something must be seriously wrong with utils_catspaw_hudmarks!\n\n"
    )
    if not cfg.markers then cfg.markers = {} end
    assert(db.actor.get_actor_object_looking_at or (not cfg.assert_modded_exes),
        "! ERROR: The function `db.actor.get_actor_object_looking_at` does not exist, which means the `actor_on_update_pickup` callback doesn't either. Both are required for DotMarks to function.\n" ..
        "\nYou must update to modded exes 20250306 or newer. Get them here:\n" ..
        "https://github.com/themrdemonized/xray-monolith"
    )
    maingameui = ActorMenu.get_maingame()
    xml = CScriptXmlInit()
    CreateTimeEvent("dotmark_scan_delay", time_global(), cfg.scan_start_delay, start_scanning)
end

function start_scanning()
    scanning = true
    return true
end

function stop_scanning()
    scanning = false
    return true
end

function get_args_for_valid_objects(obj)
    if not obj then return end
    local id = obj:id()
    local cls = obj:clsid()
    local sec = obj:section()
    local kind = get_obj_kind(obj)

    --vl("get_args_for_valid_objects: %s - clsid %s", nameid(nil, id), cls)
    if is_blacklisted(id, cls, sec, kind) then
        vl("Object matched one or more blacklists: id %s | cls %s | sec %s | kind %s", cfg.blacklisted_ids[id], cfg.blacklisted_clsids[cls], cfg.blacklisted_sections[sec], cfg.blacklisted_kinds[kind])
    return end

    local args = { logged_type = "something else", section = sec, clsid = cls }

    local function setup_item_args(iclass)
        args = get_cfg_for_type("args", iclass, obj) or {}
        args.id = id
        args.clsid = cls
        args.hidden = not cfg.scan[iclass]
        args.has_power = (item_device.dev_consumption[sec] or (sec == "batteries_dead")) or nil
    end

    local ktype = get_type_for_kind(kind)
    if ktype then
        vl("Kind %s found in lookup: %s", kind, ktype)
        setup_item_args(ktype)
    else
        local stype = get_type_for_section(sec)
        if stype then
            vl("Section %s found in lookup: %s", sec, stype)
            setup_item_args(stype)
        else
            for item_class, enabled in pairs(cfg.scan) do
                --printf("Checking %s against category %s", obj:name(), item_class)
                if cfg.is_item[item_class](obj) then
                    vl("Type found via iteration: %s", item_class)
                    setup_item_args(item_class)
                    break
                end
            end
        end
    end
    
    if not args.texture then
        local pid = cfg.available_pickup
        if (id == pid) then
            printf("! Obj %s failed classification, but is detected by engine as a pickup!\n"..
                "$ Classifying \"Misc\" as a fallback, investigate: section %s | clsid %s | kind %s",
                nameid(nil, id), sec, cls, kind
            )
            setup_item_args("Misc")
        else
            return
        end
    end
    if not args.texture then return end

    dl("get_args_for_valid_objects: %s is %s", nameid(obj), args.logged_type)
    return args
end

-- =======================================================================

function handle_primary_interact()
    -- no additional logic at this time, just need a stub function here
end


function setup_pri_interact_prompt(mark, args)
    vl("[%s] setup_pri_interact_prompt for %s", mark.mark_id or "fixed interaction", args and (args.name or args.logged_type) or "unknown type with no passed args")
    if not mark then return end
    if mark.use_pri then
        mark.use_pri:Destroy("re-init of existing prompt")
        mark.use_pri = nil
    end
    args            = args or {}
    local anchor    = mark.marker or args.anchor
    --local obj       = mark.id and get_object_by_id(mark.id)
    local key       = bind_to_dik(key_bindings.kUSE)
    local bind_text = bindtext(key, 0)
    local int_text  = trimmed_prompt(maingameui.UIStaticQuickHelp:GetText())

    if mark.pickup then
        int_text = gts("st_alti_take") .. " " .. (mark.money or mark.name)
    elseif mark and mark.is_stalker and mark.is_alive then
        int_text = gts("st_alti_speak") .. " " .. mark.name
    elseif mark and mark.is_door then
        int_text = int_text or trimmed_prompt(cfg.prompts.open_door)
    elseif mark and (mark.is_stash or (mark.is_stalker and not mark.is_alive)) then
        int_text = gts("st_alti_search") .. " " .. mark.name
    elseif mark and (mark.is_npc and not mark.is_alive) then
        int_text = gts("st_body_loot")
    end

    local passed_args = {
        pri     = true,
        --mark    = mark,
        name        = mark.name or args.name or nil,
        text        = int_text,
        bind        = bind_text,
        key         = key,
        section     = section,
        func        = args and args.pri_handler_func or handle_primary_interact,
        event       = "pri_interact",
        monitors    = mark.monitors,
    }
    if args and not is_empty(args) then for k,v in pairs(args) do passed_args[k] = v end end

    mark.use_pri = InteractPrompt(anchor or maingameui, passed_args)
    return mark.use_pri
end


function setup_sec_interact_prompt(mark)
    if not mark then return end
    if mark.alt_interact then return end
    local id        = mark.id
    vl("[%s][%s] setup_sec_interact_prompt for %s", id, mark.mark_id, mark.name)
    local anchor    = mark.marker
    local obj       = id and get_object_by_id(id)
    local section   = obj and obj:section()
    local mode      = cfg.imod_sec_interact
    local act_text  = (mode == 2) and gts("st_alti_hold").." " or (mode == 1) and gts("st_alti_doubletap").." " or ""
    local bind_text = bindtext(cfg.bind_sec_interact, cfg.modk_sec_interact)
    local int_text  = ""
    local func      = handle_secondary_interact

    if obj and IsWeapon(obj) then
        local atype     = obj:get_ammo_type() + 1
        local ammos     = parse_list(ini_sys, obj:section(), "ammo_class")
        local sec       = ammos and atype and ammos[atype]
        local ammo      = get_localization(nil, nil, sec)
        int_text        = string.format(gts("st_alti_prompt_ammo"),
            mag_installed and gts("st_alti_eject_mag") or gts("st_alti_unload_weapon"),
            ammo,
            mark.ammo_count,
            gts("st_alti_from"),
            mark.name
        )
        func = unload_and_take_ammo
    elseif IsInvbox(nil, mark.clsid) then
        -- Inventory box or stash
        local weight = nil
        if not obj:is_inv_box_empty() then
            local tbl = axr_companions.get_inventory_table(obj, id, 1)
            weight = axr_companions.get_inventory_weight(tbl)
        end
        if (section == "inv_backpack") then
            -- Pick up backpack and everything in it
            int_text = first_upper(gts("st_alti_pickup_bp"))
            func = pick_up_backpack
        else
            -- Take everything from box
            int_text = string.format("%s %s",
                first_upper(gts("st_alti_takeall")),
                mark.name
            )
            func = take_all_from_box
        end
    --elseif section and (IsItem("eatable", section)) then
    elseif cfg.is_item.Tools(obj) then
        -- Usable tool
        local verb      = mark.use_verb or "st_alti_takeuse"
        int_text        = string.format(gts("st_alti_prompt_usable"),
            gts(verb),
            mark.name,
            gts("st_alti_now")
        )

    elseif cfg.is_item.Consumables(obj) then
        -- Consumable
        local verb      = mark.use_verb or (
            (mark.kind == "i_medical") and "st_alti_use_booster" or
            (cfg.smokables[section] and "st_alti_smokeout") or
            "st_alti_consume_food"
        )
        int_text        = string.format(gts("st_alti_prompt_usable"),
            gts(verb),
            mark.name,
            gts("st_alti_now")
        )
    elseif (mark.kind == "i_letter") then
        -- Readable
        int_text        = string.format(gts("st_alti_prompt_usable"),
            gts("st_alti_read"),
            mark.name,
            gts("st_alti_now")
        )
        func = take_and_read
    elseif section and IsItem("device", section) then
        -- Device with battery power
        --printf("setting up secondary interact for device")
        int_text        = string.format(gts("st_alti_prompt_usable"),
            first_upper(gts("st_item_unpack_battery")),
            gts("st_alti_from"),
            mark.name
        ) 
        func = unpack_batteries
    elseif (mark.clsid == clsid.equ_backpack) then
        -- Backpack inventory item
        --printf("setting up secondary interact for backpack item")
        int_text        = string.format("%s %s",
            first_upper(gts("st_alti_deploy_bp")),
            mark.name
        )
        func = deploy_backpack
    else
        -- Fallback to generic "use" prompt
        int_text        = string.format(gts("st_alti_prompt_booster"),
            gts("st_alti_takeuse"),
            mark.name,
            gts("st_alti_now")
        )
    end

    local args = {
        mark    = mark,
        name    = mark.name,
        text    = int_text,
        act     = act_text,
        bind    = bind_text,
        long    = (mode == 2),
        func    = func,
        id      = id,
        event   = "sec_interact",
    }

    mark.alt_interact = InteractPrompt(anchor or maingameui, args)
end

-- =======================================================================

local scanned = {}

function unregister_scanned_entity(id)
    if not id then return end
    local name = scanned[id]
    local ind = pickup_index[id]
    if ind then
        nearby_pickups[ind] = nil
    end
    pickup_index[id] = nil
    cfg.in_pickup_range[id] = nil
    if cfg.markers[id] then
        local mark = cfg.markers[id]
        if mark.use_pri then
            mark.use_pri:Destroy("unregistering pri use" .. id)
        end
        if mark.alt_interact then
            mark.alt_interact:Destroy("unregistering sec use")
        end
        mark:Destroy()
        cfg.markers[id] = nil
    end
    scanned[id] = nil

    vl("Unregistering scanned entity for %s and nulling all pointers to it", nameid(name, id))
end


function marked_obj_has_ammo(id)
    return id and cfg.markers[id] and (cfg.markers[id].ammo_count and cfg.markers[id].ammo_count > 0)
end


function obj_has_available_sec_interact(obj, id, mark)
    if not (obj or id) then return end
    if mark and (mark.no_sec or mark.is_display) then return false end

    id = id or (obj and safeid(obj))
    obj = obj or (id and get_object_by_id(id))
    if not obj then return end
    if cfg.useless_shit[obj:section()] then return end

    local cls           = obj and obj:clsid()
    local is_melee      = IsMelee(nil, cls)
    local has_ammo      = marked_obj_has_ammo(id) and not is_meele
    local is_consumable = cfg.is_item.Consumables(obj)
    local is_readable   = (mark and mark.is_readable)
    local has_batteries = (mark and mark.has_battery)
    local is_backpack   = (mark and mark.is_backpack)
    local is_invbox     = (mark and mark.is_stash) or is_backpack

    local required      = (
        is_consumable or
        has_batteries or
        is_readable or
        has_ammo or
        is_invbox
    )

    local banned        = (
        mark.money
    )

    local has_interact = required and not banned

    local _ = debug_dump and (
        vl("obj_has_available_sec_interact: %s | %s | ammo %s | eatable %s | readable %s | money %s",
            has_interact,
            nameid(obj, id),
            has_ammo,
            is_consumable,
            is_readable,
            mark.money
        )
    )
    return has_interact
end


function scan_nearby_object(obj)
    local id  = obj and obj:id()
    if not valid_id(id) then return end
    local name = obj and obj:name()

    if scanned[id] then
        -- Skip previously-scanned IDs if their name matches, otherwise clear the table entry assuming it's a reused ID
        if scanned[id] == name then
            --vl("%s has already been scanned, skipping", nameid(name, id))
        return end
        vl("%s has a new name, assuming the ID has been reused and clearing entry", id)
        scanned[id] = nil
    end

    --printf("scanning %s", nameid(name, id))

    local m_id  = "dotmark_" .. tostring(id)
    hmm = hmm or utils_catspaw_hudmarks.get_hud_mark_manager()
    if not hmm then return end

    local cls = obj:clsid()
    local sec = obj:section()

    if hmm:GetMarker(m_id) then
        --vl("[ID %s] Existing marker found for mark_id %s, skipping", id, m_id)
    else
        scanned[id] = name
        dl("scanning unmarked object %s | cls %s | dist %s", nameid(name, id), cls)
        local args  = get_args_for_valid_objects(obj)
        if not args then return end

        vl("Trying to add dotmark marker for %s", nameid(obj, id))
        args            = args or {}
        args.id         = id
        args.mark_id    = m_id
        args.kind       = kind
        args.name       = get_localization(obj, nil, sec) or nil
        args.preset     = "dotmark"

        if debug_dump then
            vl("Passing the following args to utils_catspaw_hudmarks:")
            for k,v in pairs(args) do
                vl("%s = %s", k, v)
            end
        end

        if not cfg.markers then cfg.markers = {} end
        cfg.markers[id] = hmm:AddMarker(args)
        local mark = cfg.markers[id]

        if (not cfg.hide_pri_interact_ui) and not (args.no_pri) then
            setup_pri_interact_prompt(mark, args)
        end
        if obj_has_available_sec_interact(obj, id, mark) and not (args.no_sec) then
            setup_sec_interact_prompt(mark)
        end
        if not mark.active_swap then
            mark.active_swap = {
                texture     = cfg.marker_dotactive or cfg.marker_dotmark or "",
                width       = 12,
                height      = 12,
                line_adj_x  = 2,
                line_adj_h  = -6,
                line_adj_y  = 6,
            }
        end
        
        has_cond = (sec and cls) and (utils_item.is_degradable(nil, sec) or IsWeapon(nil, cls) or IsOutfit(nil, cls) or IsHeadgear(nil, cls))
        local is_mag = magazine_binder and sec and magazine_binder.is_magazine(sec)
        if has_cond and not is_mag then
            mark.condition = obj and obj:condition()
        end
    end
end


function scan_nearby_entities(scan_radius)
    local pos = db.actor and db.actor:center()
    if not pos then return end
    level.iterate_nearest(pos, scan_radius, scan_nearby_object)
end


function dot_eye(position)
    -- Taken from Crofok's Faction ID
    local toPoint = vector():set(position):sub(device().cam_pos):normalize()
    local toEye = device().cam_dir
    local dot = toPoint:dotproduct(toEye)
    
    return dot
end


function play_sfx(snd)
    -- Play sound effect unless disable_all_sounds is true
    if cfg.disable_all_sounds or not snd then return end
    snd:play(db.actor, 0, sound_object.s2d)
end

function play_snd_path(snd_path)
    play_sfx(snd_path and xr_sound.get_safe_sound_object(snd_path))
end

function update_targeted_object()
    --vl("update_targeted_object: %s", time_global())
    local target
    if cfg.available_pickup then
        target = get_object_by_id(cfg.available_pickup)
        -- 20250306 modded exes required for pickup callback
    elseif db.actor.get_actor_object_looking_at then
        -- 20250225 modded exes required for this method
        target = db.actor:get_actor_object_looking_at()
    else
        -- Vanilla but very finicky, requires the object to be precisely under the crosshair
        target = level.get_target_obj()
    end
    local id = target and target:id()
    if cfg.racked_items[id] then
        targeted_id = cfg.racked_items[id]
    else
        targeted_id = id
    end

    if debug_dump and targeted_id then
        target = get_object_by_id(targeted_id)
        vl("update_targeted_object: targeted_id is now %s (%s)", targeted_id, target and target:name())
    end
end


function actor_on_net_destroy()
    stop_scanning()
end


function update_actor_extra_weight()
    local w = 0
    local function itr(npc,itm)
        if (npc:is_on_belt(itm)) then
            w = w + (itm and ((ini_sys:r_float_ex(itm:section(),"additional_inventory_weight") or 0) * itm:condition()) or 0)
        end
    end

    db.actor:iterate_inventory(itr,db.actor)
    local bkpk = db.actor:item_in_slot(13)
    w = w + (bkpk and ini_sys:r_float_ex(bkpk:section(),"additional_inventory_weight") or 0)
    extra_carry = w

    return extra_carry
end

function get_actor_max_weight()
    if not db.actor then return end
    local outfit = db.actor:item_in_slot(7)
    local backpack = db.actor:item_in_slot(13)
    
    local max_weight = db.actor:get_actor_max_weight()

    -- Additional weight - Outfit
    max_weight = max_weight + (outfit and outfit:get_additional_max_weight() or 0)
    
    -- Additional weight - Backpack
    max_weight = max_weight + (backpack and backpack:get_additional_max_weight() or 0)
    
    -- Additional weight - Artefacts
    db.actor:iterate_belt( function(owner, obj)
        local c_arty = obj:cast_Artefact()
        max_weight = max_weight + (c_arty and c_arty:AdditionalInventoryWeight() or 0)
    end)
    
    -- Additional weight - Booster
    db.actor:cast_Actor():conditions():BoosterForEach( 
        function(booster_type, booster_time, booster_value)
            if (booster_type == 4) then --eBoostMaxWeight
                max_weight = max_weight + booster_value
            end
        end
    )
    return max_weight
end

function actor_weight_class(comp_weight)
    if not db.actor then return end

    local max_weight = get_actor_max_weight()
    local curr_weight = db.actor:get_total_weight()
    local current = (comp_weight or curr_weight)
    local threshold = comp_weight and (max_weight - curr_weight) or max_weight
    local wclass = ((current > threshold) and 2)  or ((current + 10 > threshold) and 1) or 0
    --printf("actor_weight_class: %s | max %s | curr %s | comp %s | threshold %s", wclass, max_weight, curr_weight, comp_weight, threshold)

    return wclass, curr_weight, max_weight
end

function get_color_for_weight(weight)
    local wc, wa, wm= (weight and actor_weight_class(weight))
    local clr_key   = wc and cfg.weight_colors[wc] or ""
    local color_wgt = cfg.colors[clr_key] or cfg.colors.clr_weight_ok
    return color_wgt, wa, wm
end

function get_inventory_table(box, id)
    -- Streamlined version of the one in axr_companions
    box = box or (id and get_object_by_id(id))
    local t = {}
    if box then
        --printf("Trying to iterate inventory for %s", box:name())
        id = id or box:id()
        local function iterate(owner, item)
            local item_id = item:id()
            local item_sec = item:section()
            t[item_id] = item_sec
        end
        iterate_any_inventory(box, iterate)
    end
    return t
end

function deploy_backpack(backpack)
    --printf("Trying to deploy stash with %s", backpack and backpack:name())
    local pos = backpack and backpack:position()
    if not pos then return end
    local actor = db.actor
    local se_obj = actor and alife_create("inv_backpack", pos, actor:level_vertex_id(), actor:game_vertex_id())
    local section = backpack:section()
    if (se_obj and section) then
        local txt = string.format(gts("st_itm_stash_of_character"), db.actor:character_name())
        level.map_add_object_spot_ser(se_obj.id, "treasure", txt)
        actor_menu.set_msg(1, gts("st_stash_created"),4)
        
        local m_data = alife_storage_manager.get_state()
        if not (m_data.player_created_stashes) then 
            m_data.player_created_stashes = {}
        end
        
        m_data.player_created_stashes[se_obj.id] = section
        
        alife_release(backpack)
    end
end


function remove_placed_backpack(id)
    if not id then return end
    level.map_remove_object_spot(id, "treasure")
    local se_obj = alife_object(id)

    if se_obj then
        alife_release(se_obj)
    end
    
    local m_data = alife_storage_manager.get_state()
    if (m_data.player_created_stashes and m_data.player_created_stashes[id]) then 
        local section = m_data.player_created_stashes[id]
        alife_create_item(section, db.actor)
        m_data.player_created_stashes[id] = nil
    end
    return true
end

function iterate_any_inventory(box, func)
    if not (box and func) then return end
    if IsInvbox(nil, box:clsid()) then
        box:iterate_inventory_box(func)
    else
        box:iterate_inventory(func)
    end
end

function take_all_from_box(box)
    if not box then return end
    local function itr_inv(temp, item)
        box:transfer_item(item, db.actor)
    end
    iterate_any_inventory(box, itr_inv)
    utils_obj.play_sound("interface\\items\\inv_items_take_all")
    return true
end


function pick_up_backpack(obj)
    local id = obj and obj:id()
    if not id then return end

    local data = {
        stash_id = id,
        cancel = false,
    }
    SendScriptCallback("actor_on_stash_remove",data)
    if data.cancel then
        return
    end

    if not obj:is_inv_box_empty() then
        take_all_from_box(obj)
    end
    
    CreateTimeEvent("bp_take_all", 0, 0.05, remove_placed_backpack, id)
end


function eject_mag_from_ground(wpn)
    -- Largely adapted from the similar eject function in Mags Redux
    if not mags_installed then return end
    if wpn:weapon_in_grenade_mode() or not magazine_binder.is_supported_weapon(wpn) then return end
    local id = wpn:id()

    magazine_binder.validate_wep(id)
    
    local mag_data = magazine_binder.get_mag_loaded(id)
    
    if mag_data then
        wpn:force_unload_magazine(false)
        wpn:unload_magazine()
        if magazines.retain_round(wpn) and #mag_data.loaded > 0 then
            vl("retaining round of type %s in chamber", stack.peek(mag_data.loaded))
            stack.pop(mag_data.loaded)
            wpn:set_ammo_elapsed(1)
        else
            wpn:set_ammo_elapsed(0)
        end
        
        se_mag = alife_create_item(mag_data.section, db.actor)
        if se_mag then
            magazines.create_time_event("mag_redux", "timer_eject_"..id, 0, magazines.timer_eject_magazine, id, se_mag.id, mag_data)
        else
            dl("Could not create magazine %s", mag_data.section)
        end
        magazine_binder.set_data(id, {
            section     = "no_mag",
            loaded      = {},
            is_weapon   = true,
        })
        magazine_binder.dump_data(mag_data)
        return se_mag.id
    end
end

function unload_and_take_ammo(wpn)
    --wpn = wpn or level.get_target_obj()
    if not (wpn and IsWeapon(wpn)) then return end
    local count = wpn:get_ammo_in_magazine()
    if count < 1 then return end
    local atype = wpn:get_ammo_type() + 1
    local ammos = parse_list(ini_sys, wpn:section(), "ammo_class")
    local sec   = ammos and atype and ammos[atype]
    
    if mags_installed then
        vl("Ejecting magazine with %s rounds of %s from %s and giving the mag to actor", count, sec, wpn:name())
        eject_mag_from_ground(wpn)
    else
        vl("Unloading %s rounds of %s from %s and giving the ammo to actor", count, sec, wpn:name())
        alife_create_item(sec, db.actor, {ammo = count})
        wpn:unload_magazine()
    end

    local id = wpn:id()
    cfg.markers[id].ammo_count = 0
    --cfg.markers[id].alt_interact:Destroy()
    --cfg.markers[id].alt_interact = nil
end

function unpack_batteries(obj)
    -- like in item_device.func_battery, except without the parent check
    local sec   = obj:section()
    local con   = obj:condition()
    local batt  = item_device.device_battery
    local id    = obj:id()
    local dead  = 0.0001
    --printf("unpacking battery %s from %s with %s%% charge", batt, sec, con * 100)
    if ini_sys:section_exist(batt) then
        --printf("Creating new battery for actor and processing old one")
        alife_create_item(batt, db.actor, {cond = con})
        alife_process_item(sec, id, {cond = dead})
        actor_effects.play_item_fx(batt)
        utils_obj.play_sound("interface\\inv_batt")
    end
    local mark = id and cfg.markers[id]
    if not (mark and mark.use_pri) then return end
    --printf("Updating charge display")
    mark.condition = dead
    mark.use_pri:SetConditionText(sec, dead)
    mark.use_pri:SetPrompt()
end

function is_obj_interact_dist(obj)
    if not (obj and db.actor) then return end
    local pos = obj:center()
    return pos and (pos:distance_to(db.actor:center()) <= (cfg.sec_interact_dist or 2.5))
end


function is_busy_with_anim()
    if (not anim_playing) or (not ea_enabled) then
        return false
    end
    return not cfg.alti_busy_during_anim
end

function delay_consume_action(id, manual_use)
    if fdda_callback and anim_playing then return true end
    local obj = id and get_object_by_id(id)
    if not obj then return true end
    if (enhanced_animations and ea_enabled and not manual_use) then
        vl("[%s][delay_consume_action] passing %s to FDDA", time_global(), nameid(obj, id))
        SendScriptCallback("actor_on_item_before_use", obj, {ret_value = true})
    else
        vl("[%s][delay_consume_action] causing actor to consume/use %s", time_global(), nameid(obj, id))
        db.actor:eat(obj)
    end
    return true
end

function force_actor_to_take(obj)
    vl("Forcing actor to take %s via active pickup callback", obj and obj:name())
    local send_pickup_callback = fdda_callback or item_pickup_intercept
    send_pickup_callback(obj, {force = true, ret_value = true})
end

function take_and_use(obj)
    if not (obj and db.actor) then return end
    force_actor_to_take(obj)
    local id = obj:id()
    if id then
        local manual_use = is_item_manual_use(obj)
        CreateTimeEvent("delayed_actor_use", time_global(), cfg.item_use_delay, delay_consume_action, id, manual_use)
    end
end

function is_item_manual_use(obj, mark)
    local id    = obj and obj:id()
    local mark  = mark or (id and cfg.markers[id]) or {}
    local sec   = mark.section or (obj and obj:section())
    vl("[%s][is_item_manual_use] %s: manual_use from mark %s | from cfg %s", time_global(), mark.name or (obj and obj:name()), mark.manual_use, cfg.manual_use[sec])
    return mark.manual_use or cfg.manual_use[sec]
end

function delay_read_action(id)
    if fdda_callback and anim_playing then return end
    local obj = id and get_object_by_id(id)
    vl("delay_read_action: %s", nameid(obj, id))
    item_recipe.func_recipe(obj)
    return true
end

function take_and_read(obj)
    if not (obj and db.actor) then return end
    force_actor_to_take(obj)
    local id = obj and obj:id()
    if id then
        CreateTimeEvent("delayed_actor_use", time_global(), cfg.item_use_delay, delay_read_action, id)
    end
end

function handle_secondary_interact(obj)
    if is_busy_with_anim() then
        vl("Actor tried to interact but is busy with another item animation")
    return end

    -- Get target object and do validation checks
    local tid = get_current_target()
    local obj = obj or (tid and get_object_by_id(tid))
    if not is_obj_interact_dist(obj) then return end
    vl("handle_secondary_interact: %s is within alti distance", obj and obj:name())
    -- Passed validation - identify handler, if any
    if IsWeapon(obj) then
        unload_and_take_ammo(obj)
    elseif (IsItem("eatable", obj:section())) then
        --vl("forcing actor to eat target food")
        take_and_use(obj)    
    else
        --vl("forcing actor to use booster item")
        take_and_use(obj)    
    end
end

function ea_on_item_use()
    anim_playing = true
end

function ea_on_item_anim_stop()
    anim_playing = false
end

function cycle_targeted_pickup(dir)
    vl("cycle_targeted_pickup: %s | locked %s | target %s", dir and (dir > 0) and "next" or "previous", locked_id, targeted_id)
    if not (dir and get_current_target()) then return end
    local max       = size_table(nearby_pickups)
    vl("max %s | in_pickup_range %s", max, size_table(cfg.in_pickup_range))
    if (max < 2) or is_empty(cfg.in_pickup_range) then return end
    local id_curr   = get_current_target()
    local ind_curr  = pickup_index[id_curr] or 1
    local ind_new
    if (dir > 0) then
        ind_new     = (ind_curr < max) and (ind_curr + 1) or 1
    else
        ind_new     = (ind_curr > 1) and (ind_curr - 1) or max
    end
    locked_id       = nearby_pickups[ind_new]
    local _         = ind_new and (ind_new ~= ind_curr) and play_snd_path(cfg.snd_path_blip)
    vl("Pickup cycled | prev ind %s id %s | new ind %s id %s", ind_curr, nearby_pickups[ind_curr], ind_new, locked_id)
end

function reset_nearby_item_tables()
    --printf("reset_nearby_item_tables")
    locked_id       = nil
    actor_moved     = true
    cfg.last_pickup = nil
    nearby_pickups  = {}
    pickup_index    = {}
end

function update_nearby_pickups()
    if is_empty(cfg.in_pickup_range) then return end
    local actor_moving = (level.actor_moving_state() > 0)
    if actor_moving then
        -- actor is moving
        reset_nearby_item_tables()
        return true
    end
    cfg.last_pickup = cfg.available_pickup
    -- actor isn't moving
    if not is_empty(nearby_pickups) then return end
    -- pickup tables haven't been updated since actor stopped moving

    local i = 1
    --printf("Updating %s nearby pickups", size_table(cfg.in_pickup_range))
    for k,v in spairs(cfg.in_pickup_range) do
        nearby_pickups[i] = k
        pickup_index[k] = i
        --printf("pickup: ID %s ind %s | nearby_pickups[%s]: %s | pickup_index[%s]: %s", k, i, i, nearby_pickups[i], k, pickup_index[k])
        i = i + 1
    end
    actor_moved = false
end

function setup_tutorial_prompt(tutorial)
    vl("Need to set up a new interact UI for tutorial %s", tutorial)
    local args = get_cfg_for_type("args", "Tutorials") or {}
    --args.preset             = "dotmark"
    args.tutorial           = tutorial
    args.fixed              = true
    args.anchor             = maingameui
    args.active_prompt      = trimmed_prompt(gts(cfg.tutorial_hints[tutorial]))
    args.logged_type        = "tutorial prompt"
    cfg.markers[tutorial]   = setup_pri_interact_prompt(maingameui, args)
end

function check_tutorial_states()
    --printf("game.has_active_tutorial(): %s", game.has_active_tutorial())
    if cfg.tutorial_hints and is_not_empty(cfg.tutorial_hints) then
        if game.has_active_tutorial() then
            cfg.tutorials_cleared = false
            if not cfg.monitors then cfg.monitors = {} end
            for k,v in pairs(cfg.tutorial_hints) do
                local last_state = cfg.monitors[k]
                cfg.monitors[k] = state_monitor(k)
                --printf("checking state for tutorial %s: %s", k, cfg.monitors[k])
                if cfg.monitors[k] then
                    if cfg.markers[k] then
                        --printf("Tutorial %s is active, showing its prompt", k)
                        cfg.markers[k]:ShowPrompt(true)
                    else
                        setup_tutorial_prompt(k)
                    end
                elseif cfg.markers[k] then
                    --printf("Tutorial %s is not active, hiding its prompt", k)
                    cfg.markers[k]:ShowPrompt(false)
                end
            end
        elseif (not cfg.tutorials_cleared) then
            --printf("No active tutorial, hiding all tutorial prompts")
            for k,v in pairs(cfg.tutorial_hints) do
                if cfg.markers[k] then
                    cfg.markers[k]:Destroy()
                    cfg.markers[k] = nil
                end
            end
            cfg.tutorials_cleared = true
        end
    end
end

function dump_monitor_states()
    for k,v in pairs(cfg.monitors) do
        printf("State monitor for %s: %s", k, state_monitor(k))
    end
end

function update_skill_bonus_range()
    local skill = haru_skills and cfg.haru_skill_name and haru_skills.skills_levels[cfg.haru_skill_name]
    local sklev = skill and skill.current_level or 0
    cfg.skill_bonus_range = sklev * (cfg.haru_skill_coef or 0)
    return cfg.skill_bonus_range
end

-- =======================================================================
--      MAIN SCAN LOOP
-- =======================================================================
function actor_on_update()
    if not scanning then return end
    -- ===================================================================
    --  Tutorial monitors
    --  Watches for state flags set by modxml_tutorial_hooks.script
    -- ===================================================================
    if cfg.tut_check_interval then
        --if debug_dump then dump_monitor_states() end
        if (next_tut_check <= time_global()) then
            next_tut_check = get_next_check(cfg.tut_check_interval)
            dotmarks_main.in_sleep_zone = is_actor_in_sleep_zone()
            check_tutorial_states()
        end
    end
    -- ===================================================================
    --  Update pickups and current target
    --  Critical, should never be throttled at all
    -- ===================================================================    
    update_nearby_pickups()
    if locked_id then
        local _ = debug_dump and vl("locked_id is %s, skipping target updates and scans", locked_id)
        return
    end
    update_targeted_object()
    -- ===================================================================
    --  Skill system updates
    --  Rare, skillups don't occur often
    --  Needs to run before near_scan so that it applies radius changes
    -- ===================================================================
    if cfg.skill_upd_interval then
        if (next_skill_upd <= time_global()) then
            next_skill_upd  = get_next_check(cfg.skill_upd_interval)
            update_skill_bonus_range()
        end
    end
    -- ===================================================================
    --  Near scan - iterate objects within near_scan_radius
    --  Frequent
    -- ===================================================================
    if cfg.near_scan_interval then
        if (next_near_scan <= time_global()) then
            next_near_scan   = get_next_check(cfg.near_scan_interval)
            scan_nearby_entities(near_scan_radius())
        end
    end
    -- ===================================================================
    --  Early scan - iterate within near_scan_radius + early_scan_radius
    --  Instantiates markers for objects before they would become visible
    --  Less frequent
    -- ===================================================================
    if cfg.early_scan_interval then
        if (next_early_scan <= time_global()) then
            next_early_scan   = get_next_check(cfg.early_scan_interval)
            scan_nearby_entities(early_scan_radius())
        end
    end
end
-- =======================================================================

function on_before_key_press(key, bind, dis, flags)
    if cfg.watch_use and (key == use_dik) then
        cfg.use_released = nil
        cfg.block_loot_window = true
        --printf("[%s][on_before_key_press] Beginning hold of key %s", time_global(), key)
        cfg.held_key = key
    end
end

function on_key_release(key)
    if key == cfg.held_mod then cfg.held_mod = nil end
    if (key == cfg.held_key) then
        if (key == use_dik) then
            local pickup, container
            pickup = get_target_pickup()
            if not pickup then
                container = get_target_container()
            end
            cfg.use_released = cfg.use_released or time_global()
            local dur = cfg.holding and cfg.holding.peak_hold
            local time = cfg.holding and cfg.holding.hold_time
            --printf("[%s] on_key_release: use key was just released | dur held %s | hold time %s", cfg.use_released, dur, time)
            cfg.held_key = nil

            if not (dur and time and (dur >= time)) then
                if pickup then
                    cfg.use_released = nil
                    --printf("No completed hold action, item pickup should occur", time)
                    force_actor_to_take(pickup)
                elseif container then
                    cfg.use_released = nil
                    cfg.block_loot_window = nil
                end
            end
        end
    end
end

function actor_on_update_pickup(obj)
    cfg.last_pickup = cfg.available_pickup
    cfg.available_pickup = obj and obj:id() or nil
    if cfg.last_pickup and cfg.available_pickup and (cfg.last_pickup ~= cfg.available_pickup) then
        reset_nearby_item_tables()
    end
end

function actor_on_item_take(obj)
    local id = obj and obj:id()
    if id and cfg.markers[id] then
        unregister_scanned_entity(id)
    end
end

function handle_npc_death(npc)
    local id = npc and npc:id()
    if id and cfg.markers[id] then
        unregister_scanned_entity(id)
        scan_nearby_object(npc)
    end
end

function on_mouse_wheel(scroll_dir, flags)
    if  (not cfg.wheel_cycles_pickups) or
        (not get_current_target()) or
        actor_menu.inventory_opened() or
        (item_device and item_device.is_pda_active()) or
        (ui_workshop.GUI and ui_workshop.GUI:IsShown()) or
        axr_main.binoc_is_zoomed or axr_main.scoped_weapon_is_zoomed then
    return end

    local direction         = (scroll_dir > 0) and 1 or -1
    vl("on_mouse_wheel: %s | direction: %s", scroll_dir, direction)
    cycle_targeted_pickup(direction)
    flags.ret_value         = false
end

function parse_file_data()
    if cfg.prompts then
        for k,v in pairs(cfg.prompts) do
            cfg.prompts[k] = gts(v)
        end
    end
    if cfg.colors then
        for k,v in pairs(cfg.colors) do
            if k:find("clr_") then
                local c         = csv_argb_to_tbl(v)
                --printf("parsing color %s: %s | %s,%s,%s,%s", k,v, c.a, c.r, c.g, c.b)
                cfg.colors[k]   = c
                local str       = string.format("%" .. "%c[%s,%s,%s,%s]", c.a, c.r, c.g, c.b)
                set_color_token(k, str)
            else
                cfg.colors[k]   = nil
            end
        end
    end
    cfg.weight_colors = {
        [0] = "clr_weight_ok",
        [1] = "clr_weight_high",
        [2] = "clr_weight_over"
    }

    cfg.show_part_condition     = (cfg.show_parts_weapons or cfg.show_parts_armor)
    cfg.color_icon_itemcard     = clr_tbl(cfg.color_icon_itemcard)
    cfg.unsquish_ratio          = utils_catspaw_hudmarks.update_unsquish_ratio() or 1
    local ini_mutant            = ini_file("items\\settings\\mutant_loot.ltx")
    cfg.mutant_decay_time       = ini_mutant:r_float_ex("mutant_loot_mod","decay_time") or 7200
    local factions      = game_relations.factions_table
    local ini_fac       = ini_file_ex("plugins\\faction_profile.ltx")
    cfg.notable_npcs    = {}
    cfg.vendors         = {}
    for _,fac in pairs(factions) do
        local fd = ini_fac:collect_section(fac)
        cfg.notable_npcs[fac] = {
            leader      = fd.leader,
            trader      = fd.trader,
            mechanic    = fd.mechanic,
            medic       = fd.medic,
            barman      = fd.barman,
            guide       = fd.guide
        }
        if fd.leader then   cfg.vendors[fd.leader]    = "leader" end
        if fd.trader then   cfg.vendors[fd.trader]    = "trader" end
        if fd.mechanic then cfg.vendors[fd.mechanic]  = "mechanic" end
        if fd.medic then    cfg.vendors[fd.medic]     = "medic" end
        if fd.barman then   cfg.vendors[fd.barman]    = "barman" end
        if fd.guide then    cfg.vendors[fd.guide]     = "guide" end
    end
    if debug_dump then
        vl("Loaded NPC vendors:")
        for k,v in pairs(cfg.vendors) do
            vl("|| %s = %s", k,v)
        end
    end 
end

function set_item_pickup_callbacks()
    if not get_fdda_callback() then
        RegisterScriptCallback("actor_on_item_before_pickup", item_pickup_intercept)
        vl("No form of FDDA installed, registering internal pickup callback")
        cfg.pickup_callback_set = true
    end
end

function on_option_change()
    local _ = debug_dump and vl("on_option_change() triggered at %s", time_global())
    dl("Iterating through settings and looking for MCM overrides\n" ..
        "+ You may see a burst of MCM warnings about bad paths during this process. These are completely harmless and should be ignored."
    )
    vl("Loading config tables")

    for k,v in pairs(cfg) do
        if type(v) ~= "table" then
            local mcm_path = cfg.mcm_paths[k]
            --if mcm_path and (#mcm_path < 20) then
            if mcm_path and mcm_path:find("/$") then
                mcm_path = mcm_path .. k
            end
            if mcm_path then
                if reset then
                    _ = debug_dump and vl("Defaulting %s = %s (was %s)", k, v, get_mcm(mcm_path, cfg[k]))
                    ui_mcm.set(mcm_path, v)
                else
                    cfg[k] = get_mcm(mcm_path, cfg[k])
                    _ = debug_dump and vl("Loading %s = %s", k, v)
                end
            else
                _ = debug_dump and vl("No MCM path found for %s, skipping", k)
            end
        end
    end
    for k,v in pairs(cfg.scan) do
        cfg.scan[k] = get_mcm("dotmarks/dmarkobjs/scan_" .. string.lower(k), cfg.scan[k])
        _ = debug_dump and vl("Scanning %s = %s", k, v)
    end

    debuglogs       = get_mcm("dotmarks/dmarkadv/debuglogs", debuglogs)
    verbose         = get_mcm("dotmarks/dmarkadv/verbose", verbose)
    _uiscale        = get_mcm("dotmarks/dmarkadv/ui_scale", _uiscale)
    dl("Debug logging enabled | verbose %s | debug_dump %s", debuglogs, verbose, debug_dump)
    ea_enabled      = ea_callbacks and get_mcm("EA_settings/enable_animations", ea_enabled)
    scanned         = {}
    use_dik         = bind_to_dik(key_bindings.kUSE)
    if cfg.bind_sec_interact == nil then
        cfg.bind_sec_interact = use_dik
    end
    cfg.watch_use   = (use_dik == cfg.bind_sec_interact) and not cfg.hide_sec_interact_ui
    if cfg.markers and not is_empty(cfg.markers) then
        for k,v in pairs(cfg.markers) do
            cfg.markers[k]:Destroy()
        end
    end
    --set_item_pickup_callbacks()
end

function on_game_start()
    cfg = dotmarks_main.get_base_config_table()
    mags_installed = (magazines and magazine_binder)
    if dotmarks_main.load_file_data(config_file, this.cfg) then
        parse_file_data()
        dotmarks_main.refresh_main_config()
        set_item_pickup_callbacks()
        RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
        RegisterScriptCallback("actor_on_update_pickup", actor_on_update_pickup)
        RegisterScriptCallback("actor_on_update", actor_on_update)
        RegisterScriptCallback("actor_on_item_take", actor_on_item_take)
        RegisterScriptCallback("actor_on_net_destroy", actor_on_net_destroy)
        RegisterScriptCallback("on_key_release", on_key_release)
        RegisterScriptCallback("on_before_key_press", on_before_key_press)
        RegisterScriptCallback("on_option_change", on_option_change)
        RegisterScriptCallback("on_mouse_wheel", on_mouse_wheel)
        RegisterScriptCallback("npc_on_death_callback", handle_npc_death)
        RegisterScriptCallback("monster_on_death_callback", handle_npc_death)
        if stealth_kill_detection then
            RegisterScriptCallback("npc_on_silent_kill_callback", handle_npc_death)
        end

        local last_en = ea_enabled
        on_option_change()
        if ea_callbacks and (ea_enabled ~= last_en) then
            if ea_enabled then
                vl("Registering item animation callbacks")
                ea_callbacks.EA_RegisterScriptCallback("ea_on_item_use", ea_on_item_use)
                ea_callbacks.EA_RegisterScriptCallback("ea_on_item_anim_stop", ea_on_item_anim_stop)
            else
                vl("Unregistering item animation callbacks")
                ea_callbacks.EA_UnregisterScriptCallback("ea_on_item_use", ea_on_item_use)
                ea_callbacks.EA_UnregisterScriptCallback("ea_on_item_anim_stop", ea_on_item_anim_stop)
            end
        end
    else
        printf("%s could not find config file %s\n" ..
                "! ERROR: %sstartup aborted, no callbacks will be registered", script_name, logprefix, config_file)
    end
end
