-- =======================================================================
--[[    Interaction Dot Marks ("DotMarks")

    PRE-RELEASE TEST BUILD - THIS IS A WORK IN PROGRESS

-- ===================================================================--]]
script_name     = "dotmarks_cfg"
script_version  = "0.8-b2"
release_date    = 20250316
--[[======================================================================
    Author: Catspaw (CatspawMods @ ModDB)
    Source: https://github.com/CatspawMods/Anomaly-Addon-Archive

    I post gameplay video on my Youtube channel, Catspaw Adventures: 
    https://www.youtube.com/@CatspawAdventures
-- =======================================================================
    A blatant imitation of the "interaction dot" HUD markers in Stalker 2,
    and some of its other UI niceties such as floating prompts and 
    secondary interactions.

    Except not quite as cool, because Anomaly is jank. Hopefully this 
    makes it a little less jank.

    Also implements an "Alternate Interact" keybind with contextual 
    actions such as unloading a weapon without having to pick it up.
-- =======================================================================
    Requires modded exes by demonized:
    https://github.com/themrdemonized/xray-monolith

    If your version of the modded exes is earlier than 20250306, you will
    see this error in your log:

    ![axr_main callback_set] callback actor_on_update_pickup doesn't exist!

    If you are seeing that, you MUST update your version of the modded 
    exes in order for object targeting to work properly. If you think you
    have updated and are still seeing that error, you need to do a clean
    reinstall of the modded exes from scratch.

    If it's even older than that, some stuff may not work at all. You
    should update your modded exes ASAP.    
-- =====================================================================]]

assert(utils_catspaw_common, "\n\n"..
    "! ui_hud_dotmarks requires script utils_catspaw_common, which does not exist!\n\n"
)
assert(utils_catspaw_text and utils_catspaw_text.bindtext, "\n\n"..
    "! ui_hud_dotmarks requires script utils_catspaw_text, which does not exist or is an older version!\n" ..
    "Version found: " .. (utils_catspaw_text and utils_catspaw_text.script_version or "missing!") .. " | Required: 1.4+\n" ..
    "If the version is outdated, try moving this addon to the bottom of your load order."
)
local dl = function(logtext, ...) utils_catspaw_common.dlog(nil, logtext, ...) end
local vl = function(logtext, ...) utils_catspaw_common.vlog(nil, logtext, ...) end

function allow_local_logging(onoff)
    -- By default, logging in this script inherits its debuglogs/verbose settings from utils_catspaw_common
    if onoff then
        dl = function(logtext, ...) utils_catspaw_common.dlog(ui_hud_dotmarks, logtext, ...) end
        vl = function(logtext, ...) utils_catspaw_common.vlog(ui_hud_dotmarks, logtext, ...) end
    else
        dl = function(logtext, ...) utils_catspaw_common.dlog(nil, logtext, ...) end
        vl = function(logtext, ...) utils_catspaw_common.vlog(nil, logtext, ...) end
    end
end

dotmarks_config_file    = "scripts\\dotmarks_defaults.ltx"
local strbool           = utils_catspaw_common.strbool
local is_living_thing   = utils_catspaw_common.is_living_thing
local safeid            = utils_catspaw_common.safeid
local safename          = utils_catspaw_text.safename
local paw               = tasks_placeable_waypoints
local gts               = game.translate_string
local cfg               = {}
-- =======================================================================
--      MAIN CONFIG TABLE
--  Most values are loaded from configs\scripts\dotmarks_defaults.ltx
-- =======================================================================
local base_config = {
-- =======================================================================
--  [cfg.is_item]: table of functors to test if an object matches a type
-- =======================================================================
    is_item = {
        Stalkers = (
            function(obj) 
                local comm = obj and get_object_community(obj)
                local is_enemy = comm and game_relations.is_factions_enemies(get_actor_true_community(), comm)
                return obj and (
                    (IsStalker(nil, obj:clsid()) and obj:alive() and not is_enemy) or
                    (obj:clsid() == clsid.script_trader)
                )
            end
        ),
        Bodies = (
            function(obj) return obj and (is_living_thing(obj) and not obj:alive()) end
        ),
        Stashes = (
            function(obj) return obj and IsInvbox(nil, obj:clsid()) end
        ),
        Ammo = (
            function(obj) 
                local cls = obj and obj:clsid()
                if not cls then return end
                return IsAmmo(nil, cls) or (cfg.grenade_ammo_clsids and cfg.grenade_ammo_clsids[cls])
            end
        ),
        Weapons = (
            function(obj) return obj and (IsWeapon(nil, obj:clsid()) or (obj:clsid() == clsid.wpn_binocular_s)) end -- also catches binocs
        ),
        Grenades = (
            function(obj) return obj and IsGrenade(nil, obj:clsid()) end
        ),
        Explosives = (
            function(obj) return obj and IsExplosive(nil, obj:clsid()) end
        ),
        Outfits = (
            function(obj) return obj and IsOutfit(nil, obj:clsid()) end
        ),
        Headgear = (
            function(obj) return obj and IsHeadgear(nil, obj:clsid()) end
        ),
        Artefacts = (
            function(obj) return obj and IsArtefact(nil, obj:clsid()) end
        ),
        Consumables = (
            function(obj) 
                local cls = obj and obj:clsid()
                if (cls and (cls == clsid.obj_food)) then
                    return true
                end
                local section = obj and obj:section()
                return 
                    (section and 
                        (IsItem("eatable", section)) or
                        (ini_sys:r_string_ex(section, "kind") == "i_medical")
                    )
            end
        ),
        Tools = (
            function(obj) return obj and IsItem("tool", obj:section()) end
        ),
        Devices = (
            function(obj) return obj and IsItem("device", obj:section()) end
        ),
        Quest = (
            function(obj) return obj and IsItem("quest", obj:section()) end
        ),
        Campfires = (
            function(obj) return obj and (obj:clsid() == clsid.zone_campfire) end
        ),
        Doors = (
            function(obj) 
                local scheme = obj and obj:id() and db.storage[obj:id()] and db.storage[obj:id()].active_scheme
                return (scheme == "ph_door")
            end
        ),
        Boxes = (
            function(obj)
                local cls = obj and obj:clsid()
                if not (cls and (cls == clsid.obj_phys_destroyable)) then return end
                local visual = obj:get_visual_name()
                return visual and cfg.breakable_box_visuals[visual]
            end
        ),
        Misc = (
            function(obj) 
                return obj and (
                    (obj:clsid() == clsid.obj_attachable) or
                    (obj:clsid() == clsid.equ_backpack)
                )
            end
        ),
        Workshops = (
            function(obj)
                return obj and (obj:clsid() == clsid.obj_physic) and string.match(obj:name(), "awr_tiski") end
        ),


    },
-- =======================================================================
--  [cfg.args]: required, returns a table of parameters for a mark type
--  At a minimum, this must include args.texture, which must be the name 
--  of a valid texture (even a blank one)
-- =======================================================================    
    args = {
    -- Whenever an object matches one of the is_item functions above, the next
    -- step is to get its base args (flags and metadata) for passing along to
    -- the HUD Marker Manager in utils_catspaw_hudmarks
    -- =======================================================================    
        Stalkers = (
            function(obj)
                if not obj then return end
                local id            = obj:id()
                local cls           = obj:clsid()
                if not cls then return end
                local sec           = obj:section()
                local args          = {
                    logged_type    = "stalker (alive)",
                    -- logged_type is purely informational for logging
                    is_npc         = true, -- these three flags should be obvious
                    is_alive       = true, -- utilized during main loop to speed up checks
                    is_stalker     = true, -- passed through via args to the interaction prompts
                    bone           = "bip01_spine1",
                    -- causes marker position to be based on this bone
                    pos_adjust     = vector():set(0, 0.1, 0),
                    -- adjust final marker world pos additively by this value
                    texture        = cfg.marker_dotmark,
                    -- The get_cfg_for_type call for the "tex" type returns the contents of
                    -- the cfg.tex table for the specified object class.
                    hint_filters = {["character_use"] = "character_use"},
                    -- Hint filters specify strings that this marker's primary interaction prompt
                    -- should watch for and erase from the QuickHelp static, and optionally 
                    -- specify a replacement localization string to use.
                }

                local service_icon
                if cfg.vendors[sec] then
                    --vl("NPC section %s has service type %s", sec, cfg.vendors[sec])
                    args.service_type   = cfg.vendors[sec]
                    local enabled       = not cfg.disable_icon_services
                    service_icon        = enabled and cfg.service_icons[args.service_type] or nil
                    -- Service NPCs (e.g. traders, mechancis) show a special icon instead of
                    -- the dot marker when they are targeted for interaction.
                    -- killswitched by cfg.disable_icon_services
                end
                if service_icon then
                    vl("Found NPC service icon %s, enabling active swap")
                    -- The active_swap arg specifies a list of args that are swapped in
                    -- whenever the marker becomes the current active target.
                    -- The original values are restored when it is no longer targeted.
                    args.active_swap = {
                        texture     = service_icon,
                        width       = 16,   -- marker width
                        height      = 16,   -- marker height
                        line_adj_x  = 4,    -- x position of the white line
                        line_adj_y  = 11,   -- y position of the white line
                        line_adj_h  = -11,  -- height of the white line
                    }
                elseif not cfg.disable_icon_talk then
                    vl("Stalker talk icon %s enabled for active swap")
                    args.active_swap = {
                        texture     = get_cfg_for_type("tex", "Stalkers"),
                        width       = 16,
                        height      = 16,
                        line_adj_x  = 4,
                        line_adj_h  = -11,
                        line_adj_y  = 11,
                    }
                end

                return args
            end
        ),
    -- =======================================================================    
        Bodies = (
            function(obj)
                if not obj then return end
                if is_empty_mutant_corpse(obj) then return end
                local id            = obj:id()
                local cls           = obj:clsid()
                if not (id and cls) then return end
                local args = {
                    is_npc          = true,
                    comm            = get_object_community(obj) or nil,
                    section         = obj:section(),
                    bone            = "bip01_spine1",
                    hint_filters = {
                        ["dead_character_use"]          = "dead_character_use",
                        ["dead_character_use_or_drag"]  = "dead_character_use_or_drag",
                        ["st_body_loot"]                = "st_body_loot",
                        ["st_body_knife_bad"]           = "st_body_knife_bad",
                        ["st_body_knife_needed"]        = "st_body_knife_needed",
                        ["st_body_knife_weak"]          = "st_body_knife_weak",
                    },
                }
                
                if IsStalker(nil, cls) then
                    args.is_stalker = true
                elseif IsMonster(nil, cls) then
                    args.is_mutant = true
                end

                args.logged_type    = "dead " .. (args.is_stalker and "stalker" or "mutant")
                if paw and cfg.bodies_use_paw_patches then
                    args.is_stalker = args.is_stalker and (args.comm ~= "zombied")
                    args.texture    = (args.is_stalker and ("ui_icons_paw_badge_uhr_" .. args.comm)) or cfg.marker_dotmark
                    if args.is_stalker then
                        args.width      = 16
                        args.height     = 16
                        args.line_adj_x = 4
                        args.line_adj_h = -10
                        args.line_adj_y = 10
                    end
                else
                    args.texture    = get_cfg_for_type("tex", "Bodies", obj) or cfg.marker_dotmark
                end
                if is_body_claimed(id) then
                    args.name       = safename(id) .. " (" .. gts("st_body_is_claimed") .. ")"
                end
                if args.is_stalker then
                    args.has_items  = not obj:is_inv_box_empty()
                end

                return args
            end
        ),
    -- =======================================================================    
        Stashes = (
            function(obj)
                --get_bones_for_obj(obj)

                local sec = obj and obj:section()
                return obj and {
                    logged_type     = "a stash",
                    is_stash        = true,
                    is_backpack     = (sec == "inv_backpack"),
                    is_display      = cfg.display_cases[sec] or nil,
                    has_items       = obj and not obj:is_inv_box_empty(),
                    texture         = get_cfg_for_type("tex", "Stashes") or cfg.marker_dotmark,
                    los_pos_adjust  = vector():set(0, 0.5, 0),
                    --pos_adjust      = vector():set(0, 0.4, 0),
                    hint_filters   = {
                        ["inventory_box_use"]       = "inventory_box_use",
                        ["actor_inventory_box_use"] = "actor_inventory_box_use",
                        ["st_search_treasure"]      = "st_search_treasure",
                    },
                }
            end
        ),
    -- =======================================================================    
        Ammo = (
            function(obj)
                --get_bones_for_obj(obj)

                return obj and {
                    logged_type     = "ammo",
                    bone            = "link",
                    pickup          = true,     -- object is a gettable inventory item
                    texture         = get_cfg_for_type("tex", "Ammo") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Weapons = (
            function(obj)
                if weapon_showcase and not is_empty(weapon_showcase.weapon_displays) then
                    local id = obj and obj:id()
                    for case_id, case_guns in pairs(weapon_showcase.weapon_displays) do
                        for item_id, world_id in pairs(case_guns) do
                            if (id == item_id) or (id == world_id) then
                                cfg.racked_items[world_id] = case_id
                                --printf("%s: case %s | item_id %s | world_id %s", obj:name(), case_id, item_id, world_id)
                                -- Ignore weapons in Hideout Furniture display cases
                                return nil
                            end
                        end
                    end
                end

                local count = obj and obj:get_ammo_in_magazine()
                return obj and {
                    logged_type     = "a weapon",
                    has_parts       = true,
                    pickup          = true,
                    texture         = get_cfg_for_type("tex", "Weapons") or cfg.marker_dotmark,
                    --pos_adjust      = vector():set(0, 0.15, 0),
                    -- adjusts world coordinates of the marker itself
                    bone            = "wpn_body",
                    ammo_count      = count,
                    -- if ammo_count and ammo_count > 0, unload-ammo secondary action will be shown
                    clsid           = obj:clsid(),
                    section         = obj:section(),
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Grenades = (
            function(obj)
                get_bones_for_obj(obj)

                return {
                    logged_type     = "a grenade",
                    pickup          = true,
                    texture         = get_cfg_for_type("tex", "Grenades") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Explosives = (
            function()
                return {
                    logged_type     = "an explosive",
                    pickup          = true,
                    texture         = get_cfg_for_type("tex", "Explosives") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Outfits = (
            function(obj)
                --get_bones_for_obj(obj)

                return obj and {
                    logged_type     = "an outfit",
                    pickup          = true,
                    has_parts       = true, -- Item has component parts with condition
                    bone            = "joint1",
                    texture         = get_cfg_for_type("tex", "Outfits") or cfg.marker_dotmark,
                    clsid           = obj:clsid(),
                    section         = obj:section(),
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Headgear = (
            function(obj)
                --get_bones_for_obj(obj)

                return obj and {
                    logged_type     = "headgear",
                    pickup          = true,
                    has_parts       = true,
                    bone            = "joint1",
                    clsid           = obj:clsid(),
                    section         = obj:section(),
                    texture         = get_cfg_for_type("tex", "Headgear") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Artefacts = (
            function(obj)
                --get_bones_for_obj(obj)

                return obj and {
                    logged_type     = "an artefact",
                    pickup          = true,
                    is_arty         = true,
                    texture         = get_cfg_for_type("tex", "Artefacts") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Consumables = (
            function(obj)
                --get_bones_for_obj(obj)

                local section       = obj and obj:section()
                local multi_uses    = nil
                if section and IsItem("multiuse", section, obj) then
                    multi_uses = obj:get_remaining_uses()
                end
                return obj and {
                    logged_type     = "food, drugs, or drink",
                    pickup          = true,
                    --bone            = "bone01",
                    multi_uses      = multi_uses,
                    -- if multi_uses and multi_uses > 1, the number of uses will be suffixed to the prompt
                    section         = section,
                    texture         = get_cfg_for_type("tex", "Consumables") or cfg.marker_dotmark,
                    hint_filters    = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Tools = (
            function(obj)
                --get_bones_for_obj(obj)

                local section       = obj and obj:section()
                local multi_uses    = nil
                if section and IsItem("multiuse", section, obj) then
                    multi_uses = obj:get_remaining_uses()
                end
                return obj and {
                    logged_type     = "a tool",
                    pickup          = true,
                    multi_uses      = multi_uses,
                    section         = section,
                    texture         = get_cfg_for_type("tex", "Tools") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Devices = (
            function(obj)
                --get_bones_for_obj(obj)

                return obj and {
                    logged_type     = "a device",
                    pickup          = true,
                    has_battery     = true,
                    has_power       = true,
                    bone            = "wpn_body",
                    clsid           = obj:clsid(),
                    section         = obj:section(),
                    texture         = get_cfg_for_type("tex", "Devices") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Quest = (
            function(obj)
                return obj and {
                    logged_type     = "a quest item",
                    pickup          = true,
                    section         = obj:section(),
                    texture         = get_cfg_for_type("tex", "Quest") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================
        Campfires = (
            function(obj)
                return obj and {
                    logged_type     = "a campfire",
                    texture         = cfg.marker_dotmark,
                    is_campfire     = true,
                    name            = gts("st_itm_campfire"),
                    --los_pos_adjust  = vector():set(0, 0, 0),
                    -- Changes the world coordinates used for LOS checks
                    pos_adjust      = vector():set(0, 0.25, 0),
                    no_pri          = true, -- Do not display a primary interaction prompt
                    -- This is because campfire interactions are shown via the
                    -- tutorial system, and are handled as a fixed-position
                    -- screen prompt
                }
            end
        ),
    -- =======================================================================    
        Doors = (
            function(obj)
                if not obj then return end
                local visual    = obj:get_visual_name()
                local id        = obj:id()
                local ph_door   = id and db.storage[id]["ph_door"]
                local use_icon  = (not cfg.disable_icon_door)
                local vadjust   = visual and cfg.door_visuals and cfg.door_visuals[visual] or 0.25

                local args = {
                    logged_type         = "a door",
                    texture             = cfg.marker_dotmark,
                    is_door             = true,
                    bone                = "lock",
                    pos_adjust          = vector():set(0, vadjust, 0),
                    scheme              = ph_door,
                    -- The scheme is used for getting direct access to the door handlers and data
                    visual              = visual,
                    -- The name of the 3D model visual used for the object
                    interact_dist       = 4,
                    -- Doors can be interacted with from a greater than normal distance
                }
                if use_icon then
                    args.active_swap = {
                        texture     = get_cfg_for_type("tex", "Doors"),
                        width       = 20,
                        height      = 20,
                        line_adj_x  = 4,
                        line_adj_h  = -12,
                        line_adj_y  = 12,
                    }
                end
                return args
            end
        ),
    -- =======================================================================    
        Boxes = (
            function(obj)
                --get_bones_for_obj(obj)

                if not obj then return end
                local visual = obj:get_visual_name()
                return {
                    logged_type     = "a breakable box",
                    texture         = (not cfg.disable_icon_box) and get_cfg_for_type("tex", "Boxes") or cfg.marker_dotmark,
                    visual          = visual,
                    no_pri          = true,
                    line_adj_x      = 2,
                    line_adj_h      = -8,
                    line_adj_y      = 8,
                    width           = 10,
                    height          = 10,
                }
            end
        ),
    -- =======================================================================    
        Misc = (
            function(obj)
                if not obj then return end
                --get_bones_for_obj(obj)
                local name = obj:name()
                local section = obj:section()
                local kind = SYS_GetParam(0, obj:section(), "kind") or "na"
                printf("Misc loot %s has condition: %s", obj:name(), utils_item.is_degradable(nil, section))
                return {
                    kind            = kind,
                    -- Used for further object type detection
                    pickup          = true,
                    --bone            = name:find("patch" and "joint1" or "link"),
                    section         = section,
                    is_readable     = kind and (kind == "i_letter") or nil,
                    -- Book or letter that can be picked up and read as a secondary action
                    is_backpack     = (obj:clsid() == clsid.equ_backpack),
                    logged_type     = "miscellaneous loot",
                    texture         = get_cfg_for_type("tex", "Misc") or cfg.marker_dotmark,
                    hint_filters   = {["inventory_item_use"] = "inventory_item_use"},
                }
            end
        ),
    -- =======================================================================    
        Tutorials = (
            -- Tutorials are a class of on-screen prompt that is displayed by the game engine
            -- according to some fairly arcane functionality in the game_tutorials.xml file.
            -- Most are not actually "tutorials" as such, but instead use the engine's tutorial
            -- system as a way of displaying custom interaction prompts to the player.
            
            -- These include campfire interactions, sleep zones, and many quest-specific
            -- one-off interaction prompts. All are displayed by DotMarks as fixed-position
            -- screen prompts, as most are not actually attached to any world object.

            -- There was no existing way to capture these tutorial events, so I created the
            -- modxml_tutorial_hooks script to set up on/off flags for the states of all such
            -- tutorial-interactions.
            function()
                local x,y               = get_fixed_screen_pos()
                return {
                    logged_type         = "game_tutorials.xml pop-up",
                    texture             = "",
                    fixed               = true,
                    los_check_int       = -1,
                    locked_screen_pos   = vector2():set(x, y),
                }
            end
        ),
        Workshops = (
            function(obj)
                if not obj then return end
                local visual = obj:get_visual_name()

                return {
                    logged_type         = "a workshop bench",
                    texture             = get_cfg_for_type("tex", "Workshops") or cfg.marker_dotmark,
                    visual              = visual,
                    section             = obj:section(),
                    interact_dist       = 1.5,
                    refresh_text        = true,
                    -- Forces the prompt text to check for changes on every update
                    hint_filters       = {
                        ["st_tiski_no_info"]= "st_tiski_no_info",
                        ["st_tiski"]        = "st_tiski",
                        ["st_awr_tiski"]    = "st_awr_tiski",
                    },
                }
            end
        ),        
    },
-- =======================================================================    
--  [cfg.state_conds]: a set of extra checks for tutorial-based prompts 
--  that must also be true (in addition to the tutorial state) in order 
--  for this script to trigger the tutorial prompt.
-- =======================================================================    
    state_conds = {
        ["sleep_zone_tip"]              = ( function() return in_sleep_zone end ),
        -- Check whether actor is actually in the sleep zone - the tutorial fires sooner
        ["tutorial_campfire_ignite"]    = ( 
            function()
                return not is_nearest_campfire_lit()
                --local fire = bind_campfire.get_nearby_campfire(2.5, true)
                --if type(fire) == "boolean" then return not fire end
                --return fire and not fire:is_on()
            end
        ),
        -- Check whether campfire is authoritatively on or off
        ["tutorial_campfire_extinguish"]= ( 
            function() 
                return is_nearest_campfire_lit()
                --local fire = bind_campfire.get_nearby_campfire(2.5, true)
                --if type(fire) == "boolean" then return fire end
                --return fire and fire:is_on()
            end 
        ),
    },
}
-- =======================================================================    

function get_base_config_table() return base_config end

function refresh_main_config()
    cfg = ui_hud_dotmarks.cfg
end

function near_scan_radius()
    return cfg.near_scan_radius + (cfg.use_skill_system and cfg.skill_bonus_range or 0)
end

function get_nearby_campfire(dist)
    return bind_campfire.get_nearby_campfire(dist or 2.5, true)
end

function is_nearest_campfire_lit()
    local fire = get_nearby_campfire()
    if type(fire) == "boolean" then return fire end
    -- bind_campfire is fucking stupid, and returns different data types
    -- so we have to trap that to avoid a dumb crash
    return fire and fire:is_on()
end

function is_empty_mutant_corpse(obj)
    if not (obj and IsMonster(obj)) then return end
    local id = safeid(obj)
    local looted = se_load_var(id,obj:name(),"looted")
    local st = db.storage[id]
    local decayed = (st and st.death_time and game.get_game_time():diffSec(st.death_time) > cfg.mutant_decay_time)
    return looted or decayed
end

function is_body_claimed(id)
    if grok_loot_claim then
        local claimed   = grok_loot_claim.claimed
        local k_id      = claimed and id and claimed[id]
        local k_obj     = k_id and get_object_by_id(k_id)
        local k_alive   = k_obj and is_living_thing(k_obj) and k_obj:alive()
        return not not (k_alive and (k_id ~= AC_ID))
    end
    return false
end

function is_blacklisted(id, cls, sec)
    return (cls and cfg.blacklisted_clsids and cfg.blacklisted_clsids[cls]) or
            (id and cfg.blacklisted_ids and cfg.blacklisted_ids[id]) or
            (sec and cfg.blacklisted_sections and cfg.blacklisted_sections[sec])
end

function get_val_or_funcval(val_or_func, ...)
    if not val_or_func then return end
    if type(val_or_func) == "function" then
        return val_or_func(...)
    else
        return val_or_func
    end
end

function get_cfg_for_type(cfg_type, obj_type, ...)
    return cfg and cfg_type and obj_type and cfg[cfg_type] and get_val_or_funcval(cfg[cfg_type][obj_type], ...)
end

function get_fixed_screen_pos()
    local x = cfg.tutorial_prompt_x or (cfg.fixed_screen_pos and cfg.pri_use_x_offset) or 512
    local y = cfg.tutorial_prompt_y or (cfg.fixed_screen_pos and cfg.pri_use_y_offset) or 600
    return x,y
end

function remove_obj_from_box_table(box, item)
    if not (box and item) then return end
    local b_id = box:id()
    if not cfg.invboxes[b_id] then return end
    local i_id = item:id()
    --printf("Removing ID %s (%s) from table for invbox %s", i_id, cfg.invboxes[b_id][i_id], b_id)
    cfg.invboxes[b_id][i_id] = nil
end

function add_obj_to_box_table(box, item)
    if not (box and item) then return end
    if not (box and item) then return end
    local b_id = box:id()
    if not cfg.invboxes[b_id] then return end
    local i_id = item:id()
    local sec = item:section()
    cfg.invboxes[b_id][i_id] = sec
    --printf("Adding ID %s (%s) to table for invbox %s", i_id, sec, b_id)
end

function load_file_data(ini_name, cfg_table)
    -- Parameterizing this to turn it into a reusable module
    local def_ini = ini_name and ini_file_ex(ini_name)
    if not def_ini then return false end

    dl("Loading file data and populating tables")
    local function load_table_values(from_tbl, to_tbl)
        if not to_tbl then to_tbl = {} end
        for k,v in pairs(from_tbl) do
            local template = false
            if tonumber(v) then
                to_tbl[k] = tonumber(v)
            elseif (v == "true") or (v == "false") then
                to_tbl[k] = strbool(v)
            else
                if (type(v) == "string") and v:find("template") then
                    vl("Loading values for %s from template table %s", k, v)
                    to_tbl[k] = {}
                    load_table_values(cfg_table[v], to_tbl[k])
                    template = true
                else
                    to_tbl[k] = v
                end
            end
            if (debug_dump and not template) then vl("* Loaded: %s = %s", k, v) end
        end
    end
    local function load_config_tables(from_tbl)
        if not from_tbl then return end
        for k,v in pairs(from_tbl) do
            vl("Initializing new config subtable %s", k)
            if not cfg_table[k] then cfg_table[k] = {} end
            local tbl_ltx = def_ini:collect_section(k)
            if tbl_ltx then
                local tbl = {}
                if k:find("clsid") then
                    for k1, v1 in pairs(tbl_ltx) do
                        local i = tonumber(k1) or clsid[k1] or k1
                        tbl[i] = v1
                    end
                else
                    tbl = tbl_ltx
                end
                vl("Populating values for config subtable %s", k)
                load_table_values(tbl, cfg_table[k])
            end
        end
    end

    vl("Populating default settings")
    if not cfg_table then cfg_table = {} end
    local def_ltx       = def_ini and def_ini:get_sections(true)
    local dts_ltx       = def_ini:collect_section("default_settings")
    load_table_values(dts_ltx, cfg_table)
    load_config_tables(def_ini:collect_section("template_tables"))
    load_config_tables(def_ini:collect_section("setting_tables"))

    return true
end

-- =======================================================================
--      FONT SETUP
-- =======================================================================
fonts = {
    [0] = { size = 10, card_x = 0, font = GetFontSmall()}, -- need accurate size
    [1] = { size = 14, card_x = 0, font = GetFontMedium()}, -- need accurate size
    [2] = { size = 16, card_x = 0, font = GetFontLetterica16Russian()},
    [3] = { size = 18, card_x = 0, font = GetFontLetterica18Russian()},
    [4] = { size = 30, card_x = 0, font = GetFontLetterica25()},
    [5] = { size = 19, card_x = 0, font = GetFontGraffiti19Russian()},
    [6] = { size = 22, card_x = 0, font = GetFontGraffiti22Russian()},
    [7] = { size = 32, card_x = 0, font = GetFontGraffiti32Russian()},
}

function actor_on_first_update()
    allow_local_logging(true)
end

function on_game_start()
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("actor_on_item_take_from_box", remove_obj_from_box_table)
    RegisterScriptCallback("actor_on_item_put_in_box", add_obj_to_box_table)
end
