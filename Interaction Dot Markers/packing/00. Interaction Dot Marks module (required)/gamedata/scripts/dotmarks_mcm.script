-- ======================================================================
--[[	Interaction Dot Marks ("DotMarks")
-- ======================================================================
 	MCM initialization script
 	Author: Catspaw (CatspawMods @ ModDB)
-- ====================================================================]]
assert(utils_catspaw_common, "\n\n"..
    "! dotmarks_mcm requires utils_catspaw_common, which does not exist!\n\n"
)
assert(utils_catspaw_text, "\n\n"..
    "! dotmarks_mcm requires utils_catspaw_text, which does not exist!\n\n"
)
assert(dotmarks_main, "\n\n"..
    "! dotmarks_mcm requires dotmarks_main, which does not exist!\n\n"
)
script_name 		= "dotmarks_mcm"
debuglogs 			= false
local exes_version 	= MODDED_EXES_VERSION or (get_modded_exes_version and get_modded_exes_version())
local header_desc 	= "ui_mcm_dotmarks_header_main"
local xml 			= CScriptXmlInit()
local headers 		= {}

local get_main_config 	= utils_catspaw_common.get_main_config
local gts 				= game.translate_string
local psk 				= utils_data.parse_string_keys
local sfind 			= string.find
local ssub 				= string.sub
local lang 				= "eng"
local play_snd_path 	= dotmarks_main.play_snd_path
script_version 			= dotmarks_main.script_version or "ersion not found!"
release_date			= tostring(dotmarks_main.release_date) or "date not found! Was ui_hud_dotmarks.script overwritten or disabled?"
local rel_version 		= string.format("$clr_tgrv%s (rel %s)", script_version, release_date)
local cfg 				= utils_catspaw_common.load_file_data("scripts\\dotmarks_defaults.ltx", cfg, {logging = debuglogs, called_by = script_name})
cfg.colors.clr_dmark_norm = utils_catspaw_text.csv_argb_to_tbl(cfg.colors["clr_dmark_norm"])

color_tokens = {
    ["clr_lbl"] = "%" .. "%c[255,0,200,220]",
    ["clr_gld"] = "%" .. "%c[255,255,215,0]",
    ["clr_wht"] = "%" .. "%c[255,255,255,255]",
    ["clr_red"] = "%" .. "%c[255,255,0,0]",
    ["clr_tgr"] = "%" .. "%c[128,90,90,90]",
    ["clr_cmg"] = "%" .. "%c[255,150,150,150]",
    ["clr_uab"] = "%" .. "%c[255,0,87,183]",
}

-- ======================================================================

local pre 	= {}
local wnds 	= {}
local cache = {}

function unsquish(width)
    return (width or 0) * (cfg.unsquish_ratio or 1)
end

function init_preview(anchor, handlers, opts, flags)
	pre.main = xml:InitStatic("box", anchor)
	pre.main:SetWndSize(vector2():set(unsquish(300), 190))
	pre.main:SetWndPos(vector2():set(unsquish(430), (lang == "rus") and 210 or 180))

	pre.bg 	= xml:InitStatic("box", pre.main)
	pre.bg:InitTexture("ui_mcm_dmarks_preview_static")
	pre.bg:SetWndSize(vector2():set(unsquish(300), 190))

	pre.fr 	= xml:InitStatic("box", pre.bg)
	pre.fr:InitTexture("ui_mcm_dmarks_preview_frame")
	pre.fr:SetWndSize(vector2():set(unsquish(300), 190))
end

function init_simple_icon(anchor, handlers, opts, flags)
	flags.icon_w 	= flags.icon_w or opts.icon_w
	flags.icon_h 	= flags.icon_h or opts.icon_h or flags.icon_w
	flags.icon_x 	= flags.icon_x or opts.icon_x
	flags.icon_y 	= flags.icon_y or opts.icon_y
	local icon 		= flags.icon or opts.icon
	local ctrl 		= xml:InitStatic("box", anchor)
	ctrl:InitTexture(opts.icon)
	ctrl:SetWndSize(vector2():set((flags.icon_w or 0) * cfg.unsquish_ratio, flags.icon_h or 0))
	ctrl:SetWndPos(vector2():set((flags.icon_x or 0) * cfg.unsquish_ratio, flags.icon_y or 0))
	return ctrl
end


function init_icon_list(anchor, handlers, opts, flags)
	printf("init_icon_list start")
	local icons = opts and opts.icon_list or cfg.service_icons
	local used = {}
	local i = 0
	for k,v in spairs(icons) do
		if not used[v] then
			local x = opts.icon_x + ((opts.icon_w + 2) * i)
			local ctrl = xml:InitStatic("box", anchor)
			ctrl:InitTexture(v)
			ctrl:SetWndSize(vector2():set((opts.icon_w or 0) * cfg.unsquish_ratio, opts.icon_h or opts.icon_w or 0))
			ctrl:SetWndPos(vector2():set((x or 0) * cfg.unsquish_ratio, opts.icon_y or 0))
			i = i + 1
			used[v] = ctrl
		end
	end
	wnds[opts.id] 		= used
	wnds[opts.id].opts 	= opts
	return wnds[opts.id]
end

-- ======================================================================

local argb_ctrl

function init_header_element(anchor, handlers, opts, flags)
	handlers.desc:SetText("")
	if opts.id == ("blank_space") then return end

	local bg	= xml:InitStatic("box", anchor)
	local text	= xml:InitTextWnd("box", bg)

	if opts.dmark_apos then
		anchor:SetWndPos(vector2():set(0, opts.dmark_apos))
	end

	if opts.id == "header_main" then
		local rvbox	= xml:InitTextWnd("box", anchor)
		rvbox:SetWndSize(vector2():set(480 * cfg.unsquish_ratio, 20))
		rvbox:SetText(psk(rel_version, color_tokens))
		rvbox:SetWndPos(vector2():set(10 * cfg.unsquish_ratio, -8))
		--rvbox:SetFont(GetFontSmall())
		rvbox:SetTextComplexMode(true)
	end

	if opts.dmark_tex then
		bg:SetWndSize(vector2():set(650 * cfg.unsquish_ratio, opts.dmark_box_h or 0))
		bg:SetWndPos(vector2():set(10, opts.dmark_bpos or 0))
		bg:InitTexture(opts.dmark_tex)
	end		

	text:SetWndSize(vector2():set(620 * cfg.unsquish_ratio, opts.dmark_text_h or 0))
	text:SetText(psk(gts(opts.dmark_text or opts.text), color_tokens))
	text:SetWndPos(vector2():set(10, opts.dmark_text_v or 0))
	text:SetTextComplexMode(true)
end


function sync_widget_color(ctrl, colors)
	if not (ctrl and colors) then return end
	ctrl:SetTextureColor(GetARGB(colors.a, colors.r, colors.g, colors.b))
end

function sync_widget_size(ctrl, w, h)
	if not (ctrl and w) then return end
	ctrl:SetWndSize(vector2():set(w, h or w))
	ctrl:EnableHeading(true)
    ctrl:SetConstHeading(true)
end

function init_dotmark_preview(anchor, handlers, opts, flags)
	local opts2 	= dup_table(opts)
	opts2.icon 		= "ui_catsy_marker_dotactive"
	opts2.icon_x 	= (opts.icon_x - 35)
	wnds[opts.id] = {
		reg = init_simple_icon(anchor, handlers, opts, flags),
		act = init_simple_icon(anchor, handlers, opts2, flags)
	}
	local ctrl = wnds[opts.id]
	local size 	= get_main_config("dotmarks/dotmain/dot_marker_size", 2) or 1
	--printf("marker size loaded: %s | base %s", size, opts.icon_w)
	local color = cfg.colors.clr_dmark_norm
	ctrl.reg.opts = opts
	ctrl.act.opts = opts2
	on_dotmark_size_select(flags.path, opts.id, size)
	return ctrl
end

function on_dotmark_size_select(path, opt, value, attrs)
	local ctrl 	= wnds[opt]
	if not ctrl then return end
	cache[opt] 	= value
	local opts 	= ctrl.reg.opts
	local szw 	= opts.icon_w or 5
	local szh 	= opts.icon_h
	local w 	= value * szh
	local h 	= value * szh
	local diff 	= (szw  - w) / 2
	local diff2 = (szw  - (w * 2)) / 2
	local x 	= (opts.icon_x + diff ) * cfg.unsquish_ratio
	local x2 	= (opts.icon_x + diff2 - 35 ) * cfg.unsquish_ratio
	local y 	= opts.icon_y
	--printf("[%s][%s] val %s | sz %s,%s | new %s,%s | diff %s | x,y %s,%s", path,opt,value,szw,szh,w,h,diff,x,y)
	sync_widget_size(ctrl.reg, w, h)
	sync_widget_size(ctrl.act, w * 2, h * 2)
	ctrl.reg:SetWndPos(vector2():set(x, y + diff))
	ctrl.act:SetWndPos(vector2():set(x2, y + diff2))
end

-- ======================================================================

function get_main_menu()
	return {
		{ id = "menuslide_main", type = "slide", link = "ui_mcm_dotmarks_banner_main", size = {512,50}, spacing = 0,
			ui_hook_functor = {dotmarks_mcm.init_preview},
			-- a proper PAW-style live preview is going to take a lot more work
		},		
		{ id = "header_main", 		type = "desc", text = "ui_mcm_dotmarks_header_main_nocolor",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_text 		= header_desc,
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head" .. ((lang == "rus") and "140" or "90"),
			dmark_apos 		= -20,
			dmark_bpos 		= 10,
			dmark_box_h 	= (lang == "rus") and 130 or 100,
			dmark_text_h 	= (lang == "rus") and 120 or 90,
			dmark_text_v 	= 12
		},

		{ id = "show_item_card", 		type = "check", 	val = 1, def = cfg.show_item_card},
		{ id = "show_item_charge", 		type = "check", 	val = 1, def = cfg.show_item_charge},
		{ id = "show_multi_uses", 		type = "check", 	val = 1, def = cfg.show_multi_uses},
		{ id = "sp_flag_favejunk", 		type = "check", 	val = 1, def = cfg.sp_flag_favejunk},
		{ id = "show_item_condition", 	type = "check", 	val = 1, def = cfg.show_item_condition and not utils_catspaw_common.using_gamma_modpack},
		{ id = "show_condition_color", 	type = "check", 	val = 1, def = cfg.show_condition_color},
		{ id = "show_condition_color", 	type = "check", 	val = 1, def = cfg.show_condition_color},
		{ id = "show_stash_weight", 	type = "check", 	val = 1, def = cfg.show_stash_weight},
		{ id = "wheel_cycles_pickups", 	type = "check", 	val = 1, def = cfg.wheel_cycles_pickups },
		{ id = "dot_marker_size", 		type = "track",		val = 2, min = 0, step = 0.1, max = 2, def = cfg.dot_marker_size,
			on_selection_functor= {dotmarks_mcm.on_dotmark_size_select},
			ui_hook_functor 	= {dotmarks_mcm.init_dotmark_preview},
			icon 	= cfg.marker_dotmark or "",
			icon_w 	= (cfg.dotmark_preset.width or 5) * 1.5,
			icon_h 	= (cfg.dotmark_preset.height or 5) * 1.5,
			icon_x 	= 370,
			icon_y 	= 12,
		},
		{ id = "interact_drop_alpha", 	type = "track", 	val = 2, min = 0, step = 0.01, max = 1, def = cfg.interact_drop_alpha },

		{id = "divider", type= "line"},
	}
end

-- ======================================================================

function get_sec_menu()
	return {
		{ id = "menuslide_sec", type = "slide", link = "ui_mcm_dotmarks_banner_sec", size = {512,50}, spacing = 0},

		{ id = "header_sec", 	type = "desc", clr = {255,255,215,0}, text = "ui_mcm_dotmarks_alti_desc",
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head90",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_apos 		= -5,
			dmark_box_h 	= 115,
			dmark_text_h 	= 105,
			dmark_text_v 	= 10
		},
		{ id = "bind_sec_interact", 	type = "key_bind", 			val = 2, def = cfg.bind_sec_interact or bind_to_dik(key_bindings.kUSE)},
		{ id = "modk_sec_interact", 	type = ui_mcm.kb_mod_radio, val = 2, def = cfg.modk_sec_interact, hint = "mcm_kb_modifier", 
			content = {
				{0,"mcm_kb_mod_none"},
				{1,"mcm_kb_mod_shift"},
				{2,"mcm_kb_mod_ctrl"},
				{3,"mcm_kb_mod_alt"}
			}
		},
		{ id = "imod_sec_interact", 	type = ui_mcm.kb_mod_radio, val = 2, def = cfg.imod_sec_interact, hint = "mcm_kb_mode",
			content = {
				{0,"mcm_kb_mode_press"},
				{1,"mcm_kb_mode_dtap"},
				{2,"mcm_kb_mode_hold"}
			}
		},

		{id = "divider", type= "line"},

		{ id = "long_press_delay", 		type = "input", 	val = 2, min = 50, max = 2000, def = cfg.long_press_delay },

		{id = "divider", type= "line"},
	}
end

-- ======================================================================


function get_mods_menu()
	return {
		{ id = "menuslide_sec", type = "slide", link = "ui_mcm_dotmarks_banner_mods", size = {512,50}, spacing = 0},

		{ id = "header_addons", 	type = "desc", text = "ui_mcm_dotmarks_addons_desc",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head90",
			dmark_apos 		= -10,
			dmark_box_h 	= 75,
			dmark_text_h 	= 70,
			dmark_text_v 	= 11
		},
		{ id = "bodies_use_paw_patches",type = "check", 	val = 1, def = cfg.bodies_use_paw_patches },
		{ id = "bodies_use_mpda_rules",	type = "check", 	val = 1, def = cfg.bodies_use_mpda_rules },
		{ id = "alti_show_during_anim", type = "check", 	val = 1, def = cfg.alti_show_during_anim },
		{ id = "alti_busy_during_anim", type = "check", 	val = 1, def = cfg.alti_busy_during_anim },
		{ id = "item_use_delay", 		type = "track", 	val = 2, min = 0, step = 0.01, max = 1, def = cfg.item_use_delay },
		{ id = "sp_hide_junk_items", 	type = "check", 	val = 1, def = cfg.sp_hide_junk_items },
		{ id = "sp_icon_pos_x", 		type = "input", 	val = 2, min = -512, max = 1024, def = cfg.sp_icon_pos_x},
		{ id = "sp_icon_pos_y", 		type = "input", 	val = 2, min = -384, max = 768, def = cfg.sp_icon_pos_y },
		{ id = "parts_dot_pos_x", 		type = "input", 	val = 2, min = -512, max = 1024, def = cfg.parts_dot_pos_x },
		{ id = "parts_dot_pos_y", 		type = "input", 	val = 2, min = -384, max = 768, def = cfg.parts_dot_pos_y },
		{ id = "use_skill_system", 		type = "check", 	val = 1, def = cfg.use_skill_system },
		{ id = "haru_skill_coef", 		type = "input", 	val = 2, min = 0, max = 5, step = 0.01, def = cfg.haru_skill_coef },
		{ id = "skill_upd_interval", 	type = "input", 	val = 2, min = 0, max = 120000, step = 1, def = cfg.skill_upd_interval },
		{ id = "haru_skill_name", 		type = "input", 	val = 0, def = cfg.haru_skill_name },

		{id = "divider", type= "line"},

	}
end

-- ======================================================================

function get_adv_menu()
	return {
		{ id = "menuslide_adv", type = "slide", link = "ui_mcm_dotmarks_banner_adv", size = {512,50}, spacing = 0 },
		{ id = "header_debug", 		type = "desc", text = "ui_mcm_dotmarks_header_debug_nocolor",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_text 		= "ui_mcm_dotmarks_header_debug",
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head140",
			dmark_apos 		= -20,
			dmark_box_h 	= 145,
			dmark_text_h 	= 130,
			dmark_text_v 	= 10
		},
		{ id = "debuglogs", 			type = "check", 	val = 1, def = ui_hud_dotmarks.debuglogs },
		{ id = "verbose", 				type = "check", 	val = 1, def = ui_hud_dotmarks.verbose },

		{id = "divider", type= "line"},

		{ id = "header_adv", 		type = "desc", text = "ui_mcm_dotmarks_adv_desc",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head90",
			dmark_box_h 	= 95,
			dmark_text_h 	= 90,
			dmark_text_v 	= 9
		},

		{ id = "hide_interaction_dots", type = "check", 	val = 1, def = cfg.hide_interaction_dots },
		{ id = "hidden_show_prompts", 	type = "check", 	val = 1, def = cfg.hidden_show_prompts },
		{ id = "hide_connecting_line", 	type = "check", 	val = 1, def = cfg.hide_connecting_line },
		{ id = "hide_pri_interact_ui", 	type = "check", 	val = 1, def = cfg.hide_pri_interact_ui },
		{ id = "hide_sec_interact_ui", 	type = "check", 	val = 1, def = cfg.hide_sec_interact_ui },
		{ id = "hide_van_interact_ui", 	type = "check", 	val = 1, def = cfg.hide_van_interact_ui },

		{ id = "disable_all_sounds", 	type = "check", 	val = 1, def = cfg.disable_all_sounds },

		{id = "divider", type= "line"},
		
		{id = "keybind_bg_style", type= "list", val = 2, def = cfg.keybind_bg_style, 
			content = {
			   {3,"dmarks_kbstyle_worn"},
			   {2,"dmarks_kbstyle_full"},
			   {1,"dmarks_kbstyle_wire"},
			   {0,"dmarks_kbstyle_none"},
			}
		},

		{ id = "font_main_prompt", 		type= "list", 		val = 2, def = cfg.font_main_prompt, 
			content = {
			   {7,"dmarks_font_graf32"},
			   {6,"dmarks_font_graf22"},
			   {5,"dmarks_font_graf19"},
			   {4,"dmarks_font_let25"},
			   {3,"dmarks_font_let18"},
			   {2,"dmarks_font_let16"},
			   {1,"dmarks_font_medium"},
			}
		},

		{ id = "font_item_card", 		type= "list", 		val = 2, def = cfg.font_item_card, 
			content = {
			   {6,"dmarks_font_graf22"},
			   {5,"dmarks_font_graf19"},
			   {4,"dmarks_font_let25"},
			   {3,"dmarks_font_let18"},
			   {2,"dmarks_font_let16"},
			   {1,"dmarks_font_medium"},
			   {0,"dmarks_font_small"},
			}
		},

		{ id = "prompt_fade_in_time", 	type = "track",		val = 2, min = 0, step = 1, max = 1000, def = cfg.prompt_fade_in_time },
		{ id = "prompt_fade_out_time", 	type = "track",		val = 2, min = 0, step = 1, max = 1000, def = cfg.prompt_fade_out_time },
		{ id = "popin_anim_dur", 		type = "track",		val = 2, min = 0, step = 1, max = 2000, def = cfg.popin_anim_dur },

		{ id = "action_text_pos_x", 	type = "input", 	val = 2, min = -384, max = 768, def = cfg.action_text_pos_x },
		{ id = "action_text_pos_y", 	type = "input", 	val = 2, min = -512, max = 1024, def = cfg.action_text_pos_y },
		{ id = "bind_text_pos_x", 		type = "input", 	val = 2, min = -512, max = 1024, def = cfg.bind_text_pos_x },
		{ id = "bind_text_pos_y", 		type = "input", 	val = 2, min = -384, max = 768, def = cfg.bind_text_pos_y },
		{ id = "bind_char_scale", 		type = "input", 	val = 2, min = 0, max = 10, def = cfg.bind_char_scale },

		{id = "divider", type= "line"},

		{ id = "header_icard", 		type = "desc", clr = {255,255,215,0}, text = "ui_mcm_dotmarks_itemcard_desc",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head90",
			dmark_apos 		= -10,
			dmark_box_h 	= 70,
			dmark_text_h 	= 60,
			dmark_text_v 	= 10
		},
		{ id = "item_card_pos_x", 		type = "input", 	val = 2, min = -512, max = 1024, def = cfg.item_card_pos_x },
		{ id = "item_card_pos_y", 		type = "input", 	val = 2, min = -384, max = 768, def = cfg.item_card_pos_y },
		{ id = "item_card_icon_sz", 	type = "input",		val = 2, min = 0, max = 64, def = cfg.item_card_icon_sz },

		{id = "divider", type= "line"},

		{ id = "header_offset",	type = "desc", text = "ui_mcm_dotmarks_offsets_desc",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head90",
			dmark_apos 		= -10,
			dmark_box_h 	= 60,
			dmark_text_h 	= 50,
			dmark_text_v 	= 12
		},
		{ id = "pri_use_x_offset", 		type = "input", 	val = 2, min = -512, max = 1024, def = cfg.pri_use_x_offset },
		{ id = "pri_use_y_offset", 		type = "input", 	val = 2, min = -384, max = 768, def = cfg.pri_use_y_offset },
		{ id = "sec_use_x_offset", 		type = "input", 	val = 2, min = -512, max = 1024, def = cfg.sec_use_x_offset },
		{ id = "sec_use_y_offset", 		type = "input", 	val = 2, min = -384, max = 768, def = cfg.sec_use_y_offset },
		{ id = "fixed_screen_pos", 		type = "check", 	val = 1, def = cfg.fixed_screen_pos },

		{id = "divider", type= "line"},
		{ id = "near_scan_interval", 	type = "input", 	val = 2, min = 0, max = 10000, step = 1, def = cfg.near_scan_interval },
		{ id = "early_scan_interval", 	type = "input", 	val = 2, min = 0, max = 30000, step = 1, def = cfg.early_scan_interval },
		{ id = "near_scan_radius", 		type = "input", 	val = 2, min = 0, max = 500, step = 0.5, def = cfg.near_scan_radius },
		{ id = "early_scan_radius", 	type = "input", 	val = 2, min = 0, max = 500, step = 0.5, def = cfg.early_scan_radius },

		{id = "divider", type= "line"},
	}
end

-- ======================================================================

function generate_objs_menu()
	local gr = {
	-- ======================================================================
	-- 	Main header
		{ id = "menuslide_objs", 		type = "slide", link = "ui_mcm_dotmarks_banner_objs", size = {512,50}, spacing = 0 },
		{ id = "objheader", 			type = "desc", text = "ui_mcm_dotmarks_objmenu",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head90",
			dmark_box_h 	= 100,
			dmark_text_h 	= 90,
			dmark_text_v 	= 12
		},
	}

	-- ======================================================================
	-- 	Inject focus icons that aren't singletons and need to be at the top
	table.insert(gr,
		{ id = "disable_icon_services", type = "check", val = 1, def = cfg.disable_icon_services,
			ui_hook_functor = {dotmarks_mcm.init_icon_list},
			icon_list 	= cfg.service_icons,
			icon_w 		= 32,
			icon_h 		= 32,
			icon_x 		= 450,
			icon_y 		= 8,
		}
	)
	table.insert(gr,
		{ id = "disable_icon_tasks", type = "check", val = 1, def = cfg.disable_icon_tasks,
			ui_hook_functor = {dotmarks_mcm.init_icon_list},
			icon_list 	= cfg.task_icons,
			icon_w 		= 32,
			icon_h 		= 32,
			icon_x 		= 450,
			icon_y 		= 8,
		}
	)

	-- ======================================================================
	-- 	Iterate the rest of the focus icons
	local tbl = {}
	for k,v in pairs(cfg.setting_icons) do
		tbl[#tbl + 1] = k
	end

	table.sort(tbl, function(a, b) return a > b end)
	for _, opt_id in spairs(tbl) do
		local enabled = cfg[opt_id]
		local iclass = cfg.setting_icons[opt_id]
		local icon 	= iclass and cfg.tex[iclass]
		table.insert(gr, 
			{ id = opt_id, type = "check", val = 1, def = cfg[opt_id],
				ui_hook_functor = {dotmarks_mcm.init_simple_icon},
				icon = icon or "",
				icon_w = 24,
				icon_h = 24,
				icon_x = 450,
				icon_y = 11,
			}
		)
	end
	table.insert(gr, {id = "divider", type= "line"})

	table.insert(gr,
		{ id = "scanheader", type = "desc", text = "ui_mcm_dotmarks_scanmenu",
			ui_hook_functor = {dotmarks_mcm.init_header_element},
			dmark_tex 		= "ui_mcm_dmarks_messagebox_transbg_head90",
			dmark_box_h 	= 70,
			dmark_text_h 	= 65,
			dmark_text_v 	= 10
		}
	)

	-- ======================================================================
	-- 	Iterate scannable objects
	tbl = {}
	for k,v in pairs(cfg.scan) do
		tbl[#tbl + 1] = k
	end
	table.sort(tbl)
	for _, item_class in spairs(tbl) do
		local enabled = cfg.scan[item_class]
		local opt_id = "scan_" .. string.lower(item_class)
		table.insert(gr, { id = opt_id, type= "check", val = 1, def = enabled })
	end
	table.insert(gr, {id = "divider", type= "line"})

	return gr
end

-- ======================================================================

function on_mcm_load()
	if not cfg then return end
	cache = {}
	cfg.unsquish_ratio = utils_catspaw_hudmarks.update_unsquish_ratio() or 1
	lang = ui_options.curr_localization()
	xml:ParseFile("ui_dotmarks.xml")
	if exes_version then
		if exes_version < 20250306 then
			header_desc = "ui_mcm_dotmarks_header_oldexes"
		end
	else
		header_desc = "ui_mcm_dotmarks_header_notmodded"
	end

	op = { id = "dotmarks", gr = {
			{ id = "dmarkmain", sh = true, gr = get_main_menu() },
			{ id = "dmarksec", 	sh = true, gr = get_sec_menu() },
			{ id = "dmarkobjs", sh = true, gr = generate_objs_menu() },
			{ id = "dmarkmods", sh = true, gr = get_mods_menu() },
			{ id = "dmarkadv", 	sh = true, gr = get_adv_menu() },
		}
	}
	return op
end
