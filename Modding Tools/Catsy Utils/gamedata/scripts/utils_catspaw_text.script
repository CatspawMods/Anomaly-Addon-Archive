-- =======================================================================
--[[	Catsy's utilities: text and names
-- ===================================================================--]]
script_name 	= "utils_catspaw_text"
script_version 	= "1.6"
release_date    = 20250322
--[[======================================================================
	Author: Catspaw (CatspawMods @ ModDB)
	Source: https://github.com/CatspawMods/Anomaly-Addon-Archive

	There are a bunch of functions that I use across my addons, and over
	time they've added up to a fair bit of duplicated code that I also 
	have to update in multiple places anytime they get improved/fixed.

	This is an attempt at centralizing them, and unifying some functions
	that I'd like to be more consistent across my addons (like color and
	text tokenization). I will endeavor to always make these backwards-
	compatible, so heed well:

		IN THE EVENT OF A FILE CONFLICT, ALWAYS USE THE MOST RECENT.

	Feel free to crib code from this or include a copy of it in your own 
	addon, but in the interest of avoiding any possibility of conflicts:

			PLEASE DO NOT MAKE CHANGES TO THIS SCRIPT ITSELF.

	Seriously. Just copy the code into yours if you want to mess with it.
-- ===================================================================--]]
-- 		DEPENDENCIES
-- =======================================================================
assert(utils_catspaw_common,
"! ERROR: " .. script_name .. " requires utils_catspaw_common, which could not be found!")
-- =======================================================================
-- 		LOGGING
-- =======================================================================
local dl, vl
debuglogs   = false
verbose     = false

function allow_local_logging(onoff)
    -- By default, logging in this script inherits its settings from utils_catspaw_common
    -- This function allows anyone to switch on debug logging for this script's operations only
    if onoff then
        dl = function(logtext, ...) utils_catspaw_common.dlog(this, logtext, ...) end
        vl = function(logtext, ...) utils_catspaw_common.vlog(this, logtext, ...) end
    else
        dl = function(logtext, ...) utils_catspaw_common.dlog(nil, logtext, ...) end
        vl = function(logtext, ...) utils_catspaw_common.vlog(nil, logtext, ...) end
    end
end
allow_local_logging(true)

function set_debug_logging(debug_en, verbose_en)
    if (debug_en ~= nil) then debuglogs = debug_en end
    if (verbose_en ~= nil) then verbose = verbose_en end
end
--set_debug_logging(true, true) --uncomment this line to enable all logging for troubleshooting

-- =======================================================================
-- 		SHORTCUTS
-- =======================================================================
local safeid 			= utils_catspaw_common.safeid
local valid_id 			= utils_catspaw_common.valid_id
local getstrtbl_support	= utils_catspaw_common.exe_getstrtbl_support
local get_stash_hint 	= utils_catspaw_common.get_stash_hint
-- =======================================================================
local psk       		= utils_data.parse_string_keys
local gts 				= game.translate_string
local sformat 			= string.format
local sfind 			= string.find
local floor 			= math.floor
local DIK_name          = ui_mcm and ui_mcm.display_key or (function() return "" end)

-- =======================================================================
-- 		TEXT SUBSTITUTION
-- =======================================================================
local female_names		= {}
local default_tokens 	= {}
local game_tokens = {
	ruble 		= "",
}
local actor_tokens = {
	actorcomm 	= "",
	actordisg 	= "",
	actorname	= "",
	actorfn		= "",
	actorln 	= "",
	actorlead 	= "",
	actorloc	= "",
	freq 		= "",
}

local ruble_locstr 		= "st_currency_rub"

function first_lower(str)
    return str and (str:gsub("^%u", string.lower))
end

function first_upper(str)
    return str and (str:gsub("^%l", string.upper))
end

function explode_name(name)
	--
	return str_explode(name or ""," ")
end

function get_firstname_lastname(name, default_nil)
	if (not name) then
		if db.actor then
			name = alife():actor():character_name()
		else
			return
		end
	end
	local firstlast = explode_name(name)
	return 	firstlast[1] or ((not default_nil) and name),
			firstlast[2] or ((not default_nil) and (firstlast[1] or name))
end

function get_name_gender(name)
	-- A bit hacky and only detectable/relevant if Dux's character kit is installed
	local gender = "m"
	if name and female_names and not is_empty(female_names) then
		name = explode_name(name)
		if female_names[name[1]] then gender = "f" end
	end
	return gender
end

function refresh_tokens(args)
	local custom_tokens = args and args.tokens or {}
	local obj_tokens 	= {
		name		= "",
		firstname	= "",
		lastname 	= "",
		location 	= "",
		comm		= "",
		leader 		= "",
	}
	local tokens 		= {}

	if db.actor then
		local actor_name 	= alife():actor():character_name()
		local afirst, alast	= get_firstname_lastname()
		local actor_comm 	= gameplay_disguise.get_default_comm()
		local disg_comm 	= db.actor:character_community()
		local fac 			= faction_expansions.faction[actor_comm]

		actor_tokens["actorcomm"]	= actor_comm	-- Actor true faction
		actor_tokens["actordisg"] 	= disg_comm 	-- Actor disguised faction (or true faction if not disguised)
		actor_tokens["actorname"]	= actor_name 	-- Actor character name in this save
		actor_tokens["actorfn"] 	= afirst 		-- Actor first name
		actor_tokens["actorln"] 	= alast 		-- Actor last name
		actor_tokens["actorlead"]	= gts(fac["leader_name"] or "") -- Actor faction leader name
		actor_tokens["actorloc"] 	= dynamic_news_helper.GetPointDescription(db.actor)
		-- Actor nearest spot location description - the blurb used in news messages about
		-- a particular location at a point, e.g. "in Cordon, east of the Rookie Village"
	end


	if args then
		local function add_tokens_from_args()
			-- Refresh token tables with any existing token names also present in args
			for k,v in pairs(args) do
				if type(v) == "string" then
					if actor_tokens[k] then actor_tokens[k] = v end
					if game_tokens[k] then game_tokens[k] = v end
					if obj_tokens[k] then obj_tokens[k] = v end
				end
			end
		end

		add_tokens_from_args()

		if args.first_init or args.force_refresh then
			dl("Refreshing standard text substitution tokens")
			
			local ruble = gts(ruble_locstr)
			if ruble == ruble_locstr then ruble = "RU" end
			game_tokens["ruble"]= ruble
		end

		if args.obj then
			if IsStalker(args.obj) then
				local id 			= safeid(args.obj)
				local npc 			= alife_object(id)
				local npc_gobj 		= db.storage[id] and db.storage[id].object or level.object_by_id(id)
				obj_tokens.comm 	= get_object_community(npc)
				local fac 			= faction_expansions.faction[obj_tokens.comm]
				obj_tokens.leader 	= gts(fac["leader_name"] or "")
				local npcname 		= npc:character_name()
				local nfirst, nlast = get_firstname_lastname(npcname)
				obj_tokens.firstname= first
				obj_tokens.lastname = last
				obj_tokens.location = dynamic_news_helper.GetPointDescription(npc_gobj)
			end
		end
	end
end

local parse_colors 		= true
local color_tokens 		= {
	["clr_def"] = "%" .. "%c[default]",			-- UI element's default color
	-- NOTE: %c[default] must be lowercase, or Anomaly will shit itself with more than two commas in the string
	-- Thanks to xcvb for pointing this out the cause of this weird-ass bug.
    ["clr_wht"] = "%" .. "%c[255,220,220,220]",	-- white, but not fullbright
    ["clr_red"] = "%" .. "%c[255,255,0,0]", 	-- full red
    ["clr_grn"] = "%" .. "%c[255,0,255,0]", 	-- full green
    ["clr_blu"] = "%" .. "%c[255,0,0,255]", 	-- full blue
    ["clr_orn"] = "%" .. "%c[255,255,140,0]",	-- the orange used in some dialogs, like the vanilla guide costs
    ["clr_gld"] = "%" .. "%c[255,255,215,0]", 	-- gold color
    ["clr_yel"] = "%" .. "%c[255,255,255,0]",	-- full yellow
    ["clr_lbl"] = "%" .. "%c[255,0,200,220]",	-- light blue color
    ["clr_prp"] = "%" .. "%c[255,137,48,225]", 	-- purple
    ["clr_cmg"]	= "%" .. "%c[255,150,150,150]",	-- context menu gray
    ["clr_tgr"] = "%" .. "%c[128,90,90,90]",    -- transparent neutral gray - used by me in menus for version tags
    ["clr_ui2"]	= "%" .. "%c[ui_2]",			-- system color: 255,232,208
    ["clr_ui8"]	= "%" .. "%c[ui_8]",			-- dialogue text: 216,186,140 - you know, that pale khaki
}
local nocolor_tokens 	= {}

function get_color_tokens()			return color_tokens or {} end
function get_nocolor_tokens()		return nocolor_tokens or {} end

function update_nocolor_tokens()
	-- manually resync nocolor_tokens table with color_tokens
	for k,v in pairs(color_tokens) do
		nocolor_tokens[k] = ""
	end
end

function set_color_token(k, s)
	-- set or add a color token in the format of the color_tokens table above
	color_tokens[k] = "%" .. s
	nocolor_tokens[k] = ""
end

update_nocolor_tokens()

function int_to_rgba(i)
	-- Converts integer to RGB or RGBA values
	-- returns r, g, b, a, defaulting alpha to 255 if not specified (value is <= 0xffffff)
	-- Improved bitwise version from RavenAscendant
	-- Should be functionally identical but much more efficient
	if not (i and type(i) == "number") then return end
	local a
	if i <= 0xffffff then a = 255 end
	return 	bit.band(bit.rshift(i, 16), 255),
			bit.band(bit.rshift(i, 8), 255),
			bit.band(i, 255),
			a or bit.band(bit.rshift(i, 24), 255)
--[[
	if not (i and type(i) == "number") then return end
	return 	floor(floor(i / 256) / 256) % 256, 
			floor(i / 256) % 256, 
			(i % 256), 
			(i > 0xffffff) and (floor(floor(floor(i / 256) / 256) / 256) % 256) or 255
--]]
end

function parse_hex_colors(str)
	-- Populates the color_tokens table on the fly with any hex color codes found in str
	-- Looks for color codes are in the format: $0xNh, where N is a hexadecimal integer
	-- If N is 24-bit rather than 32-bit, the alpha will default to 255
	-- e.g.:
	-- 	$0xff0080h 		-> 	%%c[255,255,0,128]
	-- 	$0x40ff0080h	-> 	%%c[64,255,0,128]
	local pattern = "$0x%x?%x?%x?%x?%x?%x?%x?%xh"
	
	repeat
		local mt = str:match(pattern)
		if mt then
			local key = mt:sub(2)
			local i = str:find(pattern) + #mt
			str = str:sub(i)
			if not color_tokens[key] then
				local hexcode = mt:sub(2, #mt - 1)
				local r, g, b, a = int_to_rgba(tonumber(hexcode or 0))
				local subst = "%" .. "%c[" .. sformat("%s,%s,%s,%s",a,r,g,b) .. "]"
				set_color_token(key, subst)
			end
		end
	until not mt
end

function parse_color_tokens(s, t, c)
	-- s: string to parse
	-- t: optional table of string replacement tokens for utils_data.parse_string_keys
	-- c: true/false whether to parse or strip color tokens
	if not s then return end
	local docolor = (c == nil) and parse_colors or c
	vl("parse_color_tokens | text: %s | docolor: %s%s", s, docolor, (c == nil) and " (default)" or "")
	if t and not is_empty(t) then
		s = psk(s, t or {})
	end
	if s:find("$0x") then
		parse_hex_colors(s)
	end
	return psk(s, docolor and color_tokens or nocolor_tokens)
end

-- =======================================================================
-- 		KEYBIND TEXT
-- =======================================================================
function valid_bind(kb)
    return (kb ~= nil) and (kb ~= "") and (kb ~= "<!!!>") and (kb ~= -1)
end


function bindtext(kb, km)
	-- Returns the display name for kb and km, where:
	-- 	kb = the DIK code of any keybind, and
	-- 	km = whether that key takes a modifier
	-- 		0 - no modifier
	-- 		1 - Shift
	-- 		2 - Ctrl
	-- 		3 - Alt
    local kbt = ""
    local kmt = ""
    local mt = ""
    local vbkb = valid_bind(kb)
    local vbkm = km and km > 0
    if vbkb then
        kbt = DIK_name(kb)
    end
    if vbkm then
        if km and km < 29 then
            km = ((km == 1) and 42) or ((km == 2) and 29) or ((km == 3) and 56)
        end
        if km then
            kmt = DIK_name(km)
        end
    end

    if vbkb and vbkm then
        mt = "+"
    elseif not (vbkb or vbkm) then
        kmt = "[UNBOUND]"
        mt = ""
        kbt = ""
    end

    return string.format("%s%s%s",kmt,mt,kbt)
end

-- =======================================================================
-- 		OBJECT NAMES
-- =======================================================================

function inventory_name(obj, section)
	section = section or (obj and obj:section())
	return section and ini_sys:r_string_ex(section, "inv_name") or nil
end

function find_best_localization(obj, name, section)
	-- Tries to find the best localized name for an object of unknown type
	-- based on known localization string naming patterns
    name = name or (obj and (inventory_name(obj) or obj:name()))
    section = section or (obj and ((obj.section and obj:section()) or (obj.section_name and obj:section_name())))

    local locst = section and ini_sys:r_string_ex(section, "inv_name")
    local text  = locst and gts(locst)
    if text and locst and (text ~= locst) then
        vl("Found localization for string %s: %s", locst, text)
    end

    if name and not text then
        for _,locst in ipairs({
        		name, "st_"..name,
        		name.."_name",
        		"st_"..name.."_name"
        	}) do
            text = gts(locst)
            if text ~= locst then
                vl("Found localization for string %s: %s", locst, text)
                break
            else
                text = nil
            end
        end
    end
    if section and not text then     
        for _,locst in ipairs({
        		section, "st_"..section,
        		section.."_name",
        		"st_"..section.."_name"
        	}) do
            text = gts(locst)
            if text ~= locst then
                vl("Found localization for string %s: %s", locst, text)
                break
            else
                text = nil
            end
        end
    end
    if not text then
        dl("No localization or other name found for object | name %s | section %s", name, section)
    end
    return text
end

function safename(id)
    if not valid_id(id) then return end
	local nameid 	= obj_name_and_id
    local text      = "unknown"
    local se_obj    = alife_object(id)
    if not se_obj then return text end
    local name      = se_obj:name() or text
    local cls       = se_obj:clsid()

    if paw and paw.pins[id] then
        -- If there's a pin for this ID, use its text above all else
        text = paw.pins[id].name
        vl("%s is a pin: %s", nameid(name, id), text)
    elseif paw and (cls == clsid.script_zone) then
        text = gts("st_paw_pin_default_name")
        vl("%s is a script zone: %s", nameid(name, id), text)
    elseif (cls == clsid.script_restr) then
        local _,_,hint = txr_routes.get_route_info(name)
        if hint then
            text = hint and gts(hint) or text
        else
            text = gts(name)
        end
        vl("%s is a level transition: %s", nameid(name, id), text)
    elseif (cls == clsid.smart_terrain) then
        text = gts("st_"..name.."_name"):gsub("%."," -")
        vl("%s is a smart terrain: %s", nameid(name, id), text)
    elseif (cls == clsid.online_offline_group_s) then
        local comm = se_obj.player_id
        local sq = paw and gts("st_paw_squad") or "squad"
        text = gts(comm)
        text = text.." "..sq
        if debuglogs then
            text = text..": "..name
        end
        vl("%s is NPC squad with faction %s: %s", nameid(name, id), comm, text)
    elseif IsInvbox(nil,cls) then
        local obj 	= get_object_by_id(id)
        local sec 	= obj and obj:section()
        text 		= get_stash_hint(id)
        local pre 	= ""
        if name and (not text) or (text == "") then
        	text 	= find_best_localization(obj, name, sec)
        end

        if (not text) or (text == name) then
        	if name then 
        		text = nil
	            if name:find("smart_terrain") and name:find("_box") then
	                local smartname = name:sub(1,-5)
	                local smartloc 	= "st_"..smartname.."_name"
	                smartname 		= gts(smartloc)
	                if smartloc ~= smartname then
	                	pre 		= smartname:gsub("%."," - ")
	                end
	            end
	        end
        	
	        local unknown 	= gts("st_paw_unknown")
	        if (unknown == "st_paw_unknown") then unknown = "Unknown" end
	        local stash 	= gts("st_paw_stash")
	        if (stash == "st_paw_stash") then stash = "stash" end
			text = string.format("%s%s %s", pre, unknown, stash)

            dl("No localization found for stash %s - defaulting", name)
            --text = paw and (gts("st_paw_unknown").." "..gts("st_paw_stash")) or "Unknown stash"
        end
        vl("%s is an inventory_box stash: %s", nameid(name,id),text)
    elseif IsStalker(nil,cls) or (cls == clsid.script_trader) then
        text = se_obj:character_name()
        vl("%s is a stalker: %s", nameid(name, id), text)
    else
        local obj = get_object_by_id(id)
        local section = obj and obj:section()
        if not section then
            return text
        end
        if IsMonster(nil,cls) then
            --[[
                Hack adapted from ui_enemy_health.script
                This logic acts as a translation layer for
                any monster kind/species that doesn't line
                up with the name of its encyclopedia entry
            --]]
            local special_cases = {
                dog             = "blind_dog",
                bird            = "crow",
                giant           = "pseudogiant",
                SM_KARLIK       = "karlik",
                SM_LURKER       = "lurker",
                SM_POLTER_G     = "poltergeist",
                SM_PYRO_G       = "pyrogeist",
                SM_PSEUDO_G     = "pseudogeist",
                SM_PSYSUCKER    = "psysucker",
            }
            if string.find(section,'rotan') then
                text = "rat"
            elseif string.find(section,'psy_dog') then
                text = "psydog"
            else
                local what = ini_sys:r_string_ex(section,"kind") or ini_sys:r_string_ex(section,"species") or nil
                text = special_cases[what] or what
            end
            text = text and gts("encyclopedia_mutants_"..text)
            vl("%s is a creature: %s", nameid(name, id), text)
        else
            text = find_best_localization(obj, name, section)
            if not text then
                text = name
                dl("No localization or other name found for object %s", nameid(name, id))
            end
        end
    end

    dl("safename returns %s for %s", text, name)
    return text
end

function obj_name_and_id(obj_or_string, id, use_section)
	-- I very frequently log objects by noting their name and id like so: esc_trader24869 (24869)
	-- This requires nil-checking and has let crash errors slip through before just from logging
	-- So I can alias this function to something short and use it for safe logging
	local obj, name
	id 			= tonumber(id)
	if obj_or_string and (type(obj_or_string) == "string") then
		name 	= obj_or_string
	else
		obj 	= obj_or_string or (id and get_object_by_id(id))
		id 		= id or (obj_or_string and obj_or_string:id())
		name 	= obj and (use_section and obj:section() or obj:name())
	end
	return string.format("%s (%s)", name, id)
end

function load_female_name_strings()
	if not getstrtbl_support() then
		dl("load_female_name_strings: function get_string_table is unsupported by GAMMA or vanilla, aborting")
	return end
	-- Compile list of female names starting with "name_woman_"
	-- Mainly for Dux's character kit
	dl("load_female_name_strings: parsing any recognized female names in the character list")
    local t = get_string_table()
    if not female_names then female_names = {} end
    for k, v in pairs(t) do
        if k:find("name_woman_") then
        	local name = str_explode(v," ")
            female_names[k] = name[1]
            --This log line will be very noisy on every load, only enable for targeted troubleshooting
            --vl("Found female name: %s = %s", k, v)
        end
    end
end

function on_game_start()
	-- Disabled by default, but feature is fully working and can be used by launching load_female_name_strings()
	-- RegisterScriptCallback("actor_on_first_update", load_female_name_strings)
end

